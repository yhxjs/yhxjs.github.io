<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhxjs的博客</title>
    <link>https://yhxjs.github.io/</link>
    
    <atom:link href="https://yhxjs.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>yhxjs的博客</description>
    <pubDate>Sat, 23 Mar 2024 11:52:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>再识MyBatis-Plus</title>
      <link>https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/</link>
      <guid>https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/</guid>
      <pubDate>Sat, 23 Mar 2024 09:42:21 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本人之前学习过 MyBatis-Plus，但实际自己开发还是用的 MyBatis，基本就是简单 sql，因此用注解进行开发，手写 sql 也</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本人之前学习过 MyBatis-Plus，但实际自己开发还是用的 MyBatis，基本就是简单 sql，因此用注解进行开发，手写 sql 也还好，故并未采用 MyBatis-Plus进行开发，但新入职的公司需要用到，于是进行重温，才有了这篇简略的记录。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正如<a class="link"   href="https://mybatis.plus/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>所说的愿景：成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。MyBatis-Plus 相当于 MyBatis 的增强版插件，可以一起使用，事半功倍，省去编写简单 sql 的功夫，具体介绍可自行去官网查看。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ol><li><p>@TableName</p><p>标识实体类对应的数据库表。</p></li><li><p>@TableId</p><p>标识主键属性。</p></li><li><p>@TableField</p><p>标识对应数据库字段。</p></li><li><p>@TableLogic</p><p>标识删除类型。</p></li></ol><h3 id="基本crud"><a href="#基本crud" class="headerlink" title="基本crud"></a>基本crud</h3><p>所有的基本 crud 都在 BaseMapper 接口中定义，只需要继承并指定具体实体类即可。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>BaseMapper 接口如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 更新</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity)</span>;</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量查询</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询一条数据</span></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询记录总数</span></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">selectPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">selectMapsPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;奕凰轩祭侍&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">userMapper.insert(user);</span><br><span class="line"><span class="comment">// 获取插入数据的主键 ID</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> user.getId();</span><br></pre></td></tr></table></figure></div><p>一般使用@TableId(type &#x3D; IdType.AUTO)来指定数据库主键，然后数据库还存在另外一个唯一标识符，一般由后端进行UUID或者雪花算法生成，该标识符相当于业务中使用的主键。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">10059249854L</span>); <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><p>根据主键删除，也可以直接传入对象，会根据标识的主键属性进行删除，以及可以根据其他条件删除，条件构造在<a href="#%E6%9F%A5">查询</a>中介绍。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">10059249854L</span>);</span><br><span class="line">user.setGender(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 实际执行的 SQL : UPDATE user SET gender=1 WHERE id=10059249854;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.updateById(user);  <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>在使用前需要进行 sql 条件语句的构建，有三种条件构建格式：</p><ol><li>常规条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapperr&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapperr</span>&lt;User&gt;();</span><br><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//今年刚满18岁~</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>lamda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lambda().eq(User::getName,<span class="string">&quot;劳大&quot;</span>); <span class="comment">//see you again（</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>lambda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lt(User::getPlay, <span class="string">&quot;Genshin Impact&quot;</span>); <span class="comment">//原神启动！</span></span><br></pre></td></tr></table></figure></div><h5 id="常见的单条件查询"><a href="#常见的单条件查询" class="headerlink" title="常见的单条件查询"></a>常见的单条件查询</h5><h6 id="lt匹配"><a href="#lt匹配" class="headerlink" title="lt匹配"></a>lt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="le匹配"><a href="#le匹配" class="headerlink" title="le匹配"></a>le匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.le(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="eq匹配"><a href="#eq匹配" class="headerlink" title="eq匹配"></a>eq匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//等同于=18</span></span><br></pre></td></tr></table></figure></div><h6 id="gt匹配"><a href="#gt匹配" class="headerlink" title="gt匹配"></a>gt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="ge匹配"><a href="#ge匹配" class="headerlink" title="ge匹配"></a>ge匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ge(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="ne匹配"><a href="#ne匹配" class="headerlink" title="ne匹配"></a>ne匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ne(User::getAge,<span class="number">18</span>); <span class="comment">//等同于!=18</span></span><br></pre></td></tr></table></figure></div><h6 id="between匹配"><a href="#between匹配" class="headerlink" title="between匹配"></a>between匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.between(User::getAge, <span class="number">17</span>, <span class="number">19</span>); <span class="comment">//等同于&gt;=17 &amp;&amp; &lt;= 19</span></span><br></pre></td></tr></table></figure></div><h6 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a>like匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.likeLeft(User::getName, <span class="string">&quot;奕&quot;</span>); <span class="comment">//相当于like %奕，还有like对应like %奕%、likeRight对应like 奕%</span></span><br></pre></td></tr></table></figure></div><p>还有其他的一些条件，例如orderByAsc对应升序等，具体可以自己操作看看。</p><h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>且</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">17</span>).lt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><p>或</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">17</span>).or().gt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h5><p>可以通过 condition 参数动态拼接条件，例如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(minAge != <span class="literal">null</span>, User::getAge, minAge);</span><br><span class="line">userWrapper.lt(maxAge != <span class="literal">null</span>, User::getAge, maxAge);</span><br></pre></td></tr></table></figure></div><h5 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h5><h6 id="查询部分属性"><a href="#查询部分属性" class="headerlink" title="查询部分属性"></a>查询部分属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(User::getName, User::getAge);</span><br></pre></td></tr></table></figure></div><h6 id="查询未定义属性"><a href="#查询未定义属性" class="headerlink" title="查询未定义属性"></a>查询未定义属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(<span class="string">&quot;count(*) as count&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">   .groupBy(<span class="string">&quot;age&quot;</span>)  <span class="comment">//分组字段</span></span><br><span class="line">           .having(<span class="string">&quot;COUNT(*)&gt;5&quot;</span>); <span class="comment">// 添加having筛选条件</span></span><br></pre></td></tr></table></figure></div><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子查询 select id from user where id &lt;= 10059249854</span></span><br><span class="line">userWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 10059249854&quot;</span>);</span><br><span class="line">userWrapper.select(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">userWrapper.last(<span class="string">&quot;LIMIT 10&quot;</span>);</span><br><span class="line"><span class="comment">// 实际执行 SQL : SELECT name,age FROM user WHERE (id IN (select id from user where id &lt;= 10059249854)) LIMIT 10;</span></span><br></pre></td></tr></table></figure></div>]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/">后端</category>
      
      
      <category domain="https://yhxjs.github.io/tags/Java/">Java</category>
      
      <category domain="https://yhxjs.github.io/tags/MyBatis-Plus/">MyBatis-Plus</category>
      
      
      <comments>https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ND协议</title>
      <link>https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/</link>
      <guid>https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/</guid>
      <pubDate>Wed, 06 Mar 2024 04:35:35 GMT</pubDate>
      
      <description>邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</p><p>什么是邻居？即一个链路上的相邻主机或者路由器，主机与主机，主机和路由器，路由器和路由器可以互为邻居。</p><p>地址解析放在ICMP层，通过使用ICMPv6报文实现功能。</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format.png"                      width="400px" height="auto" alt="IPv6报头格式"                ><figcaption>IPv6报头格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format_wireshark.png"                      width="550px" height="auto" alt="IPv6报头(Wireshark)"                ><figcaption>IPv6报头(Wireshark)</figcaption></figure><p><strong>版本号</strong>(version)：同IPv4，指示IP版本</p><p><strong>流量等级</strong>(Traffic Class)：类似IPv4中的TOS字段，指示IPv6数据流通信类别或优先级</p><p><strong>流标签</strong>（FlowLabel)：标记需要特殊处理的数据流，用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据</p><p><strong>传输数据长度</strong>(Payload Length)：包含有效载荷数据的IPv6报文总长度</p><p><strong>下一个报头</strong>(Next Header)：该字段定义了紧跟在IPv6报头后面的第一个扩展报头(如果存在)的类型，或者上层协议数据单元中的协议类型</p><p><strong>跳限制</strong>(Hop Limit)：类似于IPv4中的TTL字段，它定义了IP数据包所能经过路由器的最大跳数</p><p><strong>源地址</strong>(Source Address)：128bit的IPv6地址</p><p><strong>目的地址</strong>(Destination Address)：128bit的IPv6地址</p><h4 id="与IPv4对比"><a href="#与IPv4对比" class="headerlink" title="与IPv4对比"></a>与IPv4对比</h4><p><strong>IPv6报头结构的改善</strong>：基本的IPv4报头长度为20个字节，基本的IPv6报头长度为40个字节</p><p><strong>取消了IP的校验</strong>：由于2层与4层的校验已经足够健壮，取消了IP的三层校验</p><p><strong>取消中间节点的分片功能</strong>：分片重组功能由源端实现，通过Path MTU机制来发现路径MTU</p><p><strong>定义最长的IPv6报头</strong>：有利于硬件的快速处理，中间节点节约大量资源</p><p><strong>安全选项的支持</strong>：IPv6提供了对IPsec的完美支持，上层协议省去大量安全选项，例如OSPFv3取消了认证</p><p><strong>增加流标签</strong>：提高QoS效率</p><h3 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h3><p>邻居发现协议定义了五种不同的ICMP包类型：路由请求RS（Router Solicitation）和路由告知RA（ Router Advertisement）消息，邻居请求NS（Neighbor Solicitation）和邻居告知NA（Neighbor Advertisements）消息，以及重定向（Redirect message）消息。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_packet_type.png"                      width="450px" height="auto" alt="ND协议报文类型"                ><figcaption>ND协议报文类型</figcaption></figure><h4 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h4><p>当一个接口变为可用时，主机可以发出路由请求消息来要求路由器马上生成路由告知（ Router Advertisement）消息，而不是等它的下一个固定生成时间。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./rs_packet_format.png"                      width="500px" height="auto" alt="RS报文格式"                ><figcaption>RS报文格式</figcaption></figure><p>源地址：接口的地址或者全0</p><p>目的地址：全部路由器组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：133</p><p>ICMP6 CODE：0</p><h4 id="路由告知"><a href="#路由告知" class="headerlink" title="路由告知"></a>路由告知</h4><p>路由器周期地用此消息通告它们的存在及各种链路参数和互联网参数，或响应Router Solicitation消息。Router Advertisements包括前缀，这些前缀用于确定是否另一个地址共享相同链路(on-link确认)和&#x2F;或地址配置，建议的跳数限制值，等等。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ra_packet_format.png"                      width="500px" height="auto" alt="RA报文格式"                ><figcaption>RA报文格式</figcaption></figure><p><strong>当前跳数值</strong>（Current Hop Limit）字段，用法如下：链路上的结点发送IPv6报文时，会用该字段的值来填充IPv6报文头的跳数限制字段。如果该字段值为0，说明路由器并不确定该值为多少。</p><p><strong>M位</strong>被称为管理地址配置（Managed Address Configuration）标志位，当该位被置1时，说明DHCPv6可用于结点地址配置。</p><p><strong>O位</strong>被称为其它有状态配置（Other Stateful Configuration）标志位，当该位被置1时，说明DHCPv6可用于获得非地址相关的配置信息，如DNS名称服务器的IPv6地址。</p><p><strong>路由器生命期</strong>字段是一个16位无符号数，计量单位为秒，它指示链路上的结点把该路由器做为默认路由器的时间为多长，最大值为18.2小时。该字段为0表示发送该报文的路由器不做为默认路由器，这时，结点在发送报文时，不会选择该路由器做为下一跳路由器。</p><p><strong>可达时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在收到一个邻居可达的确认报文后，认为该邻居仍然可达的时间。在这段时间内，如果结点没有再收到邻居可达的确认报文，结点会执行邻居不可达检测以确认邻居是否可达。该字段为0表示路由器不指定该参数。</p><p><strong>重传时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在执行邻居不可达检测或者地址解析时，连续发送邻居请求报文中间的时间间隔。该字段为0表示路由器不指定该参数。</p><p><strong>前缀</strong>选项，通过该选项，路由器向链路上通告本链路所有可达的前缀，并且通过标志位指出哪些前缀可用于结点的地址自动配置。</p><p>源地址：接口的本地链路地址</p><p>目的地址：发送路由器请求的主机的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：134</p><p>ICMP6 CODE：0</p><h4 id="邻居请求"><a href="#邻居请求" class="headerlink" title="邻居请求"></a>邻居请求</h4><p>节点发送该消息以确定某个邻居的链路层地址，或者用来验证通过缓存里的链路层地址是否依然能够到达该邻居。也经常用来做地址重复检测。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ns_packet_format.png"                      width="500px" height="auto" alt="NS报文格式"                ><figcaption>NS报文格式</figcaption></figure><p><strong>目标地址</strong>字段是一个IPv6地址，一般与目的地址相同，填的是请求的地址，该字段不能是多播地址。</p><p><strong>源链路层地址</strong>选项，协议建议携带，一般为源MAC</p><p>源地址：接口的地址或者未指定地址</p><p>目的地址：目标地址或者目标地址对应的请求节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：135</p><p>ICMP6 CODE：0</p><h4 id="邻居告知"><a href="#邻居告知" class="headerlink" title="邻居告知"></a>邻居告知</h4><p>邻居请求消息的回应。节点也可以发送非请求的Neighbor Advertisements，通知链路层地址改变。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./na_packet_format.png"                      width="500px" height="auto" alt="NA报文格式"                ><figcaption>NA报文格式</figcaption></figure><p><strong>R位</strong>是路由器（IsRouter）标志位，当这个标志位置1时，说明发送者是路由器。</p><p><strong>S位</strong>是被请求（Solicited）标志位，当这个标志位置1时，说明发送者发送邻居通告报文是因为接收到一个邻居请求报文，这个邻居通告报文的目的地址是单播地址；如果邻居通告报文目的地址是多播地址，则该位置0。</p><p><strong>O位</strong>是覆盖（Override）标志位，当这个标志位置1时，接收到该报文的结点查看邻居缓存，如果缓存中有发送该邻居通告报文结点的链路层地址，则更新之。否则忽略该邻居通告报文。</p><p><strong>目标地址</strong>字段是一个IPv6地址，如果邻居通告报文是由邻居请求报文触发的，则该地址是邻居请求报文中的目标地址。如果邻居通告报文是因为链路层地址变化触发的，则该地址是和变化的链路层地址相关的IPv6地址。该字段不能包含一个多播地址。</p><p><strong>目标链路层地址</strong>选项。如果邻居通告报文目的地址是多播地址，必须包含目标链路层地址选项。</p><p>源地址：接口的地址</p><p>目的地址：发送邻居请求节点的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：136</p><p>ICMP6 CODE：0</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>由路由器使用，用于通知主机有到目的地的较好的第一跳。路由器收到一个报文后，如果发现报文的目的地址和源地址是同一个链路的，或者到目的地址有一个更优的路由器，都会发送重定向报文。重定向报文的源地址必须使用链路本地地址。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./redirect_packet_format.png"                      width="500px" height="auto" alt="重定向报文格式"                ><figcaption>重定向报文格式</figcaption></figure><p><strong>重定向报文头</strong>选项包含了引发重定向报文的原始报文的内容。</p><p>源地址：接口的链路本地地址</p><p>目的地址：触发重定向的数据包的源地址</p><p>跳数：255</p><p>ICMP6 TYPE：137</p><p>ICMP6 CODE：0</p><blockquote><p>主机不能发送路由器通告，路由器不能发送路由器请求。</p><p>主机不能发送重定向报文，路由器不能处理重定向报文。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><a href="#%E8%A7%A3%E6%9E%90%E9%82%BB%E5%B1%85%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80">解析邻居的链路层地址</a></li><li><a href="#%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%EF%BC%88DAD%EF%BC%89">地址冲突检测（DAD）</a></li><li><a href="#%E9%82%BB%E5%B1%85%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%A3%80%E6%B5%8B%EF%BC%88NUD%EF%BC%89">邻居不可达检测（NUD）</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E5%89%8D%E7%BC%80%E5%8F%91%E7%8E%B0">路由器和前缀发现</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91">路由重定向</a></li></ul><h3 id="解析邻居的链路层地址"><a href="#解析邻居的链路层地址" class="headerlink" title="解析邻居的链路层地址"></a>解析邻居的链路层地址</h3><p>IPv6取消ARP协议，通过邻居请求（NS）和邻居通告（NA）报文来解析三层地址对应的链路层地址。</p><p>邻居请求NS使用组播，比ARP效率高，邻居公告NA返回则直接使用单播。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_address_resolution.png"                      width="650px" height="auto" alt="IPv6地址解析"                ><figcaption>IPv6地址解析</figcaption></figure><p>一整个ping的过程跟ARP一样相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show ipv6 nd-packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_ipv6_nd_packet_history.png"                      width="100%" height="auto" alt="show ipv6 nd-packet history"                ><figcaption>show ipv6 nd-packet history</figcaption></figure><h3 id="地址冲突检测（DAD）"><a href="#地址冲突检测（DAD）" class="headerlink" title="地址冲突检测（DAD）"></a>地址冲突检测（DAD）</h3><p>DAD首先发送源地址为未分配地址，目的地址为要进行DAD检测的地址所对应被请求节点的组播地址，然后目标IP携带要进行DAD检测的地址的NS报文，若有冲突，则被请求节点发送源地址为DAD检测的地址，目的地址为全局组播地址，并目标IP携带DAD检测的地址，以及源链路层选项附上自己的链路层地址的NA报文。</p><h3 id="邻居不可达检测（NUD）"><a href="#邻居不可达检测（NUD）" class="headerlink" title="邻居不可达检测（NUD）"></a>邻居不可达检测（NUD）</h3><p>NUD首先发送源地址为接口的链路本地地址，目的地址为要进行NUD检测的单播地址，然后目标IP携带要进行NUD检测的单播地址的NS报文，若可达，则被请求节点发送源地址为NUD检测的地址，目的地址为NS的源地址，并目标IP携带NUD检测的地址，并将S位置为1的NA报文。</p><h3 id="路由器和前缀发现"><a href="#路由器和前缀发现" class="headerlink" title="路由器和前缀发现"></a>路由器和前缀发现</h3><p>当主机未配置单播地址时，就会发送RS，路由器和本地链路节点会发送RA，以使主机进行自动地址配置。</p><p>当主机接收到RA后，使用其中的前缀信息和本地接口ID自动形成IPV6地址，还可根据其中的路由器信息设置默认路由器。</p><p>RS可定位邻居路由器，同时学习和自动配置有关的前缀和配置参数。</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>假设链路上一个结点发送一个报文，源地址是A，目的地址是B，路由器收到该报文后，发送一个重定向报文，重定向报文中目标地址字段是C，该地址是告诉结点更好的下一跳地址，目的地址字段是B，该地址是结点发出去报文的目的地址，和上面的B是同一个地址。如果C和B不同，说明C地址是一个更优的路由器地址，如果C和B相同，说明B地址是同一个链路上结点的地址。</p><h2 id="表项状态"><a href="#表项状态" class="headerlink" title="表项状态"></a>表项状态</h2><p>ND表项有五种状态：</p><p><strong>INCOMPLETE</strong>（未完成的）地址解析在进行中，邻居的链路层地址还没有被确定。</p><p><strong>REACHABLE</strong>（可到达的）粗略讲，已知邻居最近(几十秒前)是可达的。</p><p><strong>STALE</strong>（陈旧的）邻居不再被认为是可达的，但是直到流量发送给该邻居时，不应当尝试改变它的可达性。</p><p><strong>DELAY</strong>（延时）邻居不再被认为是可达的，最近流量已经发送到该邻居。然而，不立即探测该邻居的可达性，延时一段时间发送探测消息，以便给上层协议一个机会提供可达性确认。</p><p><strong>PROBE</strong>（探测）邻居不再被认为是可达的，并且发送了单播NS探测消息以便验证可达性。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_entry_state.png"                      width="700px" height="auto" alt="ND表项状态机"                ><figcaption>ND表项状态机</figcaption></figure><p><strong>EMPTY</strong>状态代表邻居表项不存在或者被删除。发送IPv6报文时，如果下一跳不在邻居表中，那么创建一条状态为INCOMPLETE的邻居表项，发送多播邻居请求报文，每隔1秒钟发一次，连发3次，直到收到应答为止。如果连发3次邻居请求报文都没有收到应答，那么删除邻居表项。如果收到应答，邻居表项的状态迁移到REACHABLE。</p><p><strong>REACHABLE</strong>状态的持续时间缺省值是30秒，即在30秒钟内认为邻居可到达，30秒以后，迁移到STALE状态。如果在REACHABLE状态，收到邻居请求或者公告，发现MAC地址变化了，表项迁移到STALE状态。</p><p>处于<strong>STALE</strong>状态，如果发送报文时命中这条邻居表项，那么迁移到DELAY状态，准备进行邻居不可达检测。对于STALE状态的持续时间，RFC没有规定。</p><p>处于<strong>DELAY</strong>状态，5秒钟以后进入PROBE状态。</p><p>处于<strong>PROBE</strong>状态，开始进行邻居不可达检测，发单播邻居请求，每秒发一次，连发3次，直到收到应答为止。如果收到应答，迁移到REACHABLE状态。如果连发3次仍然没有收到应答，就认为邻居不可达，删除邻居表项。</p><p>收到邻居请求，创建新的邻居表项，状态必须是STALE，因为收到邻居请求只能证明对方发送的报文可到达自己，而不能确定自己发送的报文能到达对方。</p><p>在进行邻居不可达检测时，结点发送的邻居请求报文可以包含源链路层地址选项，也可以不包含。如果邻居请求报文中没有包含源链路层地址选项。接收结点在发送邻居通告报文时，可能还需要执行地址解析操作。所以RFC2461建议邻居请求报文发送者包含源链路层地址选项。</p>]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/">通信</category>
      
      
      <category domain="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/">通信</category>
      
      <category domain="https://yhxjs.github.io/tags/ND/">ND</category>
      
      
      <comments>https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ARP协议</title>
      <link>https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/</link>
      <guid>https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/</guid>
      <pubDate>Tue, 05 Mar 2024 13:11:28 GMT</pubDate>
      
      <description>ARP即地址解析协议，将IP地址解析为MAC地址。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARP即地址解析协议，将IP地址解析为MAC地址。数据要在以太网中传输，需要完成以太网封装，这项工作由网络层负责。要完成以太网的数据封装，需要知道目的设备的MAC地址。</p><p>注意：ARP报文不能穿越路由器，不能被转发到其他广播域</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format.png"                      width="400px" height="auto" alt="ARP报文格式"                ><figcaption>ARP报文格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format_wireshark.png"                      width="450px" height="auto" alt="ARP报文格式(Wireshark)"                ><figcaption>ARP报文格式(Wireshark)</figcaption></figure><p><strong>硬件类型</strong>：表示硬件地址的类型（其中，值为1表示以太网地址，其他还可能表示令牌环地址）。</p><p><strong>协议类型</strong>：表示要映射的协议地址类型（其中，0x0800表示IP地址，其他还可能是ICMP&#x2F;IGMP）。</p><p><strong>硬件地址长度</strong>：指出该报文中硬件地址的长度（ARP报文中，它的值为6）。</p><p><strong>协议地址长度</strong>：指出该报文中协议地址的长度（ARP报文中，它的值为4）。</p><p><strong>op</strong>：操作字段，共有4种类型（1.ARP请求，2.ARP应答，3.RARP请求，4.RARP应答）。</p><p><strong>源MAC地址</strong>：发送方设备的硬件地址。</p><p><strong>源IP地址</strong>：发送方设备的IP地址。</p><p><strong>目的MAC地址</strong>：接收方设备的硬件地址。</p><p><strong>目的IP地址</strong>：接收方设备的IP地址。</p><p>ARP报文解析主要关心的是后五个字段。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_workflow.png"                      width="450px" height="auto" alt="ARP工作流程"                ><figcaption>ARP工作流程</figcaption></figure><ol><li>先查看ARP表，如果ARP表中没有目的IP地址对应的MAC表项，则发送ARP请求包</li><li>源主机广播发送ARP request 数据包，请求目的主机的MAC地址</li><li>同网段内的所有主机都能收到ARP request请求包，但只有目的主机才会回复ARP reply数据包</li><li>源主机收到ARP reply后，将目的主句的IP-MAC对应关系添加进ARP表中，完成数据的以太网封装，进行数据交互</li></ol><p>通过Wireshark抓包可以看到整个过程。</p><p>IP为192.168.56.105的主机A广播目的IP为192.168.56.1的ARP请求，当IP为192.168.56.1的主机B收到该请求后，应答自己的MAC地址给主机A：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_request_wireshark.png"                      width="450px" height="auto" alt="ARP请求(Wireshark)"                ><figcaption>ARP请求(Wireshark)</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_reply_wireshark.png"                      width="450px" height="auto" alt="ARP应答(Wireshark)"                ><figcaption>ARP应答(Wireshark)</figcaption></figure><p>而一整个ping的过程相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show arp packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_arp_packet_history.png"                      width="100%" height="auto" alt="show arp packet history"                ><figcaption>show arp packet history</figcaption></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table><thead><tr><th>类别</th><th>含义</th><th>作用</th><th>属性</th></tr></thead><tbody><tr><td>静态</td><td>手动配置（优先级高）、认证下发</td><td></td><td>永久、表项不更新</td></tr><tr><td>动态</td><td>通过报文学得</td><td></td><td>老化、表项更新</td></tr><tr><td>可信任</td><td>客户端认证时候，会在网关交换机上添加arp，该arp是真实有效的</td><td>位于交换机端ARP表项中，防止ARP欺骗</td><td>具有静、动态属性</td></tr><tr><td>免费</td><td>源、目的IP都是自己的广播arp报文</td><td>IP地址冲突检测、MAC地址变化通知其他设备</td><td>可以定时发送免费ARP，若无IP冲突不能应答</td></tr><tr><td>代理</td><td>源目的不属于同一网段，设备知道目的ip的路由信息时，则进行代替arp响应</td><td></td><td></td></tr><tr><td>本地代理</td><td>以网关自身的MAC回应本网段的IP地址的ARP请求</td><td>用于二层端口隔离时，主机先获取网关的mac，之后在网关设备上报文会被上送三层，通过三层路由实现同一网段内主机通讯</td><td></td></tr><tr><td>any ip</td><td>任意IP地址都可以上网，ARP请求的源IP和设备不在同网段，且目的IP可能不是自己，但网关仍然发送ARP应答，并且为主机的IP地址生成直连路由</td><td>场景：无需修改IP与网关即可正常上网，例如网吧、酒店等地方</td><td></td></tr><tr><td>探测</td><td>源IP为0，目的IP为待探测地址</td><td>收到应答则说明该IP被使用</td><td></td></tr></tbody></table><h2 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h2><p>首先底层对报文进行处理，将二进制报文转化为可处理的格式，然后交由控制层进行处理。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_processing.png"                      width="300px" height="auto" alt="ARP报文处理逻辑"                ><figcaption>ARP报文处理逻辑</figcaption></figure><ol><li><p>操作码op，源接口和二层接口协议状态，格式检查，MAC合法性，IP合法性，免费ARP检查，ACL检查等，经过上述一系列检查后，源IP和目的IP都不为0，且都是合法的。</p></li><li><p>判断源IP和源接口是否处于同一网段，主要区分就是VRRP的虚IP和开启了any-ip-arp要进行特殊处理，经过判断后，如果是同一网段就进行处理，否则就丢弃即忽略。只要源IP和本机IP是一致的，都认为IP地址冲突，查看源MAC和源接口的MAC是否相同，如若相同，则说明是自己发的，不进行处理，否则进行冲突应答。如果目的IP为本机IP，判断是否是发给自己的，如果是则继续进行处理，否则进行相关的代理。</p></li><li><p>普通处理</p><p>处理request报文：</p><ol><li><p>目的地址是我们的IP，则不更新表项，只应答。</p></li><li><p>目的地址不是我们的IP，则不应答。</p></li><li><p>如果MAC地址不一样，需要代理冲突应答，并走老化逻辑。</p></li></ol><p>处理reply报文：如果源IP匹配到了表项或者开启了某种学习才进行表项的学习更新。</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/">通信</category>
      
      
      <category domain="https://yhxjs.github.io/tags/ARP/">ARP</category>
      
      <category domain="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/">通信</category>
      
      
      <comments>https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学习路线</title>
      <link>https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</link>
      <guid>https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</guid>
      <pubDate>Sun, 03 Mar 2024 10:39:23 GMT</pubDate>
      
      <description>加密内容，输入密码后方可查看。</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重新输入。" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="88247cd0df9052ab461d05c4cab63bb2dc7bbf598349d201fd03300c4f8fef9c">7e302a64c19ca2d3ce010e4131597270786b1bb1aaf244198f42d692eb66feb4bc070be16da0a052557145b88b06a7387e3029ffbbbb6130fe0a097cb8511ca043a3a1ac49a1c8d6e3209fbd33f4b5ec808511bbbcbf9eed5db3d988448945fdaf4926c793654b80518ba075a6b012b2b528ba26ffb32b6aa542d403457d3f99e138490ec2452377bb9d0aa0876d21a39ad74194eaaae82bac2f29811278064ba1ad8d323242753fcec2d647caf57e8c68a1631c6ea4b6795455aa5bddb4a7a5a6984c24e714e3a1d4b6a1f5b40d103dff22152cb5767dc0a07e63d419d50e66a3bacd98da6b63001b6dca188b97684ded665fa39e575da0bb50467826e5ab6c4e9bc7c13e5ffd851a763e80e8888f1eb158ace8a3adae10e4952a59972ded7b629425a5ba52a89aa1eb7f33f9f7a05e2282c8dd2eebdff6cbc5ff68888ad769e483801c95580f6dd44181059e723b45f1fad1441331cea7c03cf97f53e7bbceb448a73794b615a27670c7f537a9c0a360483360caa5392103a0a8887c3638cb9e49ef68db8040d2bfba1151e13c678a03996de7eb7942afe332a110eac08fa47e6c6e0ac1170d4ede7d0cc4e3cfc361c8e7e46aa9772c81e54cc1b1860fd6d08f2eb449ec0070f9f3a8162522a544bab118fb9a3234c10d03c9fdef4589ca16f812d81e033618be3866d1dc6668f8a08cb1cd9cefc5c7f6dcfe027c736e704176c9c3f75175d7c8c0852104d043665cbe3e2aca512baaf852962b738a979e4a0c0aae312650f44bc3239b826102c17e1e9d7f63fe28418a2487b913515c15782cd7a799666617bb8c49f1f6b6f4e4c758a8ba1f52b017517a27f5824b06817b4c24374441f553427fc8caf213d20e780d69ca47bc27a799bff3d895b50b5dc1a9773881963fa87203c2d78abed04f544dd4302843677e7e3fefac05e85f4879404a1fae894d13a6ca799b0b6e2c9f6222c7973239865cf5f59d645d62349f8645c2e852d24366c5149903c8042effb49e3b513f7138905e63070c65e09036604217472a4e1b29e6f6fe3e4b5c6ec873275af907d941e05fea1c9a009519b4b22d60c43f7661efea590b5a85170908fde78956f72a07c619eab9211dc2b2c7deb69fb6924b659d0e9e620f264c67af600828e4f3271a017f36249688ef1c45fcb2e0ad046ea84df8b3453e599365a3ed4a2d3123e88c84d23fb5d252bffb78ce4f7743912face06c5f0509b96c59f7ab815c00c5c7ff19d4edf909f0797610aacd54e12819bd04e9322ab69c9c0a969191ada2d3926f588e7ad54cd323632033cbec7c345891d53cf2c7dd566a888fbff271258b42f01cfaef3b87d6b660a928889bddbcede75e86cc0b28e8a7e5f8cfbfb75743436c86a48116ca0a24126bcd4790114ad22f2254d4f54ae663437574bcbd53a3a7a81dc066e2b37601836679b9eb5bf061368d82d99fd3ec79037eb24bcaf6130d7eedb69eef6fc0d3a3bcf197f4d243a61f272407c7399a446da734325a3d057459ae9b486045bd55d2d5e3c50c2aca45f13257a3d916dec48ce80382f53e5295a691c4842c74b02407228849e96782179788918da40ef252656db9e7c524ba793e5965dbcfb4a8e8e0d5d3a3fc0e155f5ff2b3debbf4f0d261bf6c61e251e28f068d212722aca95a476410f12aa2580dfbb0ef0163532a61925506e645da8dc4cd5ae960ccbd8bd05094ba81016a3ee4181bd7c383e0b5bd573e5eef0ef546b1a0846af0c6b3b583a2cbad7dcf7aabc61a27bd36aa997a1c4508ebcfec0459960cfc35bc55477158a0923d1e79fd04e5414b6e219df9727d7030a2b05c37243264470b9c491b71b840c499d06d4ff19232b800579722d0fb8c281df6b5a54e4b0fe252fecc5c3dd081da3fcdb629c8d4f274d003155890883791c1b6e731ea0bd2f297cde53a49d1aea1233a39103cab73d3454e3a6ae70a310d6be786d4d9dc40d2b7d74bffec2a76d3444fabf4309ea25fe6113f2b771125804c24394966bfc50ab206519ba84bbccefcb715d69a020651fe01f797486c12c54405bb0ca40a50a7b193e5e3617178d982d35370517af59205004ae784934c108fba3568433b7eaaf184fef2a88342af90a2cf1f92d5f78b293e5044b47d4e064ff496a05714e531619477eb38953faed1ea67380fa73df0afec0e415978d1afa6b9a2fb952575a197bb86351946df3965dd858bdbc55ff067b26c252dc7cc13fcd3f3206f82ce231f5970e43aa65dc9c53cefd494b30776d9128fdbdc9eec0f969d53b2905a47a92e4e19ad224b7ab950344043c6d53cdaec9e739a4968d6d86f2c833d283d9fb88ce043fb203fbb7bbea6c9db3683efaf2426a8847df5730c920a637f4f324bf7dfefa70f7096fd9fbc0481ca5fc0b5b89d0b605c428ebe71d1c59c06620670f316d0c9e90fa6e29006446d2b3af79fc84ff604c4192db8548f1c2373bbd401ea9b3153195a0bf7a6e2858ecbacbec605fe763840d8eb1b899750e6064b890a362398871604d7b8bad7065e5cc6dc6c19d9ee8723161c7989723b315608bd4e2b37f9c7c44776d925f120c4cd1408a62dc8e57fce927789a09aa54e46875cd78f5af37720d890113b24e68a12d97da5f4a395a383b242e1570c31160f0a4c948c810dc59979d51971f90a6c5be91e7ef1abe178e25978a2a187872b6d0fb6086ec078a83111cb223f9f2843ecf636ef594c44c48409f8a9cc71d55d1c40266356c1b32f7e3753cfaa4670976b6f5245de0eaac54f9d8b4d36c166673749114159c186212d59f6f486141a314a43fd0153939a861ac8d09fcd911f0e6f006d019861f2e22f8a53ddbd7706982727fb759e7989250580a723d714e81c1772ebb0d74c5795d2a5d881724ae5a574e22402ad02097c64fad3d2f921c08ea52a4e4ba5d0db166b3a54e8e785b09366b8dd1819e312aaeb2b93c8edba305f9abda30016a49b2727df106fa7ead96e9dafc3fcfb2b0952f0020cdb48f3db9b001a8588fa411fda26161e528481aed14dc667175a8d8f262642e8313dd0c15e924fba32c70d594b8325d3529f602666138ad95c77c5f24379f7ddcdb2bac1386c13397ef6bdd3b742234595a2950a56c39c2e409cce12a73fbb76fb9597d071bcd7048592e48a025ca73e38a0ede3a5788fd95ce0edca230392c188d84572e533a6df9c43012e660173d7b567ffe0e383384263824a010b90ba963639d6b2877fd14a1d6d85e3eb8635e5aca1cdadb156547adb622e5ad693f96347201407b27e8a487bf420fbe0fa7df5312e792ac641c9a252df3534060e77cbeec8d0d3a36c196e31140c48668c1cbc6175d37775779f93d3bfa90c9f953fc53a0c0b511a4822a3b993724793e677aa2b591c2f941d1fbb3adf89b41bd9411fd05a2036a3ddd212dfd3b8858c4deb7da95f50353f857841c159a1ad22c4bf38ab942cfa7f9be5d3d62e1d0294081808192d13f59f9d4ed35ac9322f79a554d5bcb1a4a616440f828eee1eb6b46a8ca611cb812bd411349875fe447ecf997c67917c2ec13e6939621eb6512658e4cd7fd27fa57c652c60badbfbd967a50682960184a0ed6ce79154ad446127f6f2661be06c34cdc77fedd342f8ce537c70b50116e690c04ad0cf57316bbc06330c3a0d808f2aea51a07cf74ae917d12276c44ccd9f9d66226e4cb75507c055deb58a10678336426035570469ac0df06c9e89b04451fc82776f2f3fe88ccf09869c850cb707303e6de6ad3af76fc51083d10d19c3ef39465519fd52516b2dc8e8a978acdbee3ac4516086ffc8de4be936c1428ef0934224054d365cba6b9f1d1f72af500c14932a3835ed90889b2721f8cc56f6ede85104f289bd51e693560119b98f4c704e76894fc2ab41554be217aa3eeeb691d274a066cdaaa8513a492f31bbd1a1aff277c2aefef0c6cdfde0eef90ff9e62803dde4ce1d69a19fcb4db96ed9f2f24a428380ba6fbefd18e2cd498f115c01f6cdc8b6c02d2baee224f125865353710d652307a0e6f53e12f684b832379bfdcc882c8b531ec865a4074866d5f3dd2d47beff3c611b48fb4370fb3655c532dcbab847f254d8431bee78a5e5659f8c201d44a97f2bce59847ec16818d540c0fb1b1a60788d448a04c8accbdb62cd06c61746d6cf8ac8abba73a44828503cddf411e5e8e1076a19925db73d71c14fea1ad6988310372dcba27506c75ccf00a80ae55dd6860a56da75bdbb9ed255062bd0a5a873dacbee19ce8ce678f0048aa1671bf1e8b7ceb2acf1929fc28de94e97066b1e2a6921b0092eca5418f13e3c49457fee5d50bdc27f9c4cbdfced4349d98ac9da99d1d00fa2d4c6dfa26e5548c2e5a7ddef8c6591fd0369b3188b905302e8ec3cf1b86d2b40d055dd272fe55181fa0a7f7bf0060524e2a985e739114be8fa6047e78db07d48cc6495fa32907e0a1087d17a5674324c14e7daafaed9efe8c2ad2581ad80d6ed20132d80243e66853554d2f25ef590b972c69c78b573a9d3410bb3453b0dcce4eb3f0d1319371bee24283b97e9768bee086b8cabf669a59e74da8650837ae4ead92d18f838c77ebfa10808694669b6029509b251e7dd88dca9ec4ab1a02113fdf450f5d2cdab18fd21c0685c8bc09c9e33205ea66c796940ce9f61f68bbb10a42b76ddfb5b06fb19e7b5c319a23f5d5af440599e2f5141eb7ae62e24c71d36e91adf2a14b75757761232fab6cd532dbe84116966a5ecd11f3e290023b7e02de687b6aabe6124fc04092b4eae5d670d0dba90680ae0cc99c440b090ca8d5480839e1c991178722d6aa9c7efc44c6c91baf3349a837fe254110c40e055fc3a37e1259248cc8748696920ee5669969c917d2b638ebf28dc737445b6240e4d370782ba3a545b09f476448ba9de1b94d3d498a1f38b5e6e0710e6fb40bb371b3ab9afbf3f7c2330eec651b2fecf159c2db58b0d1dc95c3b1cebb98450b56ef4efcacc4b7b62cea2a9f9c82a084e3d276bbef248638b07d55b53748f1cb33c92f5953ad211d34fc565b4c19e4ad1d0d673a2fb0ef0b1fa65415889ee0e1316dfb2bbc71c151c22526dd2c63d939ea5f25e15c009538ae2d3a58fe2e0b01012f7544526243fa61b9349d43c49031794db858b5d6d7e0a5770c141b443dca73409669e64885b113a17a791832f03aa9bed8919c98c50f5799bf6bf3759e66b9e566654af0acaa9ebb979e8ee7407fde231a0433abd96290fe9e2b04ec95322907a654dd61b743977c1224fbfbbf10e43850e8a62ea0ef4b19a18a0fc36f48b32886df16e6e207fb7c3fb09de8e78597d95633fc358401bcd52f6c5294a331b27f01ab7c85e6dd5d698ae6938101f924b97576a7d486682c6e0af17dd8ff5015140899632e3276eeac3680581412b3359d9cba9701323e6e14f467127c998a37ad4ed14bffc3f4fe11637062dd4055c6bf787e06a10681c8882798f164f6fbeacecdb804159684c99381cb44cbf8fd03594febefbd425debfa6a9df2b13aad32bedb41fc9de5aca41914fb271e74856ddba4aa74e700325f844811ce63e2e6eefc3fbc9cb4aabf3e456addf907121f7f648689834c6eb4d14edd06e26ee2d50d58520388979f27ac709cc77c7bb52140350f8ecc27a0a57004d104c49fb22eee96800ab5fe3d14846f629c6b38eb460cb17479401505c117c950c39d2fa88244fc3882897e9216ee59264e5b8167b061406c932ffaab9ddb2c094859c78f071bdff2c7a9f6ea5fdea53e57d8abf1348f85c145fe5ee3e619cc7bafdd454c647bb7b24b355adc4eb6eb3891d212b15f985c511b3db83617227570fdfa40386e007062ce33bedc9af112b50a2b39418704c8b838ce102476f7d2c857e291094d337ed86c42f6fb7713530bfb7a24a7a7c1684b8e905db5435a08e4716c342e537d3fcac6e967bfe93824fd21cfad50a383c6c9f836b077ad8d799c0fff7ec42477bc4f78ffd970ef661fa5d291ddc9683199da6d5ec05658d595f6adcff7393bd2f5a0445e6c94aa439f2273b7c29c0030f05728d8117658ac3c4c1600f37403ac6961792644d7c6f012625d4f9bc529a1ba2abf1de74a0bc0fb3fc5bde2261e41d65a51e55647f7b26b0c60e3cb3b3c48c67e4edc7ceb0fb180245d8d26084d5e19278d5c327c9f02d53810370a8faab48012a2bc5c9feb93fd84a16b9f8804a496ac10e6ea4692352ab5d5ed85819992f2f7ed9597e9979e42bdf15fe64ab25694a481f50e7ac9a988cff6a74860a9881ea267cbca0e84a568d6d6044e2c7df497fa5c7eed4ae5c4955e97b9f07ca544ec7e2c41a027fbe7f3895449a121068d00e3059724f1d4c2f534e69226d00abda308ca9500aa647be9a9491e6ac92d72033edbb92b921c0999ed2da3f893f18921ae78047bfafff7bc60d699a62290df0305f902dd40c0c11437fa4c988aee00580a73dd3d5e439561d72c9ff58e8d1c14585082a1850760672655e7f53202dcaf5defe75a03f51dc44275eca83a4a9868eb8912cb41055c8856ad15b0b93e7d24c060ce948a7cc164c85e514f0f0cd0cf2e3dfc272bddebb78f137ab8b01fea6a24e8b1fbefb1f0622e5894b70bf9f50744efc1cbd3da165389c0f555c20e90a6dd8857c7a6366641613a20c7f9ba74cd4b948637cb34f5afb0fd130a8aee81e9e9fd45d6a49c8e452411bf737f34c899e2f2b41a0369099d50195baf41041ee4fb7a2a522fb90a5c3ee64cd99a0c8bd60ff476bc2a30b9bacce0eea51a2a3ac917277b291f5152d6eb043082d0540cab5ee18710aa4e5219aa00beddbe312df0cc224257accde12d91c5369280d4114b2d4d69fca409d6b7cc3219396baf9a8dff39bdf18ddac87a3eedbf06c8a3545a7194e428e8bf96f57d530eda0c333dfb12e0328efbb2a80616889521f6b763d13ffa1bfb3870dd21e3dcdf7227dc629917695edf1fd8e903ba78d511b45c50162b3551a0f1f3bed522ba68fe0b22440cc0d811a9f2bb4cb2ea76b95ed6daa901812cc57cd4adb1d9701bbe97ffd23d0d13c2df5f50f9d279b3c4f130fd4849e15e374cc47806dc08ebd3fccfd198b86b8dfc2ff96b29fab88bfc5b0a44f59675368b8e8bbbf57419fd9e5a3ceec9a1b5bc8cd92be6bd9712a7fe386dc18a310844ab1bbc16bf8652eb8c9aba0aa9d72ec1778a877309f44c88c553a63bf6398ef04c1ea35f1fb42d5cacf4cce2deb6178072818760a886df6a8a783d18eb10a66986724f1676eb2e6d18581dcde978a319bb3b6ea205739385cb555ff4c1b0bd58d5fb1b9c8e78fbe29e1ba7430e4706a3c7989efc351f67a130223fe0e0f14d4ac8626260102bdd85e5a9382847a19d452384adc9064ef59de521cb0d783387af35126817bcf32d4bc6152095ad8eab77bc88cb105a2150f0ebb32592950424b4e63d2490a05ecd7c9cc6272569920de20ec0ca152bf43126e5a150599bce6138a29514de560b5001cc28323f65cb0a49e1df310f275c8040c6dc66d8611c5cebb0f94811f8b91d7e813d30c7cda8438be8752e64d6d146610d7ae58deacc514559ec2eae004c1c625576ec1fb8c2d6ee0a1f9ed4a63e2d9ee6ccae938f2f66ae50c7928ce2f65de0230c7ff9c80bb382e4bd89df604e12f23633049f37b5ccf233386e0b00b1bcd40bff8a000a4c21d7e3d26b385534a8c3910c6cb2ef7b6b4480eeffe1405ac7ad94b0551f52d40d827ee13df7afd5821ca1d3ab7e0263215e9544e43bc23eca3e9f30cf83ecfff37f166489ba148fa7c6349d5f5cd0feb9948f60b950bfae5262fa53e6e144106b3a493be98b82c01ecd76e2f21b0b47418883afbd164094a4ce14fef085b99f3a1bbe2e325e131a97455924d28c2c09aee21ab816068935fdb298f0a8672782abb38a960356f3a5ee25e8728fb85cbc9c39f3edfb01a5056d8c9aa5f7324fd061ccb37464deb21840be8187ed3caea3aae3689c89be306cd5e9345553fe05b14ff749d9df22f328065b4a8bb1deb307209617922c31afb219eb737d3acf30d3978f3becbdd2a66870918105479f738675b493e8eaa4fbd4047d4cd720f1fbc059ff2435dca273f53af79c59e97eb69887240df5efc3e5e1daa9eebf804d494bd1d13a1aaee57ac8cab631c35ae186bdbe24d1f1157c6dd81bc462d73f94c7e3cbc625ef43e25dbda724fce34aaa75e061d53051a640b367519a27f3cbbbafc29cf97989ed1cb6155276848fd7e31cef24ba9dee5ceb7423ba29d7fc9a9b1685fa7003b765b9eeefcca3e992ebb1f59dc86b356a3f8b5fcb174c7b55bfef61a267e42e70562006ac0096e5759ec82df2d4e10ff1f7206dcbbf4560551c3014ae482275939ca4a278f37e8c7898977557ddcbbd342728d4e6117b3a796417b725ab4a97c090a61691ac069e6464fc86368</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以查看此内容</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/">杂项</category>
      
      
      <category domain="https://yhxjs.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">学习路线</category>
      
      
      <comments>https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://yhxjs.github.io/2024/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <guid>https://yhxjs.github.io/2024/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Fri, 01 Mar 2024 15:05:40 GMT</pubDate>
      
      <description>设计模式是一种在特定情境下解决特定问题的方法论。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式提供了一套在特定问题场景下解决软件设计问题的标准化解决方案，能够帮助开发者避免重复造轮子，提高代码的可复用性、可维护性和可扩展性，并且能够使开发过程更加高效、有条理。</p><p>在介绍之前先了解下三个原则：单一职责原则、开放-封闭原则和依赖倒转原则。</p><blockquote><p>单一职责原则</p><p>如字面意思所示，对于一个类来说最好只有一个引起它变化的原因。如果一个类承担的职责过多，就相当于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。如果根据职责进行划分，即根据功能进行细化，后续的改动甚至是移植都会变得容易许多，可维护性大大提升，而不是一堆shit mountain摆在面前，不知道从何入手。当然，无需过度细分，实际上，在开发中一般是以功能模块进行划分，而模块内部的各个细节再进行具体划分，做到粗中有细。</p></blockquote><blockquote><p>开放-封闭原则</p><p>如字面意思所示，可以进行扩展，但不能进行修改。此处的不能修改并不绝对，而是需要开发者事先预知可能的变化，将这种变化进行抽象，从而实现隔离变化，当发生变化时，只需要增加新代码，而不是修改现有代码。当然，仅需要对频繁做出改变的部分进行抽象，而不是事无巨细，反而会导致过度修改。</p></blockquote><blockquote><p>依赖倒转原则</p><p>首先先了解里氏代换原则，即一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换为它的子类，程序的行为并未发生变化，简单来说，就是子类型必须能够替换掉它们的父类型。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象，即针对接口编程，不要对实现编程，高层模块不应该依赖低层模块，两个都应该依赖抽象。由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是这三类设计模式的简要概述：</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这类模式主要关注对象的创建方式，使系统独立于对象的创建、组合和表示方式。常见的创建型模式包括：</p><h4 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h4><p>即确保一个类仅存在单个实例，并为该实例提供访问方法，当多线程时，需要提供锁来保证单实例。</p><p>单例模式分为饿汉式和懒汉式，饿汉式即一开始就创建实例，而懒汉式则是用到时才构建实例。</p><h4 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h4><p>即用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实际上就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建的细节，将对象初始化为被克隆的对象，然后再根据需要修改部分属性，而不需要从头开始初始化。</p><blockquote><p>此处克隆分为浅拷贝和深拷贝，这是一个老生常谈的问题，浅拷贝只是引用传递，即拷贝对象只将对象的引用进行拷贝，而真正的数据并有拷贝，即数据只有一份，只要一个地方进行了修改，其他拷贝的地方也会跟着产生变化，如果不想这样，就需要值传递，实现深拷贝方法，重新创建一个跟被拷贝对象一样数据的对象，曾经在写Vue的时候遇到这个坑，直接用等于号赋值，结果临时变量的改变也导致了原本变量的改变，从而导致模版重新渲染，这里就不展开说了，感兴趣的可以搜搜看。对于Java、C#等等面向对象语言来说，都会提供一个Cloneable类，只需要继承该类即可调用clone方法来复制实例，不过此处的clone方法是浅拷贝，如果需要深拷贝，可以进行重写。</p></blockquote><h4 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h4><p>首先需要了解简单工厂模式，即运用多态，在构造时，构造工厂根据某个属性创建对应的类，这些类都继承于某个抽象类，实现某个公有方法，从而只需要调用该方法即可，不用关心方法是如何实现，当需要变动时，只需要改变对应类的实现，而不用关心其他类的实现。</p><p>工厂方法模式将简单工厂模式进一步抽象，把工厂也分为一个个具体的工厂，将原先在工厂内判断的逻辑移动到外部，进一步加强了开放-封闭原则。定义了一个创建对象的接口，让子类决定实例化哪个类。</p><h4 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h4><p>创建一系列相关或相互依赖的对象，而无需指定它们具体的类。常常和依赖注入和反射相结合，根据传入的依赖创建不同的实例，从而调用不同的方法，例如数据库连接池druid，它并不感知具体的数据库类型，不论是MySQL还是oracle，都有一套标准，即连接器，只需要方法一致即可。</p><h4 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h4><p>即将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>将构建流程标准化形成一个抽象类建造者，其中包含各个步骤，然后再去继承这个抽象类，然后必须实现其中的所有方法，因此不会有遗漏，而再抽象出一个流程类指挥者，传入建造者，调用各个步骤，从而形成具体的流程。部分定制化可以概括这个模式的特点，流程是定死的，但是步骤可定制化，经过不同的步骤，最后呈现的结果也是不同的，但万变不离其宗。</p><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这类模式主要涉及到类和对象的组合，用于构建大型的对象结构，帮助确保系统的灵活性和高效性。常见的结构型模式包括：</p><h4 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h4><p>即将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>适配器模式主要应用于希望复用一些现存的类，但是又与复用环境要求不一致的情况，字面意思，可以联想到电源适配器，将市电转化为直流电，供设备运行，一样的思想，适配，适配，适应配置，当存在复杂且繁杂的代码时，无法对其进行重构，或者重构成本过于昂贵，这时就可以运用适配器模式进行相应的适配，当然，还有第三方接口和自己的接口不匹配，此时也需要进行适配。</p><h4 id="装饰者（Decorator）"><a href="#装饰者（Decorator）" class="headerlink" title="装饰者（Decorator）"></a>装饰者（Decorator）</h4><p>即将所需的功能按正确的顺序串联起来控制，动态地给一个对象添加一些额外的职责。</p><p>可以理解为一种另类的递归，装饰对象的被装饰物其实还是其他对象的装饰对象，每次先执行之前“装饰”的方法，再执行自己的方法，串成一串，这样就实现了可装配的增强功能，当需要时，可按需进行串联，例如事先的数据校验，增加新的字段，新的逻辑等等。注意，装饰的顺序是很重要的，例如数据校验、加密，不能等到业务处理结束后才进行。装饰模式可以有效地将核心功能和装饰功能分离开来，按照需要进行必要的增强，而不修改核心功能。</p><h4 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h4><p>即为其他对象提供一种代理以控制这个对象的访问。</p><p>如果有部署过Nginx的应该不陌生，代理服务器，即将收到的请求发送到另一个服务器，收到应答后再将该应答返回，相当于多了一个代理人的概念，当然在传递期间可以做一些额外的事，甚至经过处理而不用继续传递直接返回，一般来说，代理能处理的事，就不用劳烦被请求的对象了。</p><h4 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h4><p>即为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加易用。</p><p>在设计初期阶段，应该有意识的定义不同的层，每个层都有不同的职责，然后层与层之间通过接口访问，使得耦合大大降低，例如网络的TCPIP模型，再比如后端的数据访问层、业务逻辑层、表示层等等，各司其职，对外提供一组接口供其他层调用，只需要知道这个接口是干啥的，而无需过分关注其中的实现，只要功能没变，调用该接口的地方就无需变动。</p><h4 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h4><p>即将抽象部分与它的实现部分分离，使它们都可以单独地变化，简单来说，就是将类的功能层次结构和类的实现层次结构连接起来。</p><p>就像系统和软件之间存在的关系，软件在不同的系统中实现有所不同，但是功能是一样的，即仅需定义好功能，然后调用实现即可，功能侧无需关心具体实现。</p><p>想要新增功能时，只需在功能侧添加功能类，不必对实现侧进行修改，增加后的功能能被所有实现使用。</p><h4 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h4><p>即将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p>文件树、窗口视图、权限管理等等，都可以采用组合模式，即可以进行嵌套，当然需要注意有没有嵌套自身，不然就会无限递归下去。</p><h4 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h4><p>即运用共享技术有效地支持大量细粒度的对象。</p><p>例如字符串常量就可以理解为是享元，相同的字符串常量实际上是在同一块内存，还有线程池、数据库连接池，其实也是享元，只不过是事先建立多个线程或者连接，然后共享，本质是一样的，C语言的文件描述符也是如此，可以事先进行创建，还能节省时间，因为创建比较耗费时间。</p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这类模式专注于对象之间的通信，用于增强对象之间的协作和职责分配。常见的行为型模式包括：</p><h4 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h4><p>即将策略（算法）从单个类剥离出来，定义一个父类，然后分成不同的类继承该父类，这些类都实现对某个问题的处理方法，这样只需要在需要构造的类（上下文）中传入需要的策略，即可调用处理方法，而无需关注内部如何实现。</p><p>策略类只需要实现必要的接口，具体的策略类需要实现策略类中定义的接口，而上下文类负责使用策略类，用多态传入不同的具体的策略类。</p><p>策略模式有效地将算法和实际应用剥离开来，后续如果要新增策略或者修改策略对应的算法时，只需要对相应的部分进行新增或者修改即可，相当于是委托，是一种弱关联关系，可以很方便地进行替换。</p><p>策略模式可以和简单工厂模式相结合，上下文构造时传入的可以是某个属性，再将该属性映射到具体的类。不同模式是可以进行嵌套的，最终境界就是看似没有应用模式，实际都是模式，不需要刻意使用，即化有形为无形。</p><h4 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h4><p>又叫发布-订阅模式，即让多个观察者订阅某一个对象，当这个对象状态发生变化时，会通知所有观察者对象执行相应的动作。</p><p>消息队列就是经典的观察者模式，以及基于事件驱动的websocket，都是根据“状态”变化来触发对应动作，也就是回调，并不关心是谁触发的，而是关注什么事件被触发了。</p><h4 id="责任链（Chain-of-Responsibility）"><a href="#责任链（Chain-of-Responsibility）" class="headerlink" title="责任链（Chain of Responsibility）"></a>责任链（Chain of Responsibility）</h4><p>即使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>相当于踢皮球一样，先看看自身能不能处理，不能就踢给下一个人，以此类推，直到有人进行处理，当然，最后必须保证能处理，不然就没有意义了，就像现实中无意义的互相甩锅（手动狗头</p><h4 id="命令（Command）"><a href="#命令（Command）" class="headerlink" title="命令（Command）"></a>命令（Command）</h4><p>即将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>可以理解为事件驱动，事件触发时将要做的操作加入队列中，或者将操作从队列中删除，当收到执行事件时，将队列中的操作一一执行。</p><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>即用状态决定对象的行为。</p><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，用类表示状态，将冗长的判断切分为一个个状态，分而治之，可以将状态迁移交给各个状态，由自己判断什么时候迁移状态，也可以在外部进行迁移，通过有限状态机可以更好地理解各个状态之间的关系。</p><h4 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h4><p>即将数据结构和处理分离开来，使得可以不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>该模式适用于数据结构相对稳定的系统，这就使得它的优缺点都十分明显，优点就是操作解耦，增加新操作无需修改先前的代码，而缺点就是一旦数据结构变化，需要修改的地方就会分散到各个角落里，难以维护，因此只适用于稳定的数据结构。</p><h4 id="中介者（Mediator）"><a href="#中介者（Mediator）" class="headerlink" title="中介者（Mediator）"></a>中介者（Mediator）</h4><p>即用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>相当于由一个路由器决定请求该发往哪里，在web应用中可以用Redis解决跨域问题，不同的网站请求同一个Redis即可，存的cookie可以很容易共享，跟发布&#x2F;订阅模式很像。</p><h4 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h4><p>即将对象的状态保存起来，需要时可以进行恢复，就像游戏中的存档和读档。</p><p>可以藉由该模式实现状态恢复、状态暂存，甚至还能覆盖保存的状态，可以将状态保存到Redis里，需要时进行取用，可以实现二阶段提交等功能。</p><h4 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h4><p>即提供一种方式顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式实际已经加入语言实现当中，iterator即迭代器，使用该元素即可对集合进行遍历然后进行相同的操作。</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><a class="link"   href="https://baike.baidu.com/item/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7427270" >《Head First设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262" >《大话设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="https://baike.baidu.com/item/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22699708" >《图解设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/">杂项</category>
      
      
      <category domain="https://yhxjs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>https://yhxjs.github.io/2024/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo配置</title>
      <link>https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/</link>
      <guid>https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Thu, 29 Feb 2024 12:08:40 GMT</pubDate>
      
      <description>Hexo简要配置指南</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm 和 git，因此需要搭建本地操作环境，安装 <a class="link"   href="https://nodejs.org/en" >Node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" >Git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>具体教程可参考 <a class="link"   href="https://blog.csdn.net/WHF__/article/details/129362462" >Node.js下载安装及环境配置教程  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://blog.csdn.net/mukes/article/details/115693833" >Git 详细安装教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>安装所需依赖后，可以开始安装 Hexo 了。</p><p>新建一个文件夹用来存放 Hexo 的程序文件，在终端输入以下命令安装 Hexo 的命令行工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div><p>安装完毕后输入 hexo -v 即可查看到版本信息，没问题即可继续。</p>  <div class="note p-4 mb-4 rounded-small success">    <figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/hexo-v.png"                      class="" alt="hexo -v"                ><figcaption>hexo -v</figcaption></figure>  </div><p>在GitHub上创建个人页仓库，命名格式为 <strong>用户名.github.io</strong></p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./creat_repository.png"                      width="600px" height="auto" alt="创建个人页仓库"                ><figcaption>创建个人页仓库</figcaption></figure><p>至此，前期工作已准备完毕，接下来进行具体配置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="初始化并安装依赖组件"><a href="#初始化并安装依赖组件" class="headerlink" title="初始化并安装依赖组件"></a>初始化并安装依赖组件</h3><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init# 初始化</span><br><span class="line">npm i# 安装组件</span><br></pre></td></tr></table></figure></div><p>完成后输入以下命令即可开启本地服务器进行预览：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g# 生成页面</span><br><span class="line">hexo s  # 启动服务器</span><br></pre></td></tr></table></figure></div><p>访问<a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，即可看到默认页面，至此，本地安装结束。</p><p>Hexo 程序目录：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./directory_structure.png"                      width="400px" height="auto" alt="目录结构"                ><figcaption>目录结构</figcaption></figure><h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>输入以下命令来安装部署工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><p>然后修改 <strong>_config.yml</strong> 的末尾</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div><p>最后运行 <span class="bg-grey">hexo d</span> 即可将网页push到GitHub上，大功告成！访问 https:&#x2F;&#x2F;用户名.github.io 就可以看到自己的博客了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo官方网站有不少主题可供使用 <a class="link"   href="https://hexo.io/themes/" >Hexo 主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，挑选一个心仪的主题并进行下载。</p><p>本博客使用的主题是 <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，用该主题介绍如何进行安装。</p><p>事先根据提供的文档进行安装，一般都提供git clone的方式，还有npm安装的方式：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br><span class="line">npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div><p>安装完毕后，修改 <strong>_config.yml</strong> ：</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div><p>最后一般都要在Hexo程序根目录下新建一个主题的配置文件，例如 <strong>_config.redefine.yml</strong>， 具体的根据官方文档进行。</p><p>完美！接下来重新启动服务器查看有多么炸裂吧。</p><h3 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h3><p>如果使用的主题是 Redefine，已经集成了不少有用的插件，在此不再赘述，可以参考 <a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行相关配置，此处推荐的是额外的插件，如果有需要也可以自己去 <a class="link"   href="https://hexo.io/plugins/" >Hexo 插件广场 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 挑选，甚至可以自己开发一个。</p><h4 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h4><p>生成站点地图，利于SEO，地址：<a href="hexo-generator-sitemap">hexo-generator-sitemap</a></p><h4 id="hexo-simple-image"><a href="#hexo-simple-image" class="headerlink" title="hexo-simple-image"></a>hexo-simple-image</h4><p>新建文章时自动在相同路径下生成存放图片的文件夹，使得文章引用图片方便不少，地址：<a class="link"   href="https://github.com/ZaiZheTingDun/hexo-simple-image" >hexo-simple-image <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>使用时可以直接像下面这样：</p><div class="highlight-container" data-rel="Md"><figure class="iseeu highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{% asset_img "span>" '"" "<span class="string">my post image</span>"' %}</span><br><span class="line">或者</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./new_post.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span>   &lt;!-- 注意img的话不需要加文件夹名字，因为生成时会自动合并 --&gt;</span><br></pre></td></tr></table></figure></div><h4 id="hexo-tag-mdline"><a href="#hexo-tag-mdline" class="headerlink" title="hexo-tag-mdline"></a>hexo-tag-mdline</h4><p>生成时间线，地址：<a class="link"   href="https://github.com/wangwei1237/hexo-tag-mdline" >hexo-tag-mdline <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="hexo-tag-bilibili"><a href="#hexo-tag-bilibili" class="headerlink" title="hexo-tag-bilibili"></a>hexo-tag-bilibili</h4><p>生成哔哩哔哩视频卡片，地址：<a class="link"   href="https://github.com/Z4Tech/hexo-tag-bilibili" >hexo-tag-bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>建议将url修改为不进行自动播放和默认静音，修改 node_modules\bilibili-embed-convert\index.js，将标出的位置进行修改：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./bilibili_url.png"                      width="700px" height="auto" alt="修改哔哩哔哩url"                ><figcaption>修改哔哩哔哩url</figcaption></figure>]]></content:encoded>
      
      
      <category domain="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/">杂项</category>
      
      
      <category domain="https://yhxjs.github.io/tags/%E9%85%8D%E7%BD%AE/">配置</category>
      
      <category domain="https://yhxjs.github.io/tags/Hexo/">Hexo</category>
      
      
      <comments>https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
