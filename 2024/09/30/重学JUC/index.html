<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="博客"><meta name="author" content="yhxjs"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://yhxjs.github.io/2024/09/30/重学juc/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="JUC工具包，全称为Java.util.concurrent工具包，是Java提供的用于实现多线程编程的工具集合。它是在Java 5版本中引入的，并在后续版本中得到了进一步的扩展和优化。"><meta property="og:type" content="article"><meta property="og:title" content="重学JUC"><meta property="og:url" content="https://yhxjs.github.io/2024/09/30/%E9%87%8D%E5%AD%A6JUC/index.html"><meta property="og:site_name" content="yhxjs的博客"><meta property="og:description" content="JUC工具包，全称为Java.util.concurrent工具包，是Java提供的用于实现多线程编程的工具集合。它是在Java 5版本中引入的，并在后续版本中得到了进一步的扩展和优化。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-09-30T08:06:25.000Z"><meta property="article:modified_time" content="2024-10-01T03:42:03.551Z"><meta property="article:author" content="yhxjs"><meta property="article:tag" content="JUC"><meta property="article:tag" content="多线程"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/images/logo.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><meta name="theme-color" content="#01b0ff"><link rel="shortcut icon" href="/images/logo.png"><title>重学JUC - yhxjs的博客</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/private.css"><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><script src="/js/libs/anime.min.js"></script><h1 class="ml13">yhxjs的博客</h1><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }</script></div><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/fonts.css"><link rel="stylesheet" href="/fonts/Satoshi/satoshi.css"><script id="hexo-configurations">window.config={hostname:"yhxjs.github.io",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"12px",image_alignment:"center",image_caption:!0,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"5rem",h2:"4rem",h3:"2.8rem",h4:"2.5rem",h5:"2.2rem",h6:"2rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:["炼体","筑基","金丹","元婴","化神","大乘","渡劫","飞升"]},code_block:{copy:!0,style:"simple",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:4,number:!0,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#01b0ff",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"心之所向",subtitle:{text:["一个平凡的人","烟花易逝，人情长存"],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn?c=a"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/yhxjs",instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!0},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.6.1",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},About:{path:"/about",icon:"fa-regular fa-user"},"追番网站":{path:"/animesite",icon:"fa-regular fa-cup-straw-swoosh"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"info",announcement:"欢迎来到我的博客",show_on_mobile:!0,links:{tags:{path:"/tags",icon:"fa-regular fa-tags"},categories:{path:"/categories",icon:"fa-regular fa-folder"},RSS:{path:"/atom.xml",icon:"fa fa-rss",color:"coral"}}},article_date_format:"YYYY-MM-DD",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/2/27 23:08:54"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><script>window.onload=function(){var t,e=document.title;document.addEventListener("visibilitychange",(function(){document.hidden?(document.title="(●—●)喔哟，崩溃啦！",clearTimeout(t)):(document.title="(/≧▽≦/)咦！页面又好了！",t=setTimeout((function(){document.title=e}),2e3))}))}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="yhxjs的博客" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="yhxjs的博客" type="application/rss+xml">
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-title" href="/">yhxjs的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a href="/about"><i class="fa-regular fa-user fa-fw"></i> 关于</a></li><li class="navbar-item"><a href="/animesite"><i class="fa-regular fa-cup-straw-swoosh fa-fw"></i> 追番网站</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about"><span>关于 </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/animesite"><span>追番网站 </span><i class="fa-regular fa-cup-straw-swoosh fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>标签</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>分类</span> <i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/atom.xml"><span>RSS</span> <i class="fa fa-rss fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">20</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">23</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">重学JUC</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/head.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">yhxjs</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">金丹</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-09-30 16:06:25</span> <span class="mobile">2024-09-30 16:06:25</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-10-01 11:42:03</span> <span class="mobile">2024-10-01 11:42:03</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/JUC/">JUC</a>&nbsp;</li><li>| <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>8.7k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>32 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><p>JUC是java.util.concurrent包的简称，方便开发者并发编程，包括线程池、异步IO和轻量级任务框架，还提供了设计用于多线程上下文中的Collection实现等。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池可以减少新建线程的开销，使得线程可以复用，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。</p><p>带来的好处：</p><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>提供了Executors工厂方法，调用如下方法即可创建对应的线程池：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();<span class="comment">//无界线程池，可以自动回收线程</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="type">int</span>);<span class="comment">//固定大小线程池</span></span><br><span class="line">Executors.newSingleThreadExecutor();<span class="comment">//单个后台线程</span></span><br></pre></td></tr></table></figure></div><p>线程池的继承结构：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor 负责线程的使用与调度的根接口</span><br><span class="line"> *   |--**ExecutorService 子接口，线程池的主要接口</span><br><span class="line"> *    |--ThreadPoolExecutor 线程池的实现类</span><br><span class="line"> *    |--ScheduledExecutorService 子接口：负责线程的调度</span><br><span class="line"> *     |--ScheduledThreadPoolExecutor 继承ThreadPoolExecutor，实现 ScheduledExecutorService</span><br></pre></td></tr></table></figure></div><p>通常会自定义线程池，通过指定一些关键参数来创建线程池交由Spring容器进行管理。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ExecutorService <span class="title function_">defaultExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(CORE_POOL_SIZE);<span class="comment">//核心线程数</span></span><br><span class="line">    executor.setMaxPoolSize(MAX_POOL_SIZE);<span class="comment">//最大线程数</span></span><br><span class="line">    executor.setKeepAliveSeconds(KEEP_ALIVE_TIME);<span class="comment">//非核心空闲线程存活时间</span></span><br><span class="line">    executor.setQueueCapacity(QUEUE_CAPACITY);<span class="comment">//等待队列数</span></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;default&quot;</span>);<span class="comment">//线程前缀</span></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<span class="comment">//拒绝策略</span></span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor.getThreadPoolExecutor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>线程池调度过程如下：</p><ol><li>判断核心线程是否已满，若未满则创建核心线程执行任务，否则进入2。</li><li>判断等待队列是否已满，若未满则将任务添加到队列之中，否则进入3。</li><li>判断线程池是否已满，若未满则创建非核心线程执行任务，否则进入4。</li><li>按照配置的拒绝策略进行处理。</li></ol><p>拒绝策略有如下几种：</p><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</p><p>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。</p><p>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</p><p>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolExecutor defaultExecutor;<span class="comment">//注入线程池</span></span><br><span class="line"></span><br><span class="line">方法一</span><br><span class="line">defaultExecutor.execute(Runnable);<span class="comment">//直接execute执行任务</span></span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">使用CompletableFuture时指定线程池</span><br><span class="line">CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, defaultExecutor);</span><br><span class="line">CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, defaultExecutor);</span><br><span class="line">CompletableFuture.allOf(future1, future2).join();</span><br></pre></td></tr></table></figure></div><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>每个线程Thread中都有一个ThreadLocalMap类型的成员变量，用于维护相关的ThreadLocal，ThreadLocalMap的key为每个ThreadLocal的弱引用，value为实际存放的值，每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了<strong>线程隔离</strong>。</p><blockquote><p>需要注意的是ThreadLocal中的key为弱引用，若未remove可能会造成不进行gc导致内存泄漏。</p><p><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候。</p><p><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。</p><p><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收。</p><p><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>场景一</p><p>每个线程需要使用一个独享的对象时，可以使用ThreadLocal来存储该对象，结合线程池使用就是核心线程不需要每次都新建一个对象，节省新建对象以及gc带来的开销。</p><p>场景二</p><p>线程上下文中需要多次使用的对象，例如登录的用户信息，可以在拦截器中对ThreadLocal进行维护，需要时从ThreadLocal中获取即可，无需在方法中不断传递，注意在拦截器的afterCompletion方法中进行ThreadLocal的remove，之所以是afterCompletion而不是postHandle是因为若抛出异常，postHandle则不会被调用，导致ThreadLocal未进行remove，进一步出现内存泄漏问题。</p><p>场景三</p><p>在ThreadLocal中保存traceId，而需要传递或者使用时维护ThreadLocal即可，而slf4j提供这样一个上下文ThreadLocal——MDC，直接使用即可。</p><p>服务发送请求时可以实现RequestInterceptor来将MDC中的traceId设置到请求头中，服务接受请求时，将请求头中的traceId存入MDC。</p><p>由于MDC时基于普通的ThreadLocal实现的，所以在多线程中需要将上下文传入线程之中，如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();</span><br><span class="line">    <span class="built_in">super</span>.execute(() -&gt; run(runnable, context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Runnable runnable, Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">        MDC.setContextMap(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MDC.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>消息队列需要在消息体中自定义traceId属性，接收方消费消息后，解析出traceId即可继续传递。</p><p>以上过程中，需要注意在结果返回前调用MDC.remove()。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="乐观锁vs悲观锁"><a href="#乐观锁vs悲观锁" class="headerlink" title="乐观锁vs悲观锁"></a>乐观锁vs悲观锁</h4><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了，<a href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB">原子变量类</a>就是使用其中的一种方式<a href="#CAS">CAS</a>实现的。高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder，用空间换时间），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能，主要针对的对象是单个共享变量。</p><h4 id="阻塞锁vs自旋锁"><a href="#阻塞锁vs自旋锁" class="headerlink" title="阻塞锁vs自旋锁"></a>阻塞锁vs自旋锁</h4><p>阻塞锁见名思意，即当线程加锁失败时，则会释放CPU给其他线程运行并进行阻塞即进入睡眠状态，直到被系统唤醒，而当锁被释放时，之前睡眠状态的线程会被唤醒变为就绪状态，然后内核会在合适的时间，把CPU切换给该线程运行。由于阻塞锁有线程状态的变化，此时就会产生一个操作——上下文切换，即将线程的私有数据、寄存器等不共享的数据进行切换，并且会在用户态和内核态之间进行切换，这样才能保证上下文是一致的。</p><p>自旋锁则是利用CPU周期进行忙等待，自旋锁开销少（因为不需要上下文切换），但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以需要注意锁住的时间，否则容易导致CPU资源被耗尽，一般实现自旋锁会设置一个超时时间，超过该时间则主动放弃，不继续执行，可以在一定程度上避免上述情况发生，自旋锁同样借鉴了<a href="#CAS">CAS</a>的思想。</p><p>自旋锁适用于锁定时间短、锁竞争不频繁的场景，而阻塞锁更适合锁定时间较长或锁竞争较频繁的场景。-</p><h4 id="公平锁vs非公平锁"><a href="#公平锁vs非公平锁" class="headerlink" title="公平锁vs非公平锁"></a>公平锁vs非公平锁</h4><p>公平还是不公平，这是门学问，咳咳咳。</p><p>公平锁和非公平锁是针对阻塞锁的概念，所谓公平则是按照先来后到的原则，按顺序唤醒阻塞的线程，可以有效避免造成线程饥饿（因为抢占而长时间获取不到锁），但由于需要保证有序，而唤醒一个线程时会有延时，相当于可以抢占时却白白增加了上下文切换的开销，而非公平锁则是若解锁时刚好有线程请求加锁，则会直接把锁给它，而不是唤醒阻塞的线程，同时唤醒顺序也可以不按阻塞顺序来，这样就可能会使阻塞的线程一直处于阻塞状态，导致线程饥饿，但有效提高了并发的性能，因为减少了不必要的上下文切换。</p><p>若不需要保证完全的有序，那么使用性能更优的非公平锁即可，反之则使用公平锁。</p><h4 id="可重入锁vs不可重入锁"><a href="#可重入锁vs不可重入锁" class="headerlink" title="可重入锁vs不可重入锁"></a>可重入锁vs不可重入锁</h4><p>可重入锁又称递归锁，指同一个线程可以在外层方法获取了锁，而在进入内层方法后依旧能获取到同一把锁，简单来说，就是同一个线程能继续获取它所拥有的锁，这就要求加锁和解锁是成对的，不然可能会发生死锁，不可重入锁则要求持有者仅且可以加锁一次，若持有者再申请加锁就会造成死锁，因此可重入锁可以在一定程度上避免死锁。</p><h4 id="共享锁vs排他锁"><a href="#共享锁vs排他锁" class="headerlink" title="共享锁vs排他锁"></a>共享锁vs排他锁</h4><p>共享锁和排他锁的经典实现就是读写锁，分别对应其中的读锁和写锁，排他锁即为只能被一个线程所持有，其他线程无法对锁住的资源进行操作，锁持有者则可以对资源进行读写，而共享锁是指能被多个线程同时持有，但获取锁后仅能读取资源，加上共享锁后不可继续加排他锁。</p><p>读写锁的实现是基于<a href="#AQS">AQS</a>的，ReentrantReadWriteLock是Java的一种读写锁，其中的WriteLock与ReadLock是靠内部类Sync实现的。由于读锁和写锁是分离的，读读不做互斥，因此在读多写少的情况下，相较于普通的排他锁，性能大幅提高。</p><h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>原子变量类依赖于CAS，CAS 的全称是Compare And Swap（比较与交换），用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>在Java中，实现CAS操作的一个关键类是Unsafe，提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的CAS操作，而Unsafe 提供的这些功能的实现需要依赖本地方法，直接调用底层的硬件指令来实现原子操作，保证不同系统的效果是一致的。</p><p>CAS最常见的问题就是ABA问题，即一个变量初次读取的值为A，而在后续操作中被修改成了B，然后又被改回A，此时再次读取还是A，就会误认为该变量没被修改过，显然是不合理的，解决该问题的方法就是引入版本号或者时间戳之类的唯一标识，变量值比较通过后再比较该标志，也比较通过后才修改变量的值。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>使用原子的方式更新基本类型，不同的基础类型的原子变量类提供的方法几乎相同，此处以AtomicInteger为例，常用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值</span></span><br></pre></td></tr></table></figure></div><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>使用原子的方式更新数组里的某个元素，以AtomicIntegerArray为例，常用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值</span></span><br></pre></td></tr></table></figure></div><p>除了是数组以外，和基本类型使用方法基本一致。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>AtomicReference类跟基本类型区别就是更新的类型为对象，可以实现新对象的替换，而想要细化到对象属性的话，需要使用Atomic***FieldUpdater，以AtomicIntegerFieldUpdater为例：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerFieldUpdater&lt;Person&gt; ageUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yhxjs&quot;</span>, <span class="number">23</span>);</span><br><span class="line">ageUpdater.incrementAndGet(person); <span class="comment">//自增</span></span><br><span class="line">ageUpdater.addAndGet(person, <span class="number">5</span>); <span class="comment">//增加5</span></span><br><span class="line">ageUpdater.compareAndSet(person, <span class="number">28</span>, <span class="number">30</span>); <span class="comment">//如果当前值是28，则设置为30，该方法会返回成功还是失败</span></span><br></pre></td></tr></table></figure></div><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>仅介绍部分并发容器，感兴趣可以自行查看JDK的源码。</p><p>ConcurrentHashMap: 线程安全的HashMap</p><p>CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于Vector。</p><p>BlockingQueue: 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>跟HashMap实现一样，底层为Node数组 + 链表&#x2F;红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p>ConcurrentHashMap初始化是通过自旋 + CAS实现的，添加元素流程如下：</p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>用当前 key 定位出Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，则需要进行扩容。</li><li>如果都不满足，则利用synchronized锁写入数据。</li><li>如果数量大于TREEIFY_THRESHOLD则要执行树化方法，在treeifyBin中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ol><p>查询元素流程如下：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的value。</li><li>如果头节点hash值小于0，说明正在扩容或者是红黑树，进行查找。</li><li>如果是链表，则遍历进行查找。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>从名字就可以看出CopyOnWriteArrayList线程安全的核心在于其采用了写时复制，当需要修改（ add，set、remove等操作）内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p><p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能，但由于每次数据修改都需要创建一个副本，这就带来了额外的开销以及内存的占用。由于是先对副本进行修改，因此存在一定的数据一致性问题，例如当进行写发操作时，处于副本写入的过程即还未替换为真正的数组，这时候读取还是从旧的数组中进行的，这就导致了读到‘脏数据’。</p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>阻塞队列被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>由此BlockingQueue被用于线程池，当核心线程无法及时处理任务时，这些任务都会扔到workQueue中，以常用的阻塞队列ArrayBlockingQueue为例。</p><p>ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁ReentrantLock，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞，尝试从一个空队列中取一个元素也会同样阻塞。</p><p>主要涉及的方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">put(E e)：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。</span><br><span class="line">take()：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。</span><br></pre></td></tr></table></figure></div><p>ArrayBlockingQueue也支持非阻塞获取和新增元素（例如poll()和offer(E e)方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为null，一般不会使用。</p><h2 id="并发流程"><a href="#并发流程" class="headerlink" title="并发流程"></a>并发流程</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>经常用来控制固定数量线程的流程，倒数结束前一直进行等待，直到倒数结束后即其他线程的操作执行完后，当前线程才会继续进行，主要函数如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch(<span class="type">int</span> count) <span class="comment">//初始化一个值为count的倒数门闩</span></span><br><span class="line">countDown() <span class="comment">//将count减1，当值为0时，唤醒等待的线程</span></span><br><span class="line">await() <span class="comment">//调用该方法的线程会被挂起，直至count值为0才会被唤醒</span></span><br></pre></td></tr></table></figure></div><p>常见的使用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个倒计数为 3 的 CountDownLatch</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 1&quot;</span>, <span class="number">2000</span>, latch));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 2&quot;</span>, <span class="number">3000</span>, latch));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 3&quot;</span>, <span class="number">4000</span>, latch));</span><br><span class="line"></span><br><span class="line">    service1.start();</span><br><span class="line">    service2.start();</span><br><span class="line">    service3.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有服务初始化完成</span></span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有服务都准备好了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> timeToStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Service</span><span class="params">(String name, <span class="type">int</span> timeToStart, CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.timeToStart = timeToStart;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(timeToStart);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 准备好了&quot;</span>);</span><br><span class="line">        latch.countDown(); <span class="comment">// 减少倒计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>将CountDownLatch传入主线程需要等待的线程，主线程调用await()进行等待，当线程执行完毕后调用countDown()方法减少计数，当计数为0时，主线程继续执行。</p><p>以上场景为一个线程等待多个线程执行完成，CountDownLatch也可以用于多个线程等待一个&#x2F;多个线程，例如资源的初始化的场景，初始化所有资源后才执行后续操作。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，熟悉C语言的小伙伴就知道C语言也有semaphore.h这个库，定义了信号量的一些操作，使用方法也是一致的，都是进行PV操作，即P操作负责分配资源，没有资源的时候就等着（进入阻塞队列）。V操作负责释放资源，在阻塞队列不为空的时候唤醒某个进程进入临界区。</p><p>主要方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(<span class="type">int</span> <span class="keyword">permits</span>) <span class="comment">//初始化一个许可证数量为permits的信号量，可以第二个参数指定其公平性，一般为true</span></span><br><span class="line">acquire() <span class="comment">// 尝试获取一个信号量，如果获取不到，就会阻塞当前线程，直到有线程释放信号量，对应P操作</span></span><br><span class="line">release() <span class="comment">//释放一个信号量，释放之后，会唤醒一个等待的线程，对应V操作</span></span><br><span class="line">tryAcquire() <span class="comment">//尝试获取一个信号量，如果获取不到，就会返回 false，不会阻塞当前线程</span></span><br></pre></td></tr></table></figure></div><p>Semaphore用来控制同时访问某个特定资源的操作数量，它并不保证线程安全，所以要保证线程安全，还需要加上同步锁。</p><p>acquire()还可以传入指定数量获取指定数量的信号量，release()也是一样，需要注意的是，获取与释放的信号量个数最好保持一致，不然容易造成信号量越来越少或者越来越多，最后不符合预期，甚至造成线程一直阻塞，形成类似死锁。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>条件对象，类似锁的条件锁，当满足一定条件再释放该锁，即可实现消费者和生产者的效果。</p><p>常用方法：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock.newCondition() <span class="comment">//条件对象依托于其他锁</span></span><br><span class="line">await() <span class="comment">//进入等待，会自动释放持有的锁</span></span><br><span class="line">signal() <span class="comment">//唤醒等待时间最长的线程</span></span><br><span class="line">signalAll() <span class="comment">//唤醒所有正在等待的线程</span></span><br></pre></td></tr></table></figure></div><p>实现消费者和生产者代码如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferResources</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//使用队列作为缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//生产者对应Condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//消费者对应Condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 当前缓冲区为空，等待生产中...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//消费者进入等待状态</span></span><br><span class="line">                    consumerCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行消费数据，从First开始消费，模拟队列</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费成功：&quot;</span> + value + <span class="string">&quot; 当前缓冲区size = &quot;</span> + queue.size());</span><br><span class="line">            <span class="comment">//消费完毕后，只唤醒生产者</span></span><br><span class="line">            producerCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要用finally执行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">(Integer value)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == maxSize) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 当前缓冲区满了，等待消费中...&quot;</span>);</span><br><span class="line">                <span class="comment">//生产者进入等待状态</span></span><br><span class="line">                producerCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进生产数据</span></span><br><span class="line">            queue.offer(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产成功：&quot;</span> + value + <span class="string">&quot; 当前缓冲区size = &quot;</span> + queue.size());</span><br><span class="line">            <span class="comment">//生产完毕后，只唤醒消费者</span></span><br><span class="line">            consumerCondition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要用finally执行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，它允许一组线程互相等待，直到到达某个公共屏障点。</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景，比如，将一个大任务分成10个小任务，用10个线程分别执行这10个小任务，当10个小任务都执行完之后，再合并这10个小任务的结果。</p><p>主要函数如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier(<span class="type">int</span> parties, Runnable barrierAction) <span class="comment">//初始化一个等待数量为parties、回调函数为barrierAction的循环栅栏</span></span><br><span class="line">await() <span class="comment">//进行等待，并且将等待计数减1，当等待数量达到parties，就会执行barrierAction，并且唤醒所有等待的线程</span></span><br></pre></td></tr></table></figure></div><p>常见的使用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(numberOfThreads, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当所有线程都到达障碍点时执行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程都已到达屏障，进入下一阶段&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;Thread &quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在屏障处等待&quot;</span>);</span><br><span class="line">            barrier.await(); <span class="comment">// 等待所有线程到达障碍点</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已越过屏障.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>最终的任务编排工具，也是实际最常用的工具，可以完美覆盖其他工具的场景。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>Runnable接口不会返回结果或抛出检查异常，但是Callable接口可以，如果任务不需要返回结果或抛出异常使用Runnable即可。</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。当执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时可以继续执行其他事情，不用等待耗时任务执行完成。等其他事情干完后，再通过Future类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>主要方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消任务执行</span></span><br><span class="line"><span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"><span class="comment">// 判断任务是否被取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio;</span><br></pre></td></tr></table></figure></div><p>Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的get() 方法为阻塞调用，CompletableFuture就是为了解决这些缺点而生的。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>对于存在前后调用顺序关系的任务，可以进行任务编排。</p><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><ol><li>通过new关键字，跟Future一致。</li><li>基于CompletableFuture自带的静态工厂方法：runAsync()、supplyAsync() ，runAsync接受一个Runnable参数，而supplyAsync接收一个Callable参数。</li></ol><h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><ul><li>thenApply()</li><li>thenAccept()</li><li>thenRun()</li><li>whenComplete()</li></ul><p>thenApply用来处理结果，将接受到的结果进行相关处理。</p><p>thenAccept则是将结果作为输入，执行其他操作，无法改变结果，类似消费者。</p><p>thenRun是运行一个新的Runnable，无法接收结果。</p><p>whenComplete接受结果和异常，进行相关的处理。</p><h5 id="组合方法"><a href="#组合方法" class="headerlink" title="组合方法"></a>组合方法</h5><p>对任务进行组合，常用方法有thenCompose()和thenCombine()。</p><p>thenCompose()可以链接两个CompletableFuture对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</p><p>thenCombine()会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</p><p>allOf()可以使多个CompletableFuture并行运行，都运行完后才会返回，调用join()则会等待所有CompletableFuture执行完毕，anyOf()则是只要有一个执行完毕后就会返回。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于CompletableFuture默认使用的是全局线程池，会有OOM的风险，因此最好指定线程池来创建CompletableFuture。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>很多线程协作类内部都有一个类Sync，且Sync是继承了AQS即AbstractQueuedSynchronizer抽象同步队列，实现了其中的一些方法。</p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>AQS核心思想就是如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于CLH队列实现的。其定义了一套多线程访问共享资源的同步模板，解决了实现同步器时涉及的大量细节问题，能够极大地减少实现工作。</p><p>包含如下内容：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞及唤醒</li><li>队列的管理</li></ul><p>其中包含核心的三个部分：state同步状态、Node组成的CLH队列、ConditionObject条件变量。</p><h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>在AQS中维护了一个同步状态变量state，getState函数获取同步状态，setState、compareAndSetState函数修改同步状态，对于AQS来说，线程同步的关键是对state的操作，可以说获取、释放资源是否成功都是由state决定的，比如state &gt; 0代表可获取资源，否则无法获取，所以state的具体语义由实现者去定义，现有的ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch定义的state语义都不一样。</p><ul><li>ReentrantLock的state用来表示是否有锁资源</li><li>ReentrantReadWriteLock的state高16位代表读锁状态，低16位代表写锁状态</li><li>Semaphore的state用来表示可用信号的个数</li><li>CountDownLatch的state用来表示计数器的值</li></ul><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><p>CLH是AQS内部维护的FIFO（先进先出）双端双向队列（方便尾部节点插入），基于链表数据结构，当一个线程竞争资源失败，就会将等待资源的线程封装成一个Node节点，通过CAS原子操作插入队列尾部，最终不同的Node节点连接组成了一个CLH队列，所以说AQS通过CLH队列管理竞争资源的线程，具有如下优点：</p><ul><li>先进先出保证了公平性</li><li>非阻塞的队列，通过自旋锁和AS保证节点插入和移除的原子性，实现无锁快速插入</li><li>采用了自旋锁思想，所以CLH也是一种基于链表的可扩展、高性能、公平的自旋锁</li></ul><p>其内部类Node定义如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，因为超时或者或者被中断，节点会被设置成取消状态。被取消的节点不会参与锁竞争，状态也不会再改变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示节点处于condition队列中，正在等待被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，下一次acquireShared应该无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 节点的等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个condition队列等待节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前驱节点或者抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>入队通过自旋CAS尝试往队列尾部插入节点，直到成功，自旋过程如果发现CLH队列不存在时会初始化CLH队列。</p><p>CLH队列中的节点都是获取资源失败的线程节点，当持有资源的线程释放资源时，会将head.next指向的线程节点唤醒（CLH队列的第二个节点），如果唤醒的线程节点获取资源成功，线程节点清空信息设置为头部节点，原头部节点出队。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>Object的wait、notify函数是配合Synchronized锁实现线程间同步协作的功能，AQS的ConditionObject条件变量也提供这样的功能，通过ConditionObject的await和signal两类函数完成。</p><p>不同于Synchronized锁，一个AQS可以对应多个条件变量，而Synchronized只有一个。</p><p>ConditionObject内部维护着一个单向条件队列，不同于CHL队列，条件队列只入队执行await的线程节点，并且加入条件队列的节点，不能在CHL队列， 条件队列出队的节点，会入队到CHL队列。</p><p>当某个线程执行了ConditionObject的await函数，阻塞当前线程，线程会被封装成Node节点添加到条件队列的末端，其他线程执行ConditionObject的signal函数，会将条件队列头部线程节点转移到CHL队列参与竞争资源。</p><h3 id="协作方法"><a href="#协作方法" class="headerlink" title="协作方法"></a>协作方法</h3><p>AQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>直接使用AQS提供的独占式模板，只需明确state的语义与实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可实现自定义协作类，AQS也支持同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><p>简单来说，仅需实现如下钩子方法：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 重学JUC</li><li><strong>作者:</strong> yhxjs</li><li><strong>创建于 :</strong> 2024-09-30 16:06:25</li><li><strong>更新于 :</strong> 2024-10-01 11:42:03</li><li><strong>链接:</strong> https://yhxjs.github.io/2024/09/30/重学JUC/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/JUC/">#JUC</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/10/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">函数式编程</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/08/06/IOC%E5%92%8CAOP%E5%8E%9F%E7%90%86/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">IOC和AOP原理</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"waline-server-eosin-nine.vercel.app",lang:"zh-CN",dark:'body[class~="dark-mode"]',requiredMeta:["nick","mail"],emoji:["https://unpkg.com/@waline/emojis@1.2.0/bilibili"],recaptchaV3Key:"6LcBOIgpAAAAAJZi-fT3F-oG6Vm0T8OFfbJazFaC"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">重学JUC</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">使用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">3.1.1.</span> <span class="nav-text">乐观锁vs悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%94%81vs%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">阻塞锁vs自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81vs%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.1.3.</span> <span class="nav-text">公平锁vs非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81vs%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.1.4.</span> <span class="nav-text">可重入锁vs不可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81vs%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">3.1.5.</span> <span class="nav-text">共享锁vs排他锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">原子变量类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">4.1.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.</span> <span class="nav-text">数组类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">引用类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">5.1.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">5.2.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">5.3.</span> <span class="nav-text">BlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">并发流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">6.1.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">6.2.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition"><span class="nav-number">6.3.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">6.4.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">6.5.</span> <span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable%E5%92%8CCallable"><span class="nav-number">6.5.1.</span> <span class="nav-text">Runnable和Callable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">6.5.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.5.3.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.5.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">7.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="nav-number">7.2.</span> <span class="nav-text">同步状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLH%E9%98%9F%E5%88%97"><span class="nav-number">7.3.</span> <span class="nav-text">CLH队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">7.4.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">7.5.</span> <span class="nav-text">协作方法</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="customize-info my-1">心之所向，素履以往，生如逆旅，一苇以航</div><div class="text-center">&copy; <span>2024</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">yhxjs</a><p class="post-count space-x-0.5"><span>共 23 篇文章 </span><span>共 39.1k 字</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools rss flex justify-center items-center"><a class="flex justify-center items-center" href="/atom.xml,rss2.xml" target="_blank"><i class="fa-regular fa-rss"></i></a></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/localSearch.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/layouts/lazyload.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div></body></html>