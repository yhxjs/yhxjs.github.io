<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yhxjs的博客</title>
  
  
  <link href="https://yhxjs.github.io/atom.xml" rel="self"/>
  
  <link href="https://yhxjs.github.io/"/>
  <updated>2024-03-25T15:19:08.055Z</updated>
  <id>https://yhxjs.github.io/</id>
  
  <author>
    <name>yhxjs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再识MyBatis-Plus</title>
    <link href="https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/"/>
    <id>https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/</id>
    <published>2024-03-23T09:42:21.000Z</published>
    <updated>2024-03-25T15:19:08.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本人之前学习过 MyBatis-Plus，但实际自己开发还是用的 MyBatis，基本就是简单 sql，因此用注解进行开发，手写 sql 也还好，故并未采用 MyBatis-Plus进行开发，但新入职的公司需要用到，于是进行重温，才有了这篇简略的记录。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正如<a class="link"   href="https://mybatis.plus/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>所说的愿景：成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。MyBatis-Plus 相当于 MyBatis 的增强版插件，可以一起使用，事半功倍，省去编写简单 sql 的功夫，具体介绍可自行去官网查看。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ol><li><p>@TableName</p><p>标识实体类对应的数据库表。</p></li><li><p>@TableId</p><p>标识主键属性。</p></li><li><p>@TableField</p><p>标识对应数据库字段。</p></li><li><p>@TableLogic</p><p>标识删除类型。</p></li></ol><h3 id="基本crud"><a href="#基本crud" class="headerlink" title="基本crud"></a>基本crud</h3><p>所有的基本 crud 都在 BaseMapper 接口中定义，只需要继承并指定具体实体类即可。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>BaseMapper 接口如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 更新</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity)</span>;</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量查询</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询一条数据</span></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询记录总数</span></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">selectPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">selectMapsPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;奕凰轩祭侍&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">userMapper.insert(user);</span><br><span class="line"><span class="comment">// 获取插入数据的主键 ID</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> user.getId();</span><br></pre></td></tr></table></figure></div><p>一般使用@TableId(type &#x3D; IdType.AUTO)来指定数据库主键，然后数据库还存在另外一个唯一标识符，一般由后端进行UUID或者雪花算法生成，该标识符相当于业务中使用的主键。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">10059249854L</span>); <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><p>根据主键删除，也可以直接传入对象，会根据标识的主键属性进行删除，以及可以根据其他条件删除，条件构造在<a href="#%E6%9F%A5">查询</a>中介绍。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">10059249854L</span>);</span><br><span class="line">user.setGender(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 实际执行的 SQL : UPDATE user SET gender=1 WHERE id=10059249854;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.updateById(user);  <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>在使用前需要进行 sql 条件语句的构建，有三种条件构建格式：</p><ol><li>常规条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapperr&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapperr</span>&lt;User&gt;();</span><br><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//今年刚满18岁~</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>lamda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lambda().eq(User::getName,<span class="string">&quot;劳大&quot;</span>); <span class="comment">//see you again（</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>lambda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lt(User::getPlay, <span class="string">&quot;Genshin Impact&quot;</span>); <span class="comment">//原神启动！</span></span><br></pre></td></tr></table></figure></div><h5 id="常见的单条件查询"><a href="#常见的单条件查询" class="headerlink" title="常见的单条件查询"></a>常见的单条件查询</h5><h6 id="lt匹配"><a href="#lt匹配" class="headerlink" title="lt匹配"></a>lt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="le匹配"><a href="#le匹配" class="headerlink" title="le匹配"></a>le匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.le(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="eq匹配"><a href="#eq匹配" class="headerlink" title="eq匹配"></a>eq匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//等同于=18</span></span><br></pre></td></tr></table></figure></div><h6 id="gt匹配"><a href="#gt匹配" class="headerlink" title="gt匹配"></a>gt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="ge匹配"><a href="#ge匹配" class="headerlink" title="ge匹配"></a>ge匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ge(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="ne匹配"><a href="#ne匹配" class="headerlink" title="ne匹配"></a>ne匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ne(User::getAge,<span class="number">18</span>); <span class="comment">//等同于!=18</span></span><br></pre></td></tr></table></figure></div><h6 id="between匹配"><a href="#between匹配" class="headerlink" title="between匹配"></a>between匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.between(User::getAge, <span class="number">17</span>, <span class="number">19</span>); <span class="comment">//等同于&gt;=17 &amp;&amp; &lt;= 19</span></span><br></pre></td></tr></table></figure></div><h6 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a>like匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.likeLeft(User::getName, <span class="string">&quot;奕&quot;</span>); <span class="comment">//相当于like %奕，还有like对应like %奕%、likeRight对应like 奕%</span></span><br></pre></td></tr></table></figure></div><p>还有其他的一些条件，例如orderByAsc对应升序等，具体可以自己操作看看。</p><h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>且</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">17</span>).lt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><p>或</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">17</span>).or().gt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h5><p>可以通过 condition 参数动态拼接条件，例如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(minAge != <span class="literal">null</span>, User::getAge, minAge);</span><br><span class="line">userWrapper.lt(maxAge != <span class="literal">null</span>, User::getAge, maxAge);</span><br></pre></td></tr></table></figure></div><h5 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h5><h6 id="查询部分属性"><a href="#查询部分属性" class="headerlink" title="查询部分属性"></a>查询部分属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(User::getName, User::getAge);</span><br></pre></td></tr></table></figure></div><h6 id="查询未定义属性"><a href="#查询未定义属性" class="headerlink" title="查询未定义属性"></a>查询未定义属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(<span class="string">&quot;count(*) as count&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">   .groupBy(<span class="string">&quot;age&quot;</span>)  <span class="comment">//分组字段</span></span><br><span class="line">           .having(<span class="string">&quot;COUNT(*)&gt;5&quot;</span>); <span class="comment">// 添加having筛选条件</span></span><br></pre></td></tr></table></figure></div><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子查询 select id from user where id &lt;= 10059249854</span></span><br><span class="line">userWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 10059249854&quot;</span>);</span><br><span class="line">userWrapper.select(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">userWrapper.last(<span class="string">&quot;LIMIT 10&quot;</span>);</span><br><span class="line"><span class="comment">// 实际执行 SQL : SELECT name,age FROM user WHERE (id IN (select id from user where id &lt;= 10059249854)) LIMIT 10;</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">最终还是拥抱了MyBatis-Plus。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://yhxjs.github.io/tags/Java/"/>
    
    <category term="MyBatis-Plus" scheme="https://yhxjs.github.io/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>ND协议</title>
    <link href="https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-03-06T04:35:35.000Z</published>
    <updated>2024-03-06T09:40:42.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</p><p>什么是邻居？即一个链路上的相邻主机或者路由器，主机与主机，主机和路由器，路由器和路由器可以互为邻居。</p><p>地址解析放在ICMP层，通过使用ICMPv6报文实现功能。</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format.png"                      width="400px" height="auto" alt="IPv6报头格式"                ><figcaption>IPv6报头格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format_wireshark.png"                      width="550px" height="auto" alt="IPv6报头(Wireshark)"                ><figcaption>IPv6报头(Wireshark)</figcaption></figure><p><strong>版本号</strong>(version)：同IPv4，指示IP版本</p><p><strong>流量等级</strong>(Traffic Class)：类似IPv4中的TOS字段，指示IPv6数据流通信类别或优先级</p><p><strong>流标签</strong>（FlowLabel)：标记需要特殊处理的数据流，用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据</p><p><strong>传输数据长度</strong>(Payload Length)：包含有效载荷数据的IPv6报文总长度</p><p><strong>下一个报头</strong>(Next Header)：该字段定义了紧跟在IPv6报头后面的第一个扩展报头(如果存在)的类型，或者上层协议数据单元中的协议类型</p><p><strong>跳限制</strong>(Hop Limit)：类似于IPv4中的TTL字段，它定义了IP数据包所能经过路由器的最大跳数</p><p><strong>源地址</strong>(Source Address)：128bit的IPv6地址</p><p><strong>目的地址</strong>(Destination Address)：128bit的IPv6地址</p><h4 id="与IPv4对比"><a href="#与IPv4对比" class="headerlink" title="与IPv4对比"></a>与IPv4对比</h4><p><strong>IPv6报头结构的改善</strong>：基本的IPv4报头长度为20个字节，基本的IPv6报头长度为40个字节</p><p><strong>取消了IP的校验</strong>：由于2层与4层的校验已经足够健壮，取消了IP的三层校验</p><p><strong>取消中间节点的分片功能</strong>：分片重组功能由源端实现，通过Path MTU机制来发现路径MTU</p><p><strong>定义最长的IPv6报头</strong>：有利于硬件的快速处理，中间节点节约大量资源</p><p><strong>安全选项的支持</strong>：IPv6提供了对IPsec的完美支持，上层协议省去大量安全选项，例如OSPFv3取消了认证</p><p><strong>增加流标签</strong>：提高QoS效率</p><h3 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h3><p>邻居发现协议定义了五种不同的ICMP包类型：路由请求RS（Router Solicitation）和路由告知RA（ Router Advertisement）消息，邻居请求NS（Neighbor Solicitation）和邻居告知NA（Neighbor Advertisements）消息，以及重定向（Redirect message）消息。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_packet_type.png"                      width="450px" height="auto" alt="ND协议报文类型"                ><figcaption>ND协议报文类型</figcaption></figure><h4 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h4><p>当一个接口变为可用时，主机可以发出路由请求消息来要求路由器马上生成路由告知（ Router Advertisement）消息，而不是等它的下一个固定生成时间。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./rs_packet_format.png"                      width="500px" height="auto" alt="RS报文格式"                ><figcaption>RS报文格式</figcaption></figure><p>源地址：接口的地址或者全0</p><p>目的地址：全部路由器组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：133</p><p>ICMP6 CODE：0</p><h4 id="路由告知"><a href="#路由告知" class="headerlink" title="路由告知"></a>路由告知</h4><p>路由器周期地用此消息通告它们的存在及各种链路参数和互联网参数，或响应Router Solicitation消息。Router Advertisements包括前缀，这些前缀用于确定是否另一个地址共享相同链路(on-link确认)和&#x2F;或地址配置，建议的跳数限制值，等等。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ra_packet_format.png"                      width="500px" height="auto" alt="RA报文格式"                ><figcaption>RA报文格式</figcaption></figure><p><strong>当前跳数值</strong>（Current Hop Limit）字段，用法如下：链路上的结点发送IPv6报文时，会用该字段的值来填充IPv6报文头的跳数限制字段。如果该字段值为0，说明路由器并不确定该值为多少。</p><p><strong>M位</strong>被称为管理地址配置（Managed Address Configuration）标志位，当该位被置1时，说明DHCPv6可用于结点地址配置。</p><p><strong>O位</strong>被称为其它有状态配置（Other Stateful Configuration）标志位，当该位被置1时，说明DHCPv6可用于获得非地址相关的配置信息，如DNS名称服务器的IPv6地址。</p><p><strong>路由器生命期</strong>字段是一个16位无符号数，计量单位为秒，它指示链路上的结点把该路由器做为默认路由器的时间为多长，最大值为18.2小时。该字段为0表示发送该报文的路由器不做为默认路由器，这时，结点在发送报文时，不会选择该路由器做为下一跳路由器。</p><p><strong>可达时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在收到一个邻居可达的确认报文后，认为该邻居仍然可达的时间。在这段时间内，如果结点没有再收到邻居可达的确认报文，结点会执行邻居不可达检测以确认邻居是否可达。该字段为0表示路由器不指定该参数。</p><p><strong>重传时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在执行邻居不可达检测或者地址解析时，连续发送邻居请求报文中间的时间间隔。该字段为0表示路由器不指定该参数。</p><p><strong>前缀</strong>选项，通过该选项，路由器向链路上通告本链路所有可达的前缀，并且通过标志位指出哪些前缀可用于结点的地址自动配置。</p><p>源地址：接口的本地链路地址</p><p>目的地址：发送路由器请求的主机的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：134</p><p>ICMP6 CODE：0</p><h4 id="邻居请求"><a href="#邻居请求" class="headerlink" title="邻居请求"></a>邻居请求</h4><p>节点发送该消息以确定某个邻居的链路层地址，或者用来验证通过缓存里的链路层地址是否依然能够到达该邻居。也经常用来做地址重复检测。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ns_packet_format.png"                      width="500px" height="auto" alt="NS报文格式"                ><figcaption>NS报文格式</figcaption></figure><p><strong>目标地址</strong>字段是一个IPv6地址，一般与目的地址相同，填的是请求的地址，该字段不能是多播地址。</p><p><strong>源链路层地址</strong>选项，协议建议携带，一般为源MAC</p><p>源地址：接口的地址或者未指定地址</p><p>目的地址：目标地址或者目标地址对应的请求节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：135</p><p>ICMP6 CODE：0</p><h4 id="邻居告知"><a href="#邻居告知" class="headerlink" title="邻居告知"></a>邻居告知</h4><p>邻居请求消息的回应。节点也可以发送非请求的Neighbor Advertisements，通知链路层地址改变。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./na_packet_format.png"                      width="500px" height="auto" alt="NA报文格式"                ><figcaption>NA报文格式</figcaption></figure><p><strong>R位</strong>是路由器（IsRouter）标志位，当这个标志位置1时，说明发送者是路由器。</p><p><strong>S位</strong>是被请求（Solicited）标志位，当这个标志位置1时，说明发送者发送邻居通告报文是因为接收到一个邻居请求报文，这个邻居通告报文的目的地址是单播地址；如果邻居通告报文目的地址是多播地址，则该位置0。</p><p><strong>O位</strong>是覆盖（Override）标志位，当这个标志位置1时，接收到该报文的结点查看邻居缓存，如果缓存中有发送该邻居通告报文结点的链路层地址，则更新之。否则忽略该邻居通告报文。</p><p><strong>目标地址</strong>字段是一个IPv6地址，如果邻居通告报文是由邻居请求报文触发的，则该地址是邻居请求报文中的目标地址。如果邻居通告报文是因为链路层地址变化触发的，则该地址是和变化的链路层地址相关的IPv6地址。该字段不能包含一个多播地址。</p><p><strong>目标链路层地址</strong>选项。如果邻居通告报文目的地址是多播地址，必须包含目标链路层地址选项。</p><p>源地址：接口的地址</p><p>目的地址：发送邻居请求节点的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：136</p><p>ICMP6 CODE：0</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>由路由器使用，用于通知主机有到目的地的较好的第一跳。路由器收到一个报文后，如果发现报文的目的地址和源地址是同一个链路的，或者到目的地址有一个更优的路由器，都会发送重定向报文。重定向报文的源地址必须使用链路本地地址。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./redirect_packet_format.png"                      width="500px" height="auto" alt="重定向报文格式"                ><figcaption>重定向报文格式</figcaption></figure><p><strong>重定向报文头</strong>选项包含了引发重定向报文的原始报文的内容。</p><p>源地址：接口的链路本地地址</p><p>目的地址：触发重定向的数据包的源地址</p><p>跳数：255</p><p>ICMP6 TYPE：137</p><p>ICMP6 CODE：0</p><blockquote><p>主机不能发送路由器通告，路由器不能发送路由器请求。</p><p>主机不能发送重定向报文，路由器不能处理重定向报文。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><a href="#%E8%A7%A3%E6%9E%90%E9%82%BB%E5%B1%85%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80">解析邻居的链路层地址</a></li><li><a href="#%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%EF%BC%88DAD%EF%BC%89">地址冲突检测（DAD）</a></li><li><a href="#%E9%82%BB%E5%B1%85%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%A3%80%E6%B5%8B%EF%BC%88NUD%EF%BC%89">邻居不可达检测（NUD）</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E5%89%8D%E7%BC%80%E5%8F%91%E7%8E%B0">路由器和前缀发现</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91">路由重定向</a></li></ul><h3 id="解析邻居的链路层地址"><a href="#解析邻居的链路层地址" class="headerlink" title="解析邻居的链路层地址"></a>解析邻居的链路层地址</h3><p>IPv6取消ARP协议，通过邻居请求（NS）和邻居通告（NA）报文来解析三层地址对应的链路层地址。</p><p>邻居请求NS使用组播，比ARP效率高，邻居公告NA返回则直接使用单播。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_address_resolution.png"                      width="650px" height="auto" alt="IPv6地址解析"                ><figcaption>IPv6地址解析</figcaption></figure><p>一整个ping的过程跟ARP一样相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show ipv6 nd-packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_ipv6_nd_packet_history.png"                      width="100%" height="auto" alt="show ipv6 nd-packet history"                ><figcaption>show ipv6 nd-packet history</figcaption></figure><h3 id="地址冲突检测（DAD）"><a href="#地址冲突检测（DAD）" class="headerlink" title="地址冲突检测（DAD）"></a>地址冲突检测（DAD）</h3><p>DAD首先发送源地址为未分配地址，目的地址为要进行DAD检测的地址所对应被请求节点的组播地址，然后目标IP携带要进行DAD检测的地址的NS报文，若有冲突，则被请求节点发送源地址为DAD检测的地址，目的地址为全局组播地址，并目标IP携带DAD检测的地址，以及源链路层选项附上自己的链路层地址的NA报文。</p><h3 id="邻居不可达检测（NUD）"><a href="#邻居不可达检测（NUD）" class="headerlink" title="邻居不可达检测（NUD）"></a>邻居不可达检测（NUD）</h3><p>NUD首先发送源地址为接口的链路本地地址，目的地址为要进行NUD检测的单播地址，然后目标IP携带要进行NUD检测的单播地址的NS报文，若可达，则被请求节点发送源地址为NUD检测的地址，目的地址为NS的源地址，并目标IP携带NUD检测的地址，并将S位置为1的NA报文。</p><h3 id="路由器和前缀发现"><a href="#路由器和前缀发现" class="headerlink" title="路由器和前缀发现"></a>路由器和前缀发现</h3><p>当主机未配置单播地址时，就会发送RS，路由器和本地链路节点会发送RA，以使主机进行自动地址配置。</p><p>当主机接收到RA后，使用其中的前缀信息和本地接口ID自动形成IPV6地址，还可根据其中的路由器信息设置默认路由器。</p><p>RS可定位邻居路由器，同时学习和自动配置有关的前缀和配置参数。</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>假设链路上一个结点发送一个报文，源地址是A，目的地址是B，路由器收到该报文后，发送一个重定向报文，重定向报文中目标地址字段是C，该地址是告诉结点更好的下一跳地址，目的地址字段是B，该地址是结点发出去报文的目的地址，和上面的B是同一个地址。如果C和B不同，说明C地址是一个更优的路由器地址，如果C和B相同，说明B地址是同一个链路上结点的地址。</p><h2 id="表项状态"><a href="#表项状态" class="headerlink" title="表项状态"></a>表项状态</h2><p>ND表项有五种状态：</p><p><strong>INCOMPLETE</strong>（未完成的）地址解析在进行中，邻居的链路层地址还没有被确定。</p><p><strong>REACHABLE</strong>（可到达的）粗略讲，已知邻居最近(几十秒前)是可达的。</p><p><strong>STALE</strong>（陈旧的）邻居不再被认为是可达的，但是直到流量发送给该邻居时，不应当尝试改变它的可达性。</p><p><strong>DELAY</strong>（延时）邻居不再被认为是可达的，最近流量已经发送到该邻居。然而，不立即探测该邻居的可达性，延时一段时间发送探测消息，以便给上层协议一个机会提供可达性确认。</p><p><strong>PROBE</strong>（探测）邻居不再被认为是可达的，并且发送了单播NS探测消息以便验证可达性。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_entry_state.png"                      width="700px" height="auto" alt="ND表项状态机"                ><figcaption>ND表项状态机</figcaption></figure><p><strong>EMPTY</strong>状态代表邻居表项不存在或者被删除。发送IPv6报文时，如果下一跳不在邻居表中，那么创建一条状态为INCOMPLETE的邻居表项，发送多播邻居请求报文，每隔1秒钟发一次，连发3次，直到收到应答为止。如果连发3次邻居请求报文都没有收到应答，那么删除邻居表项。如果收到应答，邻居表项的状态迁移到REACHABLE。</p><p><strong>REACHABLE</strong>状态的持续时间缺省值是30秒，即在30秒钟内认为邻居可到达，30秒以后，迁移到STALE状态。如果在REACHABLE状态，收到邻居请求或者公告，发现MAC地址变化了，表项迁移到STALE状态。</p><p>处于<strong>STALE</strong>状态，如果发送报文时命中这条邻居表项，那么迁移到DELAY状态，准备进行邻居不可达检测。对于STALE状态的持续时间，RFC没有规定。</p><p>处于<strong>DELAY</strong>状态，5秒钟以后进入PROBE状态。</p><p>处于<strong>PROBE</strong>状态，开始进行邻居不可达检测，发单播邻居请求，每秒发一次，连发3次，直到收到应答为止。如果收到应答，迁移到REACHABLE状态。如果连发3次仍然没有收到应答，就认为邻居不可达，删除邻居表项。</p><p>收到邻居请求，创建新的邻居表项，状态必须是STALE，因为收到邻居请求只能证明对方发送的报文可到达自己，而不能确定自己发送的报文能到达对方。</p><p>在进行邻居不可达检测时，结点发送的邻居请求报文可以包含源链路层地址选项，也可以不包含。如果邻居请求报文中没有包含源链路层地址选项。接收结点在发送邻居通告报文时，可能还需要执行地址解析操作。所以RFC2461建议邻居请求报文发送者包含源链路层地址选项。</p>]]></content>
    
    
    <summary type="html">邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</summary>
    
    
    
    <category term="通信" scheme="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="通信" scheme="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
    <category term="ND" scheme="https://yhxjs.github.io/tags/ND/"/>
    
  </entry>
  
  <entry>
    <title>ARP协议</title>
    <link href="https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-03-05T13:11:28.000Z</published>
    <updated>2024-03-06T09:37:46.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARP即地址解析协议，将IP地址解析为MAC地址。数据要在以太网中传输，需要完成以太网封装，这项工作由网络层负责。要完成以太网的数据封装，需要知道目的设备的MAC地址。</p><p>注意：ARP报文不能穿越路由器，不能被转发到其他广播域</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format.png"                      width="400px" height="auto" alt="ARP报文格式"                ><figcaption>ARP报文格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format_wireshark.png"                      width="450px" height="auto" alt="ARP报文格式(Wireshark)"                ><figcaption>ARP报文格式(Wireshark)</figcaption></figure><p><strong>硬件类型</strong>：表示硬件地址的类型（其中，值为1表示以太网地址，其他还可能表示令牌环地址）。</p><p><strong>协议类型</strong>：表示要映射的协议地址类型（其中，0x0800表示IP地址，其他还可能是ICMP&#x2F;IGMP）。</p><p><strong>硬件地址长度</strong>：指出该报文中硬件地址的长度（ARP报文中，它的值为6）。</p><p><strong>协议地址长度</strong>：指出该报文中协议地址的长度（ARP报文中，它的值为4）。</p><p><strong>op</strong>：操作字段，共有4种类型（1.ARP请求，2.ARP应答，3.RARP请求，4.RARP应答）。</p><p><strong>源MAC地址</strong>：发送方设备的硬件地址。</p><p><strong>源IP地址</strong>：发送方设备的IP地址。</p><p><strong>目的MAC地址</strong>：接收方设备的硬件地址。</p><p><strong>目的IP地址</strong>：接收方设备的IP地址。</p><p>ARP报文解析主要关心的是后五个字段。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_workflow.png"                      width="450px" height="auto" alt="ARP工作流程"                ><figcaption>ARP工作流程</figcaption></figure><ol><li>先查看ARP表，如果ARP表中没有目的IP地址对应的MAC表项，则发送ARP请求包</li><li>源主机广播发送ARP request 数据包，请求目的主机的MAC地址</li><li>同网段内的所有主机都能收到ARP request请求包，但只有目的主机才会回复ARP reply数据包</li><li>源主机收到ARP reply后，将目的主句的IP-MAC对应关系添加进ARP表中，完成数据的以太网封装，进行数据交互</li></ol><p>通过Wireshark抓包可以看到整个过程。</p><p>IP为192.168.56.105的主机A广播目的IP为192.168.56.1的ARP请求，当IP为192.168.56.1的主机B收到该请求后，应答自己的MAC地址给主机A：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_request_wireshark.png"                      width="450px" height="auto" alt="ARP请求(Wireshark)"                ><figcaption>ARP请求(Wireshark)</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_reply_wireshark.png"                      width="450px" height="auto" alt="ARP应答(Wireshark)"                ><figcaption>ARP应答(Wireshark)</figcaption></figure><p>而一整个ping的过程相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show arp packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_arp_packet_history.png"                      width="100%" height="auto" alt="show arp packet history"                ><figcaption>show arp packet history</figcaption></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table><thead><tr><th>类别</th><th>含义</th><th>作用</th><th>属性</th></tr></thead><tbody><tr><td>静态</td><td>手动配置（优先级高）、认证下发</td><td></td><td>永久、表项不更新</td></tr><tr><td>动态</td><td>通过报文学得</td><td></td><td>老化、表项更新</td></tr><tr><td>可信任</td><td>客户端认证时候，会在网关交换机上添加arp，该arp是真实有效的</td><td>位于交换机端ARP表项中，防止ARP欺骗</td><td>具有静、动态属性</td></tr><tr><td>免费</td><td>源、目的IP都是自己的广播arp报文</td><td>IP地址冲突检测、MAC地址变化通知其他设备</td><td>可以定时发送免费ARP，若无IP冲突不能应答</td></tr><tr><td>代理</td><td>源目的不属于同一网段，设备知道目的ip的路由信息时，则进行代替arp响应</td><td></td><td></td></tr><tr><td>本地代理</td><td>以网关自身的MAC回应本网段的IP地址的ARP请求</td><td>用于二层端口隔离时，主机先获取网关的mac，之后在网关设备上报文会被上送三层，通过三层路由实现同一网段内主机通讯</td><td></td></tr><tr><td>any ip</td><td>任意IP地址都可以上网，ARP请求的源IP和设备不在同网段，且目的IP可能不是自己，但网关仍然发送ARP应答，并且为主机的IP地址生成直连路由</td><td>场景：无需修改IP与网关即可正常上网，例如网吧、酒店等地方</td><td></td></tr><tr><td>探测</td><td>源IP为0，目的IP为待探测地址</td><td>收到应答则说明该IP被使用</td><td></td></tr></tbody></table><h2 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h2><p>首先底层对报文进行处理，将二进制报文转化为可处理的格式，然后交由控制层进行处理。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_processing.png"                      width="300px" height="auto" alt="ARP报文处理逻辑"                ><figcaption>ARP报文处理逻辑</figcaption></figure><ol><li><p>操作码op，源接口和二层接口协议状态，格式检查，MAC合法性，IP合法性，免费ARP检查，ACL检查等，经过上述一系列检查后，源IP和目的IP都不为0，且都是合法的。</p></li><li><p>判断源IP和源接口是否处于同一网段，主要区分就是VRRP的虚IP和开启了any-ip-arp要进行特殊处理，经过判断后，如果是同一网段就进行处理，否则就丢弃即忽略。只要源IP和本机IP是一致的，都认为IP地址冲突，查看源MAC和源接口的MAC是否相同，如若相同，则说明是自己发的，不进行处理，否则进行冲突应答。如果目的IP为本机IP，判断是否是发给自己的，如果是则继续进行处理，否则进行相关的代理。</p></li><li><p>普通处理</p><p>处理request报文：</p><ol><li><p>目的地址是我们的IP，则不更新表项，只应答。</p></li><li><p>目的地址不是我们的IP，则不应答。</p></li><li><p>如果MAC地址不一样，需要代理冲突应答，并走老化逻辑。</p></li></ol><p>处理reply报文：如果源IP匹配到了表项或者开启了某种学习才进行表项的学习更新。</p></li></ol>]]></content>
    
    
    <summary type="html">ARP即地址解析协议，将IP地址解析为MAC地址。</summary>
    
    
    
    <category term="通信" scheme="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="ARP" scheme="https://yhxjs.github.io/tags/ARP/"/>
    
    <category term="通信" scheme="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>学习路线</title>
    <link href="https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2024-03-03T10:39:23.000Z</published>
    <updated>2024-03-03T11:04:46.276Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重新输入。" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="88247cd0df9052ab461d05c4cab63bb2dc7bbf598349d201fd03300c4f8fef9c">7e302a64c19ca2d3ce010e4131597270786b1bb1aaf244198f42d692eb66feb4bc070be16da0a052557145b88b06a7387e3029ffbbbb6130fe0a097cb8511ca043a3a1ac49a1c8d6e3209fbd33f4b5ec808511bbbcbf9eed5db3d988448945fdaf4926c793654b80518ba075a6b012b2b528ba26ffb32b6aa542d403457d3f99e138490ec2452377bb9d0aa0876d21a39ad74194eaaae82bac2f29811278064ba1ad8d323242753fcec2d647caf57e8c68a1631c6ea4b6795455aa5bddb4a7a5a6984c24e714e3a1d4b6a1f5b40d103dff22152cb5767dc0a07e63d419d50e66a3bacd98da6b63001b6dca188b97684ded665fa39e575da0bb50467826e5ab6c4e9bc7c13e5ffd851a763e80e8888f1eb158ace8a3adae10e4952a59972ded7b629425a5ba52a89aa1eb7f33f9f7a05e2282c8dd2eebdff6cbc5ff68888ad769e483801c95580f6dd44181059e723b45f1fad1441331cea7c03cf97f53e7bbceb448a73794b615a27670c7f537a9c0a360483360caa5392103a0a8887c3638cb9e49ef68db8040d2bfba1151e13c678a03996de7eb7942afe332a110eac08fa47e6c6e0ac1170d4ede7d0cc4e3cfc361c8e7e46aa9772c81e54cc1b1860fd6d08f2eb449ec0070f9f3a8162522a544bab118fb9a3234c10d03c9fdef4589ca16f812d81e033618be3866d1dc6668f8a08cb1cd9cefc5c7f6dcfe027c736e704176c9c3f75175d7c8c0852104d043665cbe3e2aca512baaf852962b738a979e4a0c0aae312650f44bc3239b826102c17e1e9d7f63fe28418a2487b913515c15782cd7a799666617bb8c49f1f6b6f4e4c758a8ba1f52b017517a27f5824b06817b4c24374441f553427fc8caf213d20e780d69ca47bc27a799bff3d895b50b5dc1a9773881963fa87203c2d78abed04f544dd4302843677e7e3fefac05e85f4879404a1fae894d13a6ca799b0b6e2c9f6222c7973239865cf5f59d645d62349f8645c2e852d24366c5149903c8042effb49e3b513f7138905e63070c65e09036604217472a4e1b29e6f6fe3e4b5c6ec873275af907d941e05fea1c9a009519b4b22d60c43f7661efea590b5a85170908fde78956f72a07c619eab9211dc2b2c7deb69fb6924b659d0e9e620f264c67af600828e4f3271a017f36249688ef1c45fcb2e0ad046ea84df8b3453e599365a3ed4a2d3123e88c84d23fb5d252bffb78ce4f7743912face06c5f0509b96c59f7ab815c00c5c7ff19d4edf909f0797610aacd54e12819bd04e9322ab69c9c0a969191ada2d3926f588e7ad54cd323632033cbec7c345891d53cf2c7dd566a888fbff271258b42f01cfaef3b87d6b660a928889bddbcede75e86cc0b28e8a7e5f8cfbfb75743436c86a48116ca0a24126bcd4790114ad22f2254d4f54ae663437574bcbd53a3a7a81dc066e2b37601836679b9eb5bf061368d82d99fd3ec79037eb24bcaf6130d7eedb69eef6fc0d3a3bcf197f4d243a61f272407c7399a446da734325a3d057459ae9b486045bd55d2d5e3c50c2aca45f13257a3d916dec48ce80382f53e5295a691c4842c74b02407228849e96782179788918da40ef252656db9e7c524ba793e5965dbcfb4a8e8e0d5d3a3fc0e155f5ff2b3debbf4f0d261bf6c61e251e28f068d212722aca95a476410f12aa2580dfbb0ef0163532a61925506e645da8dc4cd5ae960ccbd8bd05094ba81016a3ee4181bd7c383e0b5bd573e5eef0ef546b1a0846af0c6b3b583a2cbad7dcf7aabc61a27bd36aa997a1c4508ebcfec0459960cfc35bc55477158a0923d1e79fd04e5414b6e219df9727d7030a2b05c37243264470b9c491b71b840c499d06d4ff19232b800579722d0fb8c281df6b5a54e4b0fe252fecc5c3dd081da3fcdb629c8d4f274d003155890883791c1b6e731ea0bd2f297cde53a49d1aea1233a39103cab73d3454e3a6ae70a310d6be786d4d9dc40d2b7d74bffec2a76d3444fabf4309ea25fe6113f2b771125804c24394966bfc50ab206519ba84bbccefcb715d69a020651fe01f797486c12c54405bb0ca40a50a7b193e5e3617178d982d35370517af59205004ae784934c108fba3568433b7eaaf184fef2a88342af90a2cf1f92d5f78b293e5044b47d4e064ff496a05714e531619477eb38953faed1ea67380fa73df0afec0e415978d1afa6b9a2fb952575a197bb86351946df3965dd858bdbc55ff067b26c252dc7cc13fcd3f3206f82ce231f5970e43aa65dc9c53cefd494b30776d9128fdbdc9eec0f969d53b2905a47a92e4e19ad224b7ab950344043c6d53cdaec9e739a4968d6d86f2c833d283d9fb88ce043fb203fbb7bbea6c9db3683efaf2426a8847df5730c920a637f4f324bf7dfefa70f7096fd9fbc0481ca5fc0b5b89d0b605c428ebe71d1c59c06620670f316d0c9e90fa6e29006446d2b3af79fc84ff604c4192db8548f1c2373bbd401ea9b3153195a0bf7a6e2858ecbacbec605fe763840d8eb1b899750e6064b890a362398871604d7b8bad7065e5cc6dc6c19d9ee8723161c7989723b315608bd4e2b37f9c7c44776d925f120c4cd1408a62dc8e57fce927789a09aa54e46875cd78f5af37720d890113b24e68a12d97da5f4a395a383b242e1570c31160f0a4c948c810dc59979d51971f90a6c5be91e7ef1abe178e25978a2a187872b6d0fb6086ec078a83111cb223f9f2843ecf636ef594c44c48409f8a9cc71d55d1c40266356c1b32f7e3753cfaa4670976b6f5245de0eaac54f9d8b4d36c166673749114159c186212d59f6f486141a314a43fd0153939a861ac8d09fcd911f0e6f006d019861f2e22f8a53ddbd7706982727fb759e7989250580a723d714e81c1772ebb0d74c5795d2a5d881724ae5a574e22402ad02097c64fad3d2f921c08ea52a4e4ba5d0db166b3a54e8e785b09366b8dd1819e312aaeb2b93c8edba305f9abda30016a49b2727df106fa7ead96e9dafc3fcfb2b0952f0020cdb48f3db9b001a8588fa411fda26161e528481aed14dc667175a8d8f262642e8313dd0c15e924fba32c70d594b8325d3529f602666138ad95c77c5f24379f7ddcdb2bac1386c13397ef6bdd3b742234595a2950a56c39c2e409cce12a73fbb76fb9597d071bcd7048592e48a025ca73e38a0ede3a5788fd95ce0edca230392c188d84572e533a6df9c43012e660173d7b567ffe0e383384263824a010b90ba963639d6b2877fd14a1d6d85e3eb8635e5aca1cdadb156547adb622e5ad693f96347201407b27e8a487bf420fbe0fa7df5312e792ac641c9a252df3534060e77cbeec8d0d3a36c196e31140c48668c1cbc6175d37775779f93d3bfa90c9f953fc53a0c0b511a4822a3b993724793e677aa2b591c2f941d1fbb3adf89b41bd9411fd05a2036a3ddd212dfd3b8858c4deb7da95f50353f857841c159a1ad22c4bf38ab942cfa7f9be5d3d62e1d0294081808192d13f59f9d4ed35ac9322f79a554d5bcb1a4a616440f828eee1eb6b46a8ca611cb812bd411349875fe447ecf997c67917c2ec13e6939621eb6512658e4cd7fd27fa57c652c60badbfbd967a50682960184a0ed6ce79154ad446127f6f2661be06c34cdc77fedd342f8ce537c70b50116e690c04ad0cf57316bbc06330c3a0d808f2aea51a07cf74ae917d12276c44ccd9f9d66226e4cb75507c055deb58a10678336426035570469ac0df06c9e89b04451fc82776f2f3fe88ccf09869c850cb707303e6de6ad3af76fc51083d10d19c3ef39465519fd52516b2dc8e8a978acdbee3ac4516086ffc8de4be936c1428ef0934224054d365cba6b9f1d1f72af500c14932a3835ed90889b2721f8cc56f6ede85104f289bd51e693560119b98f4c704e76894fc2ab41554be217aa3eeeb691d274a066cdaaa8513a492f31bbd1a1aff277c2aefef0c6cdfde0eef90ff9e62803dde4ce1d69a19fcb4db96ed9f2f24a428380ba6fbefd18e2cd498f115c01f6cdc8b6c02d2baee224f125865353710d652307a0e6f53e12f684b832379bfdcc882c8b531ec865a4074866d5f3dd2d47beff3c611b48fb4370fb3655c532dcbab847f254d8431bee78a5e5659f8c201d44a97f2bce59847ec16818d540c0fb1b1a60788d448a04c8accbdb62cd06c61746d6cf8ac8abba73a44828503cddf411e5e8e1076a19925db73d71c14fea1ad6988310372dcba27506c75ccf00a80ae55dd6860a56da75bdbb9ed255062bd0a5a873dacbee19ce8ce678f0048aa1671bf1e8b7ceb2acf1929fc28de94e97066b1e2a6921b0092eca5418f13e3c49457fee5d50bdc27f9c4cbdfced4349d98ac9da99d1d00fa2d4c6dfa26e5548c2e5a7ddef8c6591fd0369b3188b905302e8ec3cf1b86d2b40d055dd272fe55181fa0a7f7bf0060524e2a985e739114be8fa6047e78db07d48cc6495fa32907e0a1087d17a5674324c14e7daafaed9efe8c2ad2581ad80d6ed20132d80243e66853554d2f25ef590b972c69c78b573a9d3410bb3453b0dcce4eb3f0d1319371bee24283b97e9768bee086b8cabf669a59e74da8650837ae4ead92d18f838c77ebfa10808694669b6029509b251e7dd88dca9ec4ab1a02113fdf450f5d2cdab18fd21c0685c8bc09c9e33205ea66c796940ce9f61f68bbb10a42b76ddfb5b06fb19e7b5c319a23f5d5af440599e2f5141eb7ae62e24c71d36e91adf2a14b75757761232fab6cd532dbe84116966a5ecd11f3e290023b7e02de687b6aabe6124fc04092b4eae5d670d0dba90680ae0cc99c440b090ca8d5480839e1c991178722d6aa9c7efc44c6c91baf3349a837fe254110c40e055fc3a37e1259248cc8748696920ee5669969c917d2b638ebf28dc737445b6240e4d370782ba3a545b09f476448ba9de1b94d3d498a1f38b5e6e0710e6fb40bb371b3ab9afbf3f7c2330eec651b2fecf159c2db58b0d1dc95c3b1cebb98450b56ef4efcacc4b7b62cea2a9f9c82a084e3d276bbef248638b07d55b53748f1cb33c92f5953ad211d34fc565b4c19e4ad1d0d673a2fb0ef0b1fa65415889ee0e1316dfb2bbc71c151c22526dd2c63d939ea5f25e15c009538ae2d3a58fe2e0b01012f7544526243fa61b9349d43c49031794db858b5d6d7e0a5770c141b443dca73409669e64885b113a17a791832f03aa9bed8919c98c50f5799bf6bf3759e66b9e566654af0acaa9ebb979e8ee7407fde231a0433abd96290fe9e2b04ec95322907a654dd61b743977c1224fbfbbf10e43850e8a62ea0ef4b19a18a0fc36f48b32886df16e6e207fb7c3fb09de8e78597d95633fc358401bcd52f6c5294a331b27f01ab7c85e6dd5d698ae6938101f924b97576a7d486682c6e0af17dd8ff5015140899632e3276eeac3680581412b3359d9cba9701323e6e14f467127c998a37ad4ed14bffc3f4fe11637062dd4055c6bf787e06a10681c8882798f164f6fbeacecdb804159684c99381cb44cbf8fd03594febefbd425debfa6a9df2b13aad32bedb41fc9de5aca41914fb271e74856ddba4aa74e700325f844811ce63e2e6eefc3fbc9cb4aabf3e456addf907121f7f648689834c6eb4d14edd06e26ee2d50d58520388979f27ac709cc77c7bb52140350f8ecc27a0a57004d104c49fb22eee96800ab5fe3d14846f629c6b38eb460cb17479401505c117c950c39d2fa88244fc3882897e9216ee59264e5b8167b061406c932ffaab9ddb2c094859c78f071bdff2c7a9f6ea5fdea53e57d8abf1348f85c145fe5ee3e619cc7bafdd454c647bb7b24b355adc4eb6eb3891d212b15f985c511b3db83617227570fdfa40386e007062ce33bedc9af112b50a2b39418704c8b838ce102476f7d2c857e291094d337ed86c42f6fb7713530bfb7a24a7a7c1684b8e905db5435a08e4716c342e537d3fcac6e967bfe93824fd21cfad50a383c6c9f836b077ad8d799c0fff7ec42477bc4f78ffd970ef661fa5d291ddc9683199da6d5ec05658d595f6adcff7393bd2f5a0445e6c94aa439f2273b7c29c0030f05728d8117658ac3c4c1600f37403ac6961792644d7c6f012625d4f9bc529a1ba2abf1de74a0bc0fb3fc5bde2261e41d65a51e55647f7b26b0c60e3cb3b3c48c67e4edc7ceb0fb180245d8d26084d5e19278d5c327c9f02d53810370a8faab48012a2bc5c9feb93fd84a16b9f8804a496ac10e6ea4692352ab5d5ed85819992f2f7ed9597e9979e42bdf15fe64ab25694a481f50e7ac9a988cff6a74860a9881ea267cbca0e84a568d6d6044e2c7df497fa5c7eed4ae5c4955e97b9f07ca544ec7e2c41a027fbe7f3895449a121068d00e3059724f1d4c2f534e69226d00abda308ca9500aa647be9a9491e6ac92d72033edbb92b921c0999ed2da3f893f18921ae78047bfafff7bc60d699a62290df0305f902dd40c0c11437fa4c988aee00580a73dd3d5e439561d72c9ff58e8d1c14585082a1850760672655e7f53202dcaf5defe75a03f51dc44275eca83a4a9868eb8912cb41055c8856ad15b0b93e7d24c060ce948a7cc164c85e514f0f0cd0cf2e3dfc272bddebb78f137ab8b01fea6a24e8b1fbefb1f0622e5894b70bf9f50744efc1cbd3da165389c0f555c20e90a6dd8857c7a6366641613a20c7f9ba74cd4b948637cb34f5afb0fd130a8aee81e9e9fd45d6a49c8e452411bf737f34c899e2f2b41a0369099d50195baf41041ee4fb7a2a522fb90a5c3ee64cd99a0c8bd60ff476bc2a30b9bacce0eea51a2a3ac917277b291f5152d6eb043082d0540cab5ee18710aa4e5219aa00beddbe312df0cc224257accde12d91c5369280d4114b2d4d69fca409d6b7cc3219396baf9a8dff39bdf18ddac87a3eedbf06c8a3545a7194e428e8bf96f57d530eda0c333dfb12e0328efbb2a80616889521f6b763d13ffa1bfb3870dd21e3dcdf7227dc629917695edf1fd8e903ba78d511b45c50162b3551a0f1f3bed522ba68fe0b22440cc0d811a9f2bb4cb2ea76b95ed6daa901812cc57cd4adb1d9701bbe97ffd23d0d13c2df5f50f9d279b3c4f130fd4849e15e374cc47806dc08ebd3fccfd198b86b8dfc2ff96b29fab88bfc5b0a44f59675368b8e8bbbf57419fd9e5a3ceec9a1b5bc8cd92be6bd9712a7fe386dc18a310844ab1bbc16bf8652eb8c9aba0aa9d72ec1778a877309f44c88c553a63bf6398ef04c1ea35f1fb42d5cacf4cce2deb6178072818760a886df6a8a783d18eb10a66986724f1676eb2e6d18581dcde978a319bb3b6ea205739385cb555ff4c1b0bd58d5fb1b9c8e78fbe29e1ba7430e4706a3c7989efc351f67a130223fe0e0f14d4ac8626260102bdd85e5a9382847a19d452384adc9064ef59de521cb0d783387af35126817bcf32d4bc6152095ad8eab77bc88cb105a2150f0ebb32592950424b4e63d2490a05ecd7c9cc6272569920de20ec0ca152bf43126e5a150599bce6138a29514de560b5001cc28323f65cb0a49e1df310f275c8040c6dc66d8611c5cebb0f94811f8b91d7e813d30c7cda8438be8752e64d6d146610d7ae58deacc514559ec2eae004c1c625576ec1fb8c2d6ee0a1f9ed4a63e2d9ee6ccae938f2f66ae50c7928ce2f65de0230c7ff9c80bb382e4bd89df604e12f23633049f37b5ccf233386e0b00b1bcd40bff8a000a4c21d7e3d26b385534a8c3910c6cb2ef7b6b4480eeffe1405ac7ad94b0551f52d40d827ee13df7afd5821ca1d3ab7e0263215e9544e43bc23eca3e9f30cf83ecfff37f166489ba148fa7c6349d5f5cd0feb9948f60b950bfae5262fa53e6e144106b3a493be98b82c01ecd76e2f21b0b47418883afbd164094a4ce14fef085b99f3a1bbe2e325e131a97455924d28c2c09aee21ab816068935fdb298f0a8672782abb38a960356f3a5ee25e8728fb85cbc9c39f3edfb01a5056d8c9aa5f7324fd061ccb37464deb21840be8187ed3caea3aae3689c89be306cd5e9345553fe05b14ff749d9df22f328065b4a8bb1deb307209617922c31afb219eb737d3acf30d3978f3becbdd2a66870918105479f738675b493e8eaa4fbd4047d4cd720f1fbc059ff2435dca273f53af79c59e97eb69887240df5efc3e5e1daa9eebf804d494bd1d13a1aaee57ac8cab631c35ae186bdbe24d1f1157c6dd81bc462d73f94c7e3cbc625ef43e25dbda724fce34aaa75e061d53051a640b367519a27f3cbbbafc29cf97989ed1cb6155276848fd7e31cef24ba9dee5ceb7423ba29d7fc9a9b1685fa7003b765b9eeefcca3e992ebb1f59dc86b356a3f8b5fcb174c7b55bfef61a267e42e70562006ac0096e5759ec82df2d4e10ff1f7206dcbbf4560551c3014ae482275939ca4a278f37e8c7898977557ddcbbd342728d4e6117b3a796417b725ab4a97c090a61691ac069e6464fc86368</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以查看此内容</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">加密内容，输入密码后方可查看。</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="学习路线" scheme="https://yhxjs.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置</title>
    <link href="https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/"/>
    <id>https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/</id>
    <published>2024-02-29T12:08:40.000Z</published>
    <updated>2024-03-06T09:41:43.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm 和 git，因此需要搭建本地操作环境，安装 <a class="link"   href="https://nodejs.org/en" >Node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" >Git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>具体教程可参考 <a class="link"   href="https://blog.csdn.net/WHF__/article/details/129362462" >Node.js下载安装及环境配置教程  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://blog.csdn.net/mukes/article/details/115693833" >Git 详细安装教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>安装所需依赖后，可以开始安装 Hexo 了。</p><p>新建一个文件夹用来存放 Hexo 的程序文件，在终端输入以下命令安装 Hexo 的命令行工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div><p>安装完毕后输入 hexo -v 即可查看到版本信息，没问题即可继续。</p>  <div class="note p-4 mb-4 rounded-small success">    <figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/hexo-v.png"                      class="" alt="hexo -v"                ><figcaption>hexo -v</figcaption></figure>  </div><p>在GitHub上创建个人页仓库，命名格式为 <strong>用户名.github.io</strong></p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./creat_repository.png"                      width="600px" height="auto" alt="创建个人页仓库"                ><figcaption>创建个人页仓库</figcaption></figure><p>至此，前期工作已准备完毕，接下来进行具体配置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="初始化并安装依赖组件"><a href="#初始化并安装依赖组件" class="headerlink" title="初始化并安装依赖组件"></a>初始化并安装依赖组件</h3><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init# 初始化</span><br><span class="line">npm i# 安装组件</span><br></pre></td></tr></table></figure></div><p>完成后输入以下命令即可开启本地服务器进行预览：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g# 生成页面</span><br><span class="line">hexo s  # 启动服务器</span><br></pre></td></tr></table></figure></div><p>访问<a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，即可看到默认页面，至此，本地安装结束。</p><p>Hexo 程序目录：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./directory_structure.png"                      width="400px" height="auto" alt="目录结构"                ><figcaption>目录结构</figcaption></figure><h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>输入以下命令来安装部署工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><p>然后修改 <strong>_config.yml</strong> 的末尾</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div><p>最后运行 <span class="bg-grey">hexo d</span> 即可将网页push到GitHub上，大功告成！访问 https:&#x2F;&#x2F;用户名.github.io 就可以看到自己的博客了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo官方网站有不少主题可供使用 <a class="link"   href="https://hexo.io/themes/" >Hexo 主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，挑选一个心仪的主题并进行下载。</p><p>本博客使用的主题是 <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，用该主题介绍如何进行安装。</p><p>事先根据提供的文档进行安装，一般都提供git clone的方式，还有npm安装的方式：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br><span class="line">npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div><p>安装完毕后，修改 <strong>_config.yml</strong> ：</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div><p>最后一般都要在Hexo程序根目录下新建一个主题的配置文件，例如 <strong>_config.redefine.yml</strong>， 具体的根据官方文档进行。</p><p>完美！接下来重新启动服务器查看有多么炸裂吧。</p><h3 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h3><p>如果使用的主题是 Redefine，已经集成了不少有用的插件，在此不再赘述，可以参考 <a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行相关配置，此处推荐的是额外的插件，如果有需要也可以自己去 <a class="link"   href="https://hexo.io/plugins/" >Hexo 插件广场 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 挑选，甚至可以自己开发一个。</p><h4 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h4><p>生成站点地图，利于SEO，地址：<a href="hexo-generator-sitemap">hexo-generator-sitemap</a></p><h4 id="hexo-simple-image"><a href="#hexo-simple-image" class="headerlink" title="hexo-simple-image"></a>hexo-simple-image</h4><p>新建文章时自动在相同路径下生成存放图片的文件夹，使得文章引用图片方便不少，地址：<a class="link"   href="https://github.com/ZaiZheTingDun/hexo-simple-image" >hexo-simple-image <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>使用时可以直接像下面这样：</p><div class="highlight-container" data-rel="Md"><figure class="iseeu highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{% asset_img "span>" '"" "<span class="string">my post image</span>"' %}</span><br><span class="line">或者</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./new_post.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span>   &lt;!-- 注意img的话不需要加文件夹名字，因为生成时会自动合并 --&gt;</span><br></pre></td></tr></table></figure></div><h4 id="hexo-tag-mdline"><a href="#hexo-tag-mdline" class="headerlink" title="hexo-tag-mdline"></a>hexo-tag-mdline</h4><p>生成时间线，地址：<a class="link"   href="https://github.com/wangwei1237/hexo-tag-mdline" >hexo-tag-mdline <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="hexo-tag-bilibili"><a href="#hexo-tag-bilibili" class="headerlink" title="hexo-tag-bilibili"></a>hexo-tag-bilibili</h4><p>生成哔哩哔哩视频卡片，地址：<a class="link"   href="https://github.com/Z4Tech/hexo-tag-bilibili" >hexo-tag-bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>建议将url修改为不进行自动播放和默认静音，修改 node_modules\bilibili-embed-convert\index.js，将标出的位置进行修改：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./bilibili_url.png"                      width="700px" height="auto" alt="修改哔哩哔哩url"                ><figcaption>修改哔哩哔哩url</figcaption></figure>]]></content>
    
    
    <summary type="html">Hexo简要配置指南</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="配置" scheme="https://yhxjs.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Hexo" scheme="https://yhxjs.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>重构</title>
    <link href="https://yhxjs.github.io/2023/11/06/%E9%87%8D%E6%9E%84/"/>
    <id>https://yhxjs.github.io/2023/11/06/%E9%87%8D%E6%9E%84/</id>
    <published>2023-11-06T12:37:09.000Z</published>
    <updated>2024-03-26T12:40:37.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重构，即对程序内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构以增加程序的可维护性、可靠性，这是门学问，这与古老的谚语“程序能跑就不要动它”背道而驰，这句谚语也是屎山如何形成的最根本原因，没有定期地重构不合理的代码，使得埋下的坑越来越深，解bug就像探宝一样，时不时能发现其他宝藏：更难解的bug，这就是为什么bug越解越多。当然，重构总是与bug如影随形，这就要求以最小的步伐来进行重构，每一次重构完成时要进行详尽的测试，最好是提供统一稳定的测试环境，按照相同的方法进行测试，以免重构引入bug。</p><p>重复的代码块IDE会进行提醒，如果有两个及以上重复就可以考虑抽象出一个函数了，这样当这块代码出错，就无需修改每处地方，仅需修改那个函数，这就是重构，其实我们每天都在进行重构，提炼、分析，从而选出最适合的数据结构，或者逻辑顺序。重构有许多种方法，其中按照既有模版进行重构是最简单的，因此了解设计模式以及类似的思想是很有必要的，可以减少编写代码出错的概率。重构就像是在梳理代码，只有理解了具体的逻辑，重构才成为可能，这就是代码可理解性的重要性，难以理解的设计非常不利于重构，因此，代码可读性优先于其他要义（如果不考虑性能的情况下，如果要进行性能优化，可能就会摒弃可读性，这是没办法的，不过也可以增加适当的注解来提高可读性，不要让别人揣测你代码的意思，而是浅显易懂，这才是好的设计）。讲个笑话，当有天回过头来看之前写的代码，会看不懂，惊呼一句卧槽这啥*玩意，那么就需要进行重构了，如果当初代码的作者都看不明白了，那么指望别人能快速理解代码意图是不太可能了。</p><h2 id="设计大于编码"><a href="#设计大于编码" class="headerlink" title="设计大于编码"></a>设计大于编码</h2><p>良好的设计才是快速开发的秘诀，恶劣的设计会使得开发大半的时间都花在不断重复地调试当中，因为程序状况百出，不得不每每打断开发的进度，甚至因为修复bug而打上的补丁会影响后续的开发，使代码愈来愈臃肿，这是我们不希望看见的，因此，我再次强调设计思想的重要性，这是重构的前提。</p><p>事先做好设计可以有效减少返工次数，即进行重构的次数，甚至无需进行重构，就能完美符合需求且代码结构清晰，维护容易，当然，不要过度设计，过于揣测之后的变化是不利于开发的，应该能够在满足需求的情况下，然后一定限度地对风险进行预测，考虑增加容错，而不是一上来就“疑神疑鬼”。掌握设计和编码难度的平衡性也是挺困难的，设计为需求而服务，但满足需求并不一定能够实际落地，需要切实考虑编码难度、时间花费、风险控制等等因素，而不是盲目地追求所谓好的设计。在设计前请务必理清需求和度量系统，不要臆测，想当然地以为那样就是那样，需要不断沟通以完善设计。</p><h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h3><p>这是再正常不过的坏味道了，当一段代码在多处出现，那就要考虑是否需要进行重构了，提炼出重复代码，然后封装到一个函数中，这样出问题只需改一处即可，而不是牵一发而动全身。</p><h3 id="过长函数"><a href="#过长函数" class="headerlink" title="过长函数"></a>过长函数</h3><p>当一个函数过长，就要注意了，函数越长，逻辑就越难理清，也就越难维护，所谓屎山就是堆砌起来的，当一段冗长的代码摆在面前，且没有相应注释，我想是个人都会抗拒去阅读它，将这类代码分割成一小块一小块，每一块都是单独的一段逻辑，然后再串联起来，这样不仅能减少临时变量，且还能让逻辑变得清晰明了，最重要的是，复用性大大增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;重构，即对程序内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构以增加程序的可维护性、可靠性，这</summary>
      
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="重构" scheme="https://yhxjs.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://yhxjs.github.io/2023/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yhxjs.github.io/2023/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-01T15:05:40.000Z</published>
    <updated>2024-03-26T12:36:05.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式提供了一套在特定问题场景下解决软件设计问题的标准化解决方案，能够帮助开发者避免重复造轮子，提高代码的可复用性、可维护性和可扩展性，并且能够使开发过程更加高效、有条理。</p><p>在介绍之前先了解下三个原则：单一职责原则、开放-封闭原则和依赖倒转原则。</p><blockquote><p>单一职责原则</p><p>如字面意思所示，对于一个类来说最好只有一个引起它变化的原因。如果一个类承担的职责过多，就相当于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。如果根据职责进行划分，即根据功能进行细化，后续的改动甚至是移植都会变得容易许多，可维护性大大提升，而不是一堆shit mountain摆在面前，不知道从何入手。当然，无需过度细分，实际上，在开发中一般是以功能模块进行划分，而模块内部的各个细节再进行具体划分，做到粗中有细。</p></blockquote><blockquote><p>开放-封闭原则</p><p>如字面意思所示，可以进行扩展，但不能进行修改。此处的不能修改并不绝对，而是需要开发者事先预知可能的变化，将这种变化进行抽象，从而实现隔离变化，当发生变化时，只需要增加新代码，而不是修改现有代码。当然，仅需要对频繁做出改变的部分进行抽象，而不是事无巨细，反而会导致过度修改。</p></blockquote><blockquote><p>依赖倒转原则</p><p>首先先了解里氏代换原则，即一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换为它的子类，程序的行为并未发生变化，简单来说，就是子类型必须能够替换掉它们的父类型。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象，即针对接口编程，不要对实现编程，高层模块不应该依赖低层模块，两个都应该依赖抽象。由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是这三类设计模式的简要概述：</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这类模式主要关注对象的创建方式，使系统独立于对象的创建、组合和表示方式。常见的创建型模式包括：</p><h4 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h4><p>即确保一个类仅存在单个实例，并为该实例提供访问方法，当多线程时，需要提供锁来保证单实例。</p><p>单例模式分为饿汉式和懒汉式，饿汉式即一开始就创建实例，而懒汉式则是用到时才构建实例。</p><h4 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h4><p>即用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实际上就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建的细节，将对象初始化为被克隆的对象，然后再根据需要修改部分属性，而不需要从头开始初始化。</p><blockquote><p>此处克隆分为浅拷贝和深拷贝，这是一个老生常谈的问题，浅拷贝只是引用传递，即拷贝对象只将对象的引用进行拷贝，而真正的数据并有拷贝，即数据只有一份，只要一个地方进行了修改，其他拷贝的地方也会跟着产生变化，如果不想这样，就需要值传递，实现深拷贝方法，重新创建一个跟被拷贝对象一样数据的对象，曾经在写Vue的时候遇到这个坑，直接用等于号赋值，结果临时变量的改变也导致了原本变量的改变，从而导致模版重新渲染，这里就不展开说了，感兴趣的可以搜搜看。对于Java、C#等等面向对象语言来说，都会提供一个Cloneable类，只需要继承该类即可调用clone方法来复制实例，不过此处的clone方法是浅拷贝，如果需要深拷贝，可以进行重写。</p></blockquote><h4 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h4><p>首先需要了解简单工厂模式，即运用多态，在构造时，构造工厂根据某个属性创建对应的类，这些类都继承于某个抽象类，实现某个公有方法，从而只需要调用该方法即可，不用关心方法是如何实现，当需要变动时，只需要改变对应类的实现，而不用关心其他类的实现。</p><p>工厂方法模式将简单工厂模式进一步抽象，把工厂也分为一个个具体的工厂，将原先在工厂内判断的逻辑移动到外部，进一步加强了开放-封闭原则。定义了一个创建对象的接口，让子类决定实例化哪个类。</p><h4 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h4><p>创建一系列相关或相互依赖的对象，而无需指定它们具体的类。常常和依赖注入和反射相结合，根据传入的依赖创建不同的实例，从而调用不同的方法，例如数据库连接池druid，它并不感知具体的数据库类型，不论是MySQL还是oracle，都有一套标准，即连接器，只需要方法一致即可。</p><h4 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h4><p>即将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>将构建流程标准化形成一个抽象类建造者，其中包含各个步骤，然后再去继承这个抽象类，然后必须实现其中的所有方法，因此不会有遗漏，而再抽象出一个流程类指挥者，传入建造者，调用各个步骤，从而形成具体的流程。部分定制化可以概括这个模式的特点，流程是定死的，但是步骤可定制化，经过不同的步骤，最后呈现的结果也是不同的，但万变不离其宗。</p><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这类模式主要涉及到类和对象的组合，用于构建大型的对象结构，帮助确保系统的灵活性和高效性。常见的结构型模式包括：</p><h4 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h4><p>即将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>适配器模式主要应用于希望复用一些现存的类，但是又与复用环境要求不一致的情况，字面意思，可以联想到电源适配器，将市电转化为直流电，供设备运行，一样的思想，适配，适配，适应配置，当存在复杂且繁杂的代码时，无法对其进行重构，或者重构成本过于昂贵，这时就可以运用适配器模式进行相应的适配，当然，还有第三方接口和自己的接口不匹配，此时也需要进行适配。</p><h4 id="装饰者（Decorator）"><a href="#装饰者（Decorator）" class="headerlink" title="装饰者（Decorator）"></a>装饰者（Decorator）</h4><p>即将所需的功能按正确的顺序串联起来控制，动态地给一个对象添加一些额外的职责。</p><p>可以理解为一种另类的递归，装饰对象的被装饰物其实还是其他对象的装饰对象，每次先执行之前“装饰”的方法，再执行自己的方法，串成一串，这样就实现了可装配的增强功能，当需要时，可按需进行串联，例如事先的数据校验，增加新的字段，新的逻辑等等。注意，装饰的顺序是很重要的，例如数据校验、加密，不能等到业务处理结束后才进行。装饰模式可以有效地将核心功能和装饰功能分离开来，按照需要进行必要的增强，而不修改核心功能。</p><h4 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h4><p>即为其他对象提供一种代理以控制这个对象的访问。</p><p>如果有部署过Nginx的应该不陌生，代理服务器，即将收到的请求发送到另一个服务器，收到应答后再将该应答返回，相当于多了一个代理人的概念，当然在传递期间可以做一些额外的事，甚至经过处理而不用继续传递直接返回，一般来说，代理能处理的事，就不用劳烦被请求的对象了。</p><h4 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h4><p>即为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加易用。</p><p>在设计初期阶段，应该有意识的定义不同的层，每个层都有不同的职责，然后层与层之间通过接口访问，使得耦合大大降低，例如网络的TCPIP模型，再比如后端的数据访问层、业务逻辑层、表示层等等，各司其职，对外提供一组接口供其他层调用，只需要知道这个接口是干啥的，而无需过分关注其中的实现，只要功能没变，调用该接口的地方就无需变动。</p><h4 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h4><p>即将抽象部分与它的实现部分分离，使它们都可以单独地变化，简单来说，就是将类的功能层次结构和类的实现层次结构连接起来。</p><p>就像系统和软件之间存在的关系，软件在不同的系统中实现有所不同，但是功能是一样的，即仅需定义好功能，然后调用实现即可，功能侧无需关心具体实现。</p><p>想要新增功能时，只需在功能侧添加功能类，不必对实现侧进行修改，增加后的功能能被所有实现使用。</p><h4 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h4><p>即将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p>文件树、窗口视图、权限管理等等，都可以采用组合模式，即可以进行嵌套，当然需要注意有没有嵌套自身，不然就会无限递归下去。</p><h4 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h4><p>即运用共享技术有效地支持大量细粒度的对象。</p><p>例如字符串常量就可以理解为是享元，相同的字符串常量实际上是在同一块内存，还有线程池、数据库连接池，其实也是享元，只不过是事先建立多个线程或者连接，然后共享，本质是一样的，C语言的文件描述符也是如此，可以事先进行创建，还能节省时间，因为创建比较耗费时间。</p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这类模式专注于对象之间的通信，用于增强对象之间的协作和职责分配。常见的行为型模式包括：</p><h4 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h4><p>即将策略（算法）从单个类剥离出来，定义一个父类，然后分成不同的类继承该父类，这些类都实现对某个问题的处理方法，这样只需要在需要构造的类（上下文）中传入需要的策略，即可调用处理方法，而无需关注内部如何实现。</p><p>策略类只需要实现必要的接口，具体的策略类需要实现策略类中定义的接口，而上下文类负责使用策略类，用多态传入不同的具体的策略类。</p><p>策略模式有效地将算法和实际应用剥离开来，后续如果要新增策略或者修改策略对应的算法时，只需要对相应的部分进行新增或者修改即可，相当于是委托，是一种弱关联关系，可以很方便地进行替换。</p><p>策略模式可以和简单工厂模式相结合，上下文构造时传入的可以是某个属性，再将该属性映射到具体的类。不同模式是可以进行嵌套的，最终境界就是看似没有应用模式，实际都是模式，不需要刻意使用，即化有形为无形。</p><h4 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h4><p>又叫发布-订阅模式，即让多个观察者订阅某一个对象，当这个对象状态发生变化时，会通知所有观察者对象执行相应的动作。</p><p>消息队列就是经典的观察者模式，以及基于事件驱动的websocket，都是根据“状态”变化来触发对应动作，也就是回调，并不关心是谁触发的，而是关注什么事件被触发了。</p><h4 id="责任链（Chain-of-Responsibility）"><a href="#责任链（Chain-of-Responsibility）" class="headerlink" title="责任链（Chain of Responsibility）"></a>责任链（Chain of Responsibility）</h4><p>即使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>相当于踢皮球一样，先看看自身能不能处理，不能就踢给下一个人，以此类推，直到有人进行处理，当然，最后必须保证能处理，不然就没有意义了，就像现实中无意义的互相甩锅（手动狗头</p><h4 id="命令（Command）"><a href="#命令（Command）" class="headerlink" title="命令（Command）"></a>命令（Command）</h4><p>即将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>可以理解为事件驱动，事件触发时将要做的操作加入队列中，或者将操作从队列中删除，当收到执行事件时，将队列中的操作一一执行。</p><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>即用状态决定对象的行为。</p><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，用类表示状态，将冗长的判断切分为一个个状态，分而治之，可以将状态迁移交给各个状态，由自己判断什么时候迁移状态，也可以在外部进行迁移，通过有限状态机可以更好地理解各个状态之间的关系。</p><h4 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h4><p>即将数据结构和处理分离开来，使得可以不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>该模式适用于数据结构相对稳定的系统，这就使得它的优缺点都十分明显，优点就是操作解耦，增加新操作无需修改先前的代码，而缺点就是一旦数据结构变化，需要修改的地方就会分散到各个角落里，难以维护，因此只适用于稳定的数据结构。</p><h4 id="中介者（Mediator）"><a href="#中介者（Mediator）" class="headerlink" title="中介者（Mediator）"></a>中介者（Mediator）</h4><p>即用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>相当于由一个路由器决定请求该发往哪里，在web应用中可以用Redis解决跨域问题，不同的网站请求同一个Redis即可，存的cookie可以很容易共享，跟发布&#x2F;订阅模式很像。</p><h4 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h4><p>即将对象的状态保存起来，需要时可以进行恢复，就像游戏中的存档和读档。</p><p>可以藉由该模式实现状态恢复、状态暂存，甚至还能覆盖保存的状态，可以将状态保存到Redis里，需要时进行取用，可以实现二阶段提交等功能。</p><h4 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h4><p>即提供一种方式顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式实际已经加入语言实现当中，iterator即迭代器，使用该元素即可对集合进行遍历然后进行相同的操作。</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><a class="link"   href="https://baike.baidu.com/item/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7427270" >《Head First设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262" >《大话设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>强烈推荐！！！以浅显易懂地方式介绍了各个模式，建议先阅读，挺有趣的</p><p><a class="link"   href="https://baike.baidu.com/item/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22699708" >《图解设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>具体案例可以看这本，加深理解</p><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>技术是在总结和否定中不断发展，设计模式就是总结前人惯用的一些思维模式，抽象出来具体的方法，让后来者可以借鉴，领略其中的精妙之处，但23个设计模式并不足以概括此前贡献者的智慧，在我看来，只是冰山一角，更多的奥妙，还需要在接下来的编码生涯中慢慢体会，仔细品味。</p><p>不同的语言之间存在实现上的差异，但是处处可见设计模式的身影，这说明了设计模式的技巧被广泛运用，其实这是个先有鸡还是先有蛋的问题，是先有所谓的设计模式，还是先有的技巧，我觉得并不重要，重要的是如何运用所谓的设计模式，要融会贯通，而不仅仅是套用，虽然套用可以省去一些无谓的开销，但是结合具体场景需要对模版进行改进以适应需求。有的时候，套用模版并不是一件好事，这样容易将简单的事情复杂化，个人觉得，需要设计模式的时候，那么这个功能一定是繁杂的，不容易理清的，才需要设计模式的协助，减少出错的概率，就像C语言，并不是面向对象的语言，但是这并不影响面向对象思想的运用，这就要问问神奇的宏了，可以实现多态，进而实现各个设计模式，让我不由得感叹前人的智慧，精妙！</p><p>集设计模式为大成的MVC模式，即模型-视图-控制器，最近貌似被DDD模式给创飞了，即领域驱动设计，我对于DDD的了解甚少，在前不久才知道有这么个模式，不过貌似这两个模式可以并存，DDD模式实际上是一种思想。</p><p>MVC是一种常见的软件架构模式，用于组织和分离应用程序的逻辑层、表示层和用户交互层。模型负责表示和处理数据，视图负责显示用户界面，控制器负责处理用户交互和调度逻辑。MVC的核心目标是将应用程序的不同功能和职责解耦，使得各个组件可以独立变化，并且提高了应用程序的可维护性和可扩展性。</p><p>DDD是一种面向复杂业务领域的软件设计方法，它将关注点放在领域模型的设计和开发上，强调领域专家和开发团队的紧密合作，以达到更好的业务理解和设计实现。它提倡通过领域模型来反映业务需求，将业务逻辑和业务概念抽象为领域对象、值对象、聚合等概念，通过领域模型来实现业务规则和业务流程的核心逻辑。它的核心思想包括战略设计和和战术设计，其中战略设计关注领域模型的整体结构和组织，战术设计则关注具体领域对象和业务逻辑的实现。</p><p>二者都是软件开发中的设计模式和思想，它们的目标都是提高软件系统的可维护性、可扩展性和可理解性。二者可以结合使用，DDD的领域模型可以作为MVC模型中的模型部分，MVC模式提供了一种良好的架构和开发模式来组织和展现DDD的领域模型。</p>]]></content>
    
    
    <summary type="html">设计模式是一种在特定情境下解决特定问题的方法论。</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="设计模式" scheme="https://yhxjs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>小丑</title>
    <link href="https://yhxjs.github.io/2021/08/16/%E5%B0%8F%E4%B8%91/"/>
    <id>https://yhxjs.github.io/2021/08/16/%E5%B0%8F%E4%B8%91/</id>
    <published>2021-08-16T08:59:10.000Z</published>
    <updated>2024-03-25T15:07:18.100Z</updated>
    
    <content type="html"><![CDATA[<p>破碎的天空沉入海底，泛起阵阵涟漪，<br>孤独的太阳浮出海面，映着波光粼粼。</p><p>黑白的人间恶鬼游荡，<br>没有镜子，<br>看不清笑容背后，<br>阳光黯淡，<br>照不亮眼泪，<br>火炬已灭，<br>想不起。</p><p>哀嚎着，<br>究竟是人是鬼？</p><p style="text-align:right;">写于2021-8-16</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./joker.jpg"                      width="500px" height="auto" alt="小丑"                ><figcaption>小丑</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;破碎的天空沉入海底，泛起阵阵涟漪，&lt;br&gt;孤独的太阳浮出海面，映着波光粼粼。&lt;/p&gt;
&lt;p&gt;黑白的人间恶鬼游荡，&lt;br&gt;没有镜子，&lt;br&gt;看不清笑容背后，&lt;br&gt;阳光黯淡，&lt;br&gt;照不亮眼泪，&lt;br&gt;火炬已灭，&lt;br&gt;想不起。&lt;/p&gt;
&lt;p&gt;哀嚎着，&lt;br&gt;究竟是人是鬼？&lt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>致百日誓师的我</title>
    <link href="https://yhxjs.github.io/2018/09/16/%E8%87%B4%E7%99%BE%E6%97%A5%E8%AA%93%E5%B8%88%E7%9A%84%E6%88%91/"/>
    <id>https://yhxjs.github.io/2018/09/16/%E8%87%B4%E7%99%BE%E6%97%A5%E8%AA%93%E5%B8%88%E7%9A%84%E6%88%91/</id>
    <published>2018-09-16T11:25:45.000Z</published>
    <updated>2024-03-25T15:05:46.378Z</updated>
    
    <content type="html"><![CDATA[<p>当我审视自己，我看到了无数个视角下不同的我，为了他人目光活着，有点累，而我却看不清真实的自己到底是哪个，还是说，我早已不是当初的那个我，我曾以为我便是我，一个自由放纵的我，可现实却击中了我，把我击倒在地，我强忍着伤痛，匍匐前进，前方始终是黑暗，我心逐渐绝望，终于，我看清了，我就是我，一个独一无二的我，也许他人目光将我弄得遍体鳞伤，但我终究是我，随自己的心意而活，可是，真的吗？我不禁陷入了深思，我真的能吗？我想这是不可能的，生活本就是一个囚笼，你无法打破它，只能去学会接受它，去改造它，让它变得更加美好，哪怕再不堪，也要好好的，没有人能真正按照自己心意而活，生活本就是如此，面对他人的目光，不要去逃避，不然你终将会被其击倒在地，我挣扎着爬起来，哪怕前方没有光亮，我也要用我这心，去照亮前方，只为那当初的我，于是，我便不断前行，披荆斩棘。</p><p>我知道你内心挣扎，并全力克制着疑惑，我理解你每次每次哭泣时的痛苦与无奈，但我早已没了眼泪，被生活磨去了棱角，你本能再坚强一点的，把握明天将给予的一切，但是等待我们的往往是狂风骤雨，不要害怕，去感受它，敞开心胸，让它来吧，学会接受恐惧给你带来的感受，是那么黑暗，那么纯粹，而带来恐惧的正是你的心，不要抵触，让它成为你的一部分，让它驱使你前进，哪怕跟当初的我一样，你也要前行，因为你一旦停止了脚步，你将迷失在这黑暗之中，陷入深潭，恐惧将会吞噬你，所以，接受它吧，没有人能真正按照自己的心意而活，我也不例外，如今我已完全醒悟，过去那些将我击倒的，逐渐使我升华，所以，请不要灰心，相信明天将会是美好的，哪怕狂风骤雨，但你也不怕了，不是吗？勇敢的去面对它，我知道，真正的敌人就在我内心深处，那里是恐惧本源，我须战胜自我，去降服他，可是，我的双手早已无力，我的内心早已千疮百孔，我已无心战斗，但我的灵魂不允许我松懈，于是，我便不断前行，披荆斩棘。</p><p>那么，便努力吧，努力做自己，去冲。</p><p style="text-align:right;">——致百日誓师的我</p><p style="text-align:right;">写于2018-9-16</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我审视自己，我看到了无数个视角下不同的我，为了他人目光活着，有点累，而我却看不清真实的自己到底是哪个，还是说，我早已不是当初的那个我，我曾以为我便是我，一个自由放纵的我，可现实却击中了我，把我击倒在地，我强忍着伤痛，匍匐前进，前方始终是黑暗，我心逐渐绝望，终于，我看清了，</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>我</title>
    <link href="https://yhxjs.github.io/2018/05/06/%E6%88%91/"/>
    <id>https://yhxjs.github.io/2018/05/06/%E6%88%91/</id>
    <published>2018-05-06T13:23:22.000Z</published>
    <updated>2024-03-25T15:05:38.270Z</updated>
    
    <content type="html"><![CDATA[<p>飘浮着<br>流荡着<br>望着远方的夕阳<br>我知道你已逝去</p><p>踌躇着<br>漫步着<br>听着身旁的乐声<br>我知道你已归来</p><p>也许<br>来来往往<br>你已老去</p><p>但是<br>往复之间<br>越发真切</p><p>我知道<br>你<br>一直在追逐<br>追逐那心中念想</p><p>我知道<br>你<br>一直在幻想<br>幻想那世间美好</p><p>我也知道<br>你<br>曾多少次暗自神伤</p><p>我亦知道<br>你<br>曾多少次触景生情</p><p>因为<br>我知道<br>我便是你</p><p style="text-align:right;">写于2018-5-6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;飘浮着&lt;br&gt;流荡着&lt;br&gt;望着远方的夕阳&lt;br&gt;我知道你已逝去&lt;/p&gt;
&lt;p&gt;踌躇着&lt;br&gt;漫步着&lt;br&gt;听着身旁的乐声&lt;br&gt;我知道你已归来&lt;/p&gt;
&lt;p&gt;也许&lt;br&gt;来来往往&lt;br&gt;你已老去&lt;/p&gt;
&lt;p&gt;但是&lt;br&gt;往复之间&lt;br&gt;越发真切&lt;/p&gt;
&lt;p&gt;我知道&lt;b</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>呐喊</title>
    <link href="https://yhxjs.github.io/2016/10/30/%E5%91%90%E5%96%8A/"/>
    <id>https://yhxjs.github.io/2016/10/30/%E5%91%90%E5%96%8A/</id>
    <published>2016-10-30T13:29:05.000Z</published>
    <updated>2024-03-25T15:05:00.529Z</updated>
    
    <content type="html"><![CDATA[<p>回想过去，多么怀念曾经的美好时光，但却早已只剩下那渐行渐远的一个个瞬间仍然徘徊，转瞬即逝。深入骨髓的孤独感慢慢侵蚀着我，迷失在人海中，与自己的影子为伍，不时躲闪来往的行人，我只想躲到阴暗的角落，回想过去的点点滴滴，仅此而已，但外在虚伪的皮囊早已机械麻木，与这繁华世界格格不入。此刻，我只想呐喊。<br>内心的苦楚遍布在每一个角落，想呐喊，却不行，就像一个异类，不被人所正视，即便有，那也是不长久的，顷刻间，可能往昔的情分早已烟消云散，不复存在，只剩下那充斥着虚伪笑容的脸仍留在脑中，久久挥之不去，仿佛在讥讽，嘲笑，我想这是不能呐喊的原因吧，因为它无时无刻不在压抑你，让你无法置身事外，世间种种皆是如此，想要逃离这一切，却发现自己早已被捆绑住了，无法挣脱，甚至无法发声，身边的人诧异地看着你，你的那些看似有些另类的行为不被人所接受，因为人们习惯于司空见惯，而当一些不正常的东西出现的时候，他们会质疑它，甚至去摧残它。</p><p>呐喊，我只想呐喊，在广袤无垠的田野中肆意呐喊，在这里，没有人去讥讽、嘲笑你，似乎很畅意，但我不能，虽然世间的种种把我压得喘不过气来，但在这一片黑暗中还有零星的灯火——真正爱你的人，回到他们的身边，种种不安、惶恐都消失了，尽管只有一段段短暂的时间，但内心却是如此光明。也许将来你们会离开我的身边，但我还是会挺住这苦楚的肆虐，在这万象丛生的世界活下去，去为了寻找一个能够陪伴我走下去的挚爱。</p><p>在这之前，我只想呐喊，当我渐渐长大，亦或是变老，头发渐渐苍白，如今炽热的心也许会随之降温，但我仍有信念，仍有为之一生的目标，这便足够了。哪怕世人无法理解，但我保持自我，我还是我，放纵着我，在这世界中茫茫一点，不奢求改变什么，但求初心不变，这便足够了。</p><p>在这世界，有许多不公平，但这往往是表象，许多人想逃离这种不公平的现象，转而追求那些看似公平的选择，这本没有错，但这些人为了公平，将不公平强加于他人，只为了一时的利益，并不能说人心险恶，这只是人们为了自我保护和那万恶的欲望作的祟，这可能会毁了一个人的一生，但人们却不管不顾，仍旧如此，只有当其波及家人或自我的时候，这才会看清本质，停止那愚蠢的行为，但有些人仍旧被蒙蔽，做出无法挽回的事，这充斥在人世间，几乎每时每刻都在发生，我厌倦了这种选择和拒绝的过程，而结果也不再那么重要了，无非是为了欲望，还有那可笑的自我保护，所以，我只想呐喊。</p><p>生活中的某些事物会将我们置之于一处险地，在这里，只有你自己，周围黑漆漆的一片，这强烈的压抑感会使人喘不过气，但又不得不去面对它，独自地，将它打败，你才能走出去，这时，你的心境会变得更加强韧，但往往会有许多事物会影响你的心智，妨碍甚至阻止你做出关键的选择，如果你放弃了，那么你将沦为它的奴隶，自此难以自拔，只能任由它侵蚀你，肆虐你，直到你的最后一道防线被攻破，那么，你早已不是你，你将会被改变，变得麻木，没有丝毫情感，一切都将无法阻止你的决定，你的选择，你的一切，因为你已不是人，只是机械动物，我怕，会成为这样的存在，所以，我只想呐喊。</p><p>啊——这一切究竟是为了什么？也许究其一生都不会知道，只能默默、平凡地活着，让尸骨腐烂在地底，让世界遗忘我曾经存在过，而这一切，都将成为消失那一点。</p><p>我真的只想呐喊。</p><p style="text-align:right;">写于2016-10-30</p><p align="right" style="text-align:right;text-indent:32.0pt"><span style="font-size:16.0pt;font-family:楷体;color:#215868">蚝油<span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回想过去，多么怀念曾经的美好时光，但却早已只剩下那渐行渐远的一个个瞬间仍然徘徊，转瞬即逝。深入骨髓的孤独感慢慢侵蚀着我，迷失在人海中，与自己的影子为伍，不时躲闪来往的行人，我只想躲到阴暗的角落，回想过去的点点滴滴，仅此而已，但外在虚伪的皮囊早已机械麻木，与这繁华世界格格不入</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>等着</title>
    <link href="https://yhxjs.github.io/2016/09/25/%E7%AD%89%E7%9D%80/"/>
    <id>https://yhxjs.github.io/2016/09/25/%E7%AD%89%E7%9D%80/</id>
    <published>2016-09-24T18:55:34.000Z</published>
    <updated>2024-03-25T15:05:31.498Z</updated>
    
    <content type="html"><![CDATA[<p>等<br>一盏明灯<br>照亮我的内心，<br>这样也许<br>就不会如此孤独。</p><p>一切由自己面对，<br>哭过笑过，<br>都是独自承受。</p><p>他人的眼光，<br>装作无所谓；<br>装作若无其事。<br>其实内心<br>早已千疮百孔。</p><p>默默的，<br>多么希望<br>有人能分担一些，<br>但没有。</p><p>这也许就是我。<br>也许放弃<br>向往自由，<br>但是被孤独<br>所囚禁了，<br>无法挣脱。<br>默默的。</p><p>这也许就是我——至喜欢独自承受的自己（永远）</p><p style="text-align:right;">写于2016-09-25</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./whalefall.jpg"                      width="500px" height="auto" alt="鲸落"                ><figcaption>鲸落</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;等&lt;br&gt;一盏明灯&lt;br&gt;照亮我的内心，&lt;br&gt;这样也许&lt;br&gt;就不会如此孤独。&lt;/p&gt;
&lt;p&gt;一切由自己面对，&lt;br&gt;哭过笑过，&lt;br&gt;都是独自承受。&lt;/p&gt;
&lt;p&gt;他人的眼光，&lt;br&gt;装作无所谓；&lt;br&gt;装作若无其事。&lt;br&gt;其实内心&lt;br&gt;早已千疮百孔。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>也许那么...</title>
    <link href="https://yhxjs.github.io/2016/09/25/%E4%B9%9F%E8%AE%B8%E9%82%A3%E4%B9%88/"/>
    <id>https://yhxjs.github.io/2016/09/25/%E4%B9%9F%E8%AE%B8%E9%82%A3%E4%B9%88/</id>
    <published>2016-09-24T18:53:42.000Z</published>
    <updated>2024-03-25T15:04:11.151Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./time.jpg"                      width="400px" height="auto" alt="时光里"                ><figcaption>时光里</figcaption></figure><p>那么<br>曾经喜欢过，<br>也许<br>现在还喜欢，<br>但是<br>早已过去。</p><p>曾经铭记于心，<br>现在隐藏内心。<br>包裹着<br>一层又一层的皮囊；<br>感受着<br>一次又一次的煎熬；<br>回想着<br>过去的点点滴滴；<br>不禁<br>心有感悟。</p><p>过去的人和事，<br>如若还在身边，<br>那么这形同陌路，<br>却不如不见。<br>可不见，<br>却又倍加思念，<br>不知该何去何从，<br>便只能做好如今的事。</p><p>那么不如待我如初见——至逝去的三年（初中）</p><p style="text-align:right;">写于2016-09-25</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;image-caption&quot;&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>把握</title>
    <link href="https://yhxjs.github.io/2016/05/14/%E6%8A%8A%E6%8F%A1/"/>
    <id>https://yhxjs.github.io/2016/05/14/%E6%8A%8A%E6%8F%A1/</id>
    <published>2016-05-14T05:51:55.000Z</published>
    <updated>2024-03-25T15:06:06.685Z</updated>
    
    <content type="html"><![CDATA[<p>曾经放眼望去，时间就在那里，现在却找不着它了，只怪我没有好好珍惜，等一切都变了，再来追悔莫及，一切都晚了，时间从手间划过，留下一道道触目惊心的伤痕，也许时间会慢慢抚平，但当那时，心早已崩塌，化作一朵凋零的花蕊，珍惜时间吧，时间也许就在那里，找到它，紧握，不要让它再消失了，让我们把握当下吧，也许酸甜苦辣，也许会受伤，也许有那么一份保留的纯真，也许还有那内心深处的感触，去感受它们其中蕴含的真理，那么你的一生将由此改变，也许变得沧桑，也许变得开朗，也许什么都不会变，变的只是你的外表，而不是自己的本心，不忘初心，方得始终，虽然人终有一死，但死得其所，才是最重要的，而当初那些觉得重要的，却早已不重要了，记住，有时候忘记是最好的选择，而忘不掉的，往往是那些你爱的，深爱的，或者是恨的，而这些都将影响你的内心，因此你要控制住它，不让它侵蚀你的内心，保持着最初的那一份念想。</p><p style="text-align:right;">写于2016-5-14</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./elapse.jpg"                      width="400px" height="auto" alt="流逝"                ><figcaption>流逝</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;曾经放眼望去，时间就在那里，现在却找不着它了，只怪我没有好好珍惜，等一切都变了，再来追悔莫及，一切都晚了，时间从手间划过，留下一道道触目惊心的伤痕，也许时间会慢慢抚平，但当那时，心早已崩塌，化作一朵凋零的花蕊，珍惜时间吧，时间也许就在那里，找到它，紧握，不要让它再消失了，让</summary>
      
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
