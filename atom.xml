<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yhxjs的博客</title>
  
  
  <link href="https://yhxjs.github.io/atom.xml" rel="self"/>
  
  <link href="https://yhxjs.github.io/"/>
  <updated>2024-11-01T14:44:30.485Z</updated>
  <id>https://yhxjs.github.io/</id>
  
  <author>
    <name>yhxjs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于上云故障转移方案</title>
    <link href="https://yhxjs.github.io/2024/11/01/%E5%85%B3%E4%BA%8E%E4%B8%8A%E4%BA%91%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%96%B9%E6%A1%88/"/>
    <id>https://yhxjs.github.io/2024/11/01/%E5%85%B3%E4%BA%8E%E4%B8%8A%E4%BA%91%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%96%B9%E6%A1%88/</id>
    <published>2024-11-01T14:39:19.000Z</published>
    <updated>2024-11-01T14:44:30.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上云"><a href="#上云" class="headerlink" title="上云"></a>上云</h2><p>现代服务部署解决方案基本都为云部署，尤其是较大规模的应用，部署服务的方式一般有自建机房、IDC托管、云服务厂商，现如今以阿里云、腾讯云、华为云等为首的云服务厂商的份额日益增加，得益于上云后带来的最大好处——方便运维，变相提高了应用的可靠性，因为相较于部署在自建机房和IDC托管，云服务厂商会提供更加成熟的部署方案，不仅包括简单的部署，包括域名解析、数据备份、容灾等一系列完善的服务，使得服务部署不再困难，降低运维成本以及减少犯错的概率。</p><p>不过，上云容易受到一些不可控的因素干扰，例如云服务厂商突然做出骚操作，之前就存在云服务厂商升级组件而未通知客户，而组件升级切换并不平滑，导致客户部署的服务出现短暂不可用，甚至出现更为糟糕的情况——光缆被挖断了，物理意义上的断你网线，如果没有做好多地容灾，那后果可想而知，服务完全down，无法恢复，当然，不仅云上有这个问题，云下同样如此，因为本质都是机房，只不过运维方式不同。</p><p>而中间件出问题导致服务不可用的情况只能说挺少见的，至少我目前还未遇到过，但是做好应对方案也是必要的，因为谁也保不准什么时候会出问题，弄好预案就多一份保险，省的出问题时两眼一黑。</p><h2 id="动态数据源"><a href="#动态数据源" class="headerlink" title="动态数据源"></a>动态数据源</h2><p>上云前需要弄清楚各个中间件如何动态设置数据源，从而实现热更新，即仅更改某处的配置即可对应用使用的数据源进行动态更新，而无需重启应用，可以使用Nacos进行配置的修改，而且Nacos支持动态刷新配置，天然支持配置监听，并且也可以不使用Nacos自带的配置监听类，可以使用定时器对配置的数据源进行比对，若发生变化则对数据源进行设置。</p><p>当然，应用启动时是通过读取环境变量来设置初始可用的数据源，避免因为某个数据源不可用导致服务启动失败，由于是上云，因此为了稳妥起见，采用了云下——混合云——云上的渐进上云，混合云的中间件都还是连接的云下，而流量是按比例打到云上和云下，而为了做好上云的准备，各个中间件的数据需要从云下同步到云上，当上云时会将云下服务全量停止，云上服务中间件全量切入，并全量流量切入，为此需要准备两个配置文件，方便进行切换。</p><h2 id="故障转移方案"><a href="#故障转移方案" class="headerlink" title="故障转移方案"></a>故障转移方案</h2><h3 id="废案"><a href="#废案" class="headerlink" title="废案"></a>废案</h3><p>在应用启动时同时初始化云上和云下的数据源bean，而在使用数据源时，通过当前配置的数据源标记进行匹配数据源，从而进行相关的数据源操作，这个存在致命的问题，就是当云上和云下其中一个数据源出现问题，服务会无法启动，所以才有后续的补充方案（仅是个想法，还未进行验证）。</p><h4 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h4><p>通过继承AbstractRoutingDataSource这个jdbc动态数据源类，重写determineCurrentLookupKey方法，即可使用相应的数据源，正常场景是读写分离，写入使用主库，查询使用从库。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;cloudDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource cloudDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;idcDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource idcDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置初始数据源信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;CLOUD&quot;</span>, cloudDataSource);</span><br><span class="line">        map.put(<span class="string">&quot;IDC&quot;</span>, idcDataSource);</span><br><span class="line">        setTargetDataSources(map);</span><br><span class="line">        setDefaultTargetDataSource(idcDataSource);</span><br><span class="line">        <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是主要的方法，根据key查找对应的数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CLOUD&quot;</span>; <span class="comment">// 这里需要修改为返回动态的数据源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Redis-Kafka"><a href="#Redis-Kafka" class="headerlink" title="Redis&#x2F;Kafka"></a>Redis&#x2F;Kafka</h4><p>Redis和Kafka一般都有工具类，因此在工具类中注入bean，并且通过map维护云上和云下对应的bean，执行相关操作时，通过数据源标记在map中获得相应的bean即可，无需额外操作。</p><p>而以上最终成为了废案，因为不确定因素太多了，容易出现问题，所以采用了最稳妥的方案即终极方案。</p><h3 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h3><p>直接改配置文件，然后重启服务，是的，你没看错，采用了最原始的方式，同样是最为可靠的方式，虽然服务不可用的时间会比较长，但是更为稳妥，不容易出现问题，且代码侵入性低，一个字，白学（bushi</p><h3 id="补充方案（未验证）"><a href="#补充方案（未验证）" class="headerlink" title="补充方案（未验证）"></a>补充方案（未验证）</h3><p>由于废案中是同时初始化云上和云下两套数据源，那么在启动的时候指定其中某一套可用的数据源初始化不就行了，通过查询资料得知，貌似是可行的，通过方法在应用启动后还可以手动初始化数据源，从而实现动态切换数据源，而触发初始化数据源的就可以是之前所提到的使用定时器对配置的数据源进行比对，只不过不是设置数据源了，而是重新初始化数据源。</p><h4 id="MySql-1"><a href="#MySql-1" class="headerlink" title="MySql"></a>MySql</h4><p>以Druid为例，DruidDataSource提供restart方法，可以在应用启动后重新初始化连接池，因此可以修改数据源配置后，由定时器进行调用，设置为需要切换的对应配置，如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，cloudDataSource需要为DruidDataSource类型</span></span><br><span class="line">cloudDataSource.setUrl(<span class="string">&quot;jdbc:mysql://***.***.***.***:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&quot;</span>);</span><br><span class="line">cloudDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">cloudDataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">cloudDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">cloudDataSource.restart();</span><br></pre></td></tr></table></figure></div><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>暂未找到相关方法，待补充。。。</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>暂未找到相关方法，待补充。。。</p>]]></content>
    
    
    <summary type="html">关于上云故障转移方案设想及实操。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="上云" scheme="https://yhxjs.github.io/tags/%E4%B8%8A%E4%BA%91/"/>
    
    <category term="故障转移" scheme="https://yhxjs.github.io/tags/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://yhxjs.github.io/2024/10/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://yhxjs.github.io/2024/10/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2024-10-18T14:37:17.000Z</published>
    <updated>2024-10-18T14:45:24.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>函数对象是函数指针引申出来的概念，可以定义一个只有方法而没有数据的类，然后把这个类的对象传递给别的方法，这时传递的这个对象就是一个函数对象。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>将共同的部分提取为一个方法，将不同操作的行为作为参数传递给这个方法，上述的操作的方式就是行为参数化，运用这个特性可以减少创建方法的数量，相当于传入一个匿名函数，而这个匿名函数对应的方法是外部定义的。</p><p>而传入函数式接口后，并不会立即执行，而是取决于高阶函数内部在什么时机进行调用，这就是延迟执行的特点。</p><p>函数式接口相当于函数对象的一种子集，仅包含一个抽象方法，可用@FunctionalInterface进行编译时检查。</p><p>如以下形式：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述代码定义了一个入参类型为T，返回值类型为R的函数式接口，将函数式接口传入高阶函数（所谓高阶，就是指它是其他函数对象的使用者），调用apply方法即可。</p><ul><li><p>将通用、复杂的逻辑隐含在高阶函数内。</p></li><li><p>将易变、未定的逻辑放在外部的函数对象中。</p></li></ul><p>可以使函数灵活性大大增加，使用者可以无需关心内部实现，只需知晓传入的函数在何时进行调用，进而使函数抽象性大幅提升，更加符合开闭原则。</p><h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>提供了一种简洁的方式来定义小型匿名函数，这些函数可以作为参数传递给其他方法或作为返回值使用。</p><p>由于Java目前只能Pass-by-value，因此对于Lambda也和有匿名类一样的final的局限性，无法在Lambda表达式中修改外部元素的值。</p><p>Lambda最终还是会被翻译为实际的类、对象、方法，是一种语法糖，减少开发者编写冗余的代码，方法会在编译期间生成，在当前类中生成private static方法，方法内包含对应 Lambda 表达式的逻辑，而对应的类和对象会在运行期间自动生成，开发者无需关心，在生成的类中，调用了在原始类中生成的静态方法。</p><p>语法为(参数列表) -&gt; 执行过程，形如(a, b) -&gt; a + b，即传入a和b，返回a+b。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>将现有方法的调用转化为函数对象。</p><p>方法引用跟Lambda一样，同样最终还是会被翻译为实际的类、对象、方法，只不过由于方法已经存在，无需再次生成，而对应的类和对象依旧会在运行期间自动生成，直接调用被引用的方法。</p><p>语法为类::方法，形如Student::getName。</p><h3 id="常见的函数式接口"><a href="#常见的函数式接口" class="headerlink" title="常见的函数式接口"></a>常见的函数式接口</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Runnable</span><br><span class="line">() -&gt; <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">Callable</span></span><br><span class="line"><span class="params">()</span> -&gt; T</span><br><span class="line"></span><br><span class="line"><span class="title function_">Comparator</span></span><br><span class="line"><span class="params">(T,T)</span> -&gt; <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">Consumer</span></span><br><span class="line"><span class="params">(T)</span> -&gt; <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">Function</span></span><br><span class="line"><span class="params">(T)</span> -&gt; R</span><br><span class="line"></span><br><span class="line"><span class="title function_">Predicate</span></span><br><span class="line"><span class="params">(T)</span> -&gt; <span class="type">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">Supplier</span></span><br><span class="line"><span class="params">()</span> -&gt; T</span><br><span class="line"></span><br><span class="line"><span class="title function_">UnaryOperator</span></span><br><span class="line"><span class="params">(T)</span> -&gt; T</span><br></pre></td></tr></table></figure></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Lambda表达式使用外部定义的变量（局部变量、成员变量、静态变量），函数对象和它外界的变量绑定在一起，就形成了闭包。</p><p>函数式编程要求函数产生的结果只与传入函数的参数有关，即对象状态不能发生变化，但在实际开发场景中是可以对对象的内部状态进行修改，不一定非得完全满足函数式编程的要求。</p><p>如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;just test&quot;</span>);</span><br><span class="line">    Function&lt;String, String&gt; func = append -&gt; test.content + <span class="string">&quot; &quot;</span> + append; <span class="comment">// 这就是一个闭包</span></span><br><span class="line">    assertThat(func.apply(<span class="string">&quot;this&quot;</span>)).isEqualTo(<span class="string">&quot;just test this&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要求test实例不变，但可以修改内部字段</span></span><br><span class="line">    test.content = <span class="string">&quot;just fxxk&quot;</span>;</span><br><span class="line">    assertThat(func.apply(<span class="string">&quot;this&quot;</span>)).isEqualTo(<span class="string">&quot;just fxxk that&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用闭包能够为函数提供除参数以外的其他数据。</p><p>引用外部变量可能有 3 中情况：</p><ol><li>局部变量</li><li>静态变量</li><li>成员变量</li></ol><p>局部变量会在生成的类中新增private final成员变量，生成的静态方法增加对应个数的参数，构造函数也会相应增加对应个数的参数，而重写的方法则会使用新增的那些成员变量，传入静态方法。</p><p>如果为静态变量，由于可以直接使用，因此生成的方法又回到两个参数，这是因为在方法内部可以通过类名.静态变量的形式访问到目标静态变量，同样，生成的类的构造函数也回归无参。</p><p>而成员变量，生成的方法依旧是两个参数，方法内部可以通过this.成员变量的形式访问到目标成员变量，但它不再是静态方法，而是成员方法。生成的类也发生了变化，它的构造函数需要接收一个成员变量所在类的实例，重写的方法中调用生成的成员方法。</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>让接收多个参数的函数转换成一系列接收一个参数的函数，使用柯里化实现让函数分步执行。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fa</span> &#123;</span><br><span class="line">    Fb <span class="title function_">op</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fb</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Fa</span> <span class="variable">fa</span> <span class="operator">=</span> (a) -&gt; (b) -&gt; a + b; <span class="comment">// 实际上也是闭包</span></span><br><span class="line">    <span class="type">Fb</span> <span class="variable">fb</span> <span class="operator">=</span> fa.op(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fb.op(<span class="number">1</span>);</span><br><span class="line">    assertThat(r).is(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>通过source产生流，然后依次通过一些中间操作，比如过滤，转换，限制等，最后结束对流的操作，这就是流式操作。</p><p>Stream API主要是通过Lambda表达式完成，极大的提高了程序的效率和可读性，同时Stram API中自带的并行流使得并发处理集合的门槛再次降低。</p><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>从已有数据构建出Stream对象：</p><ul><li>Collection.stream()</li><li>Arrays.stream(T array)</li><li>Stream.of()</li></ul><p>不从现有数据生成Stream对象：</p><ul><li>IntStream.range(int start, int end) &#x2F;&#x2F; 生成从start到end-1的流，rangeClosed生成的流包含end</li><li>IntStream.iterate(final int seed, final IntUnaryOperator f) &#x2F;&#x2F; 根据上一个元素生成下一个元素，传入开始的元素即seed，然后根据传入的操作生成下一个元素，如x -&gt; x * 2，两个参数的需要用limit限定个数，不然就是一个无限流，除了使用limit，还可以使用三个参数的函数IntStream.iterate(final int seed, IntPredicate hasNext, IntUnaryOperator next)，第二个参数为判断结束生成的条件，如IntStream.iterate(1, x -&gt; x &lt;&#x3D; 9, x -&gt; x * 2)生成的流包含的元素为1、2、4、8</li><li>IntStream.generate(IntSupplier s) &#x2F;&#x2F; 不指定初始值，只需要传入无参的生成规则，常用来生成随机数流</li></ul><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><ol><li><p>filter</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure></div><p>顾名思义，就是过滤元素，通过调用传入的推断型函数式接口，若为true则进行保留，否则丢弃。</p></li><li><p>map</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure></div><p>映射，将流中的元素通过某种规则转化为另外的元素，可以看到传入的函数式接口是Function，接受一种类型的元素，生成另一种类型的元素。</p></li><li><p>flatMap</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br></pre></td></tr></table></figure></div><p>扁平化映射，与map不同的是，map是同维度的转化，而flatMap是将二维的数据降为一维，即将多个stream转化为一个stream，可以类比于多维数组，但可以执行更加复杂的操作，例如取交集，如下代码：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Test&gt; updateDataList = testList.stream()</span><br><span class="line">.flatMap(x -&gt; allList.stream()</span><br><span class="line">.filter(x::equals)</span><br><span class="line">.map(Test::<span class="keyword">new</span>)))</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div><p>本质上就是将每个单独的流进行筛选后再扁平化，就是取交集的过程了。</p></li><li><p>distinct</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div><p>跟数据库的distinct一样，用于去重，会自动调用对象的equals方法和hashCode方法，所以一般情况下是需要重写类的equals方法和hashCode方法。</p></li><li><p>peek</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure></div><p>peek有遍历的意思，和终结操作forEach一样，但是它是一个中间操作，可以继续对流进行操作。</p></li><li><p>sorted</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure></div><p>排序，默认是从小到大排列，sorted方法包含一个重载，使用sorted方法，如果没有传递参数，那么流中的元素就需要实现Comparable<T>方法，也可以在使用sorted方法的时候传入一个Comparator<T>，如果需要从大到小排序，可以在传入的comparator后加上reversed()。</p></li><li><p>limit</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure></div><p>裁剪操作，跟数据库的limit如出一辙，都是限制n个元素，实际上会取min(n,size)个元素，n表示参数，size表示流中元素个数，毕竟不可能取的比流中元素个数还多。</p></li><li><p>skip</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure></div><p>跳过n个元素，n为传入的元素，跟数组不同的是，skip不存在越界的概念，因为会进行判断，如果越界即超过流中元素个数则会返回一个空流。</p></li></ol><h3 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h3><ol><li><p>forEach</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure></div><p>终结操作的遍历，操作和中间操作peek一样，但是forEach之后就不会再返回流。</p></li><li><p>toArray</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure></div><p>将流转化为一个数组，不常用，一般还是转化为List。</p></li><li><p>reduce</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br></pre></td></tr></table></figure></div><p>归纳操作，将流中的各个元素结合起来，它需要一个起始值，然后按照一定的规则进行计算，比如相加相乘等，它接收一个二元操作 BinaryOperator函数式接口。从某种意义上来说，sum、min、max、average都是特殊的reduce，sum和average是Number流的操作，如字面意思，求和和求平均值，可以将一个对象流通过mapToInt&#x2F;mapToLong&#x2F;mapToDouble操作转化为对应的Number流。</p></li><li><p>max&#x2F;min</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure></div><p>找出最大或者最小的元素，传入一个比较器，会逐一进行比较，最终取得最大或者最小的元素，实际上也是一种reduce操作。</p></li><li><p>count</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div><p>返回流中元素的个数。</p></li><li><p>anyMatch&#x2F;allMatch&#x2F;noneMatch</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure></div><p>测试是否有任意元素&#x2F;所有元素&#x2F;没有元素匹配表达式。</p></li><li><p>findFirst&#x2F;findAny</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst();</span><br><span class="line">Optional&lt;T&gt; findAny();</span><br></pre></td></tr></table></figure></div><p>findFirt返回流中第一个元素，findAny返回流中任意一个元素，并不保证每次都返回同一个元素。</p></li><li><p>collect</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure></div><p>收集操作，最重要也是最常用的一个终结操作，可以将流转化为对应的各种容器类型。</p><p>collect包含两个重载：一个参数和三个参数。</p><p>三个参数的函数很少使用，因为JDK提供了最常使用的Collector可以直接使用，可以简单了解下这三个参数什么意思：</p><ul><li>supplier：用于产生最后存放元素的容器的生产者</li><li>accumulator：将元素添加到容器中的方法</li><li>combiner：将分段元素全部添加到容器中的方法</li></ul><p>例如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(ArrayList::<span class="keyword">new</span>, List::add, List::addAll);</span><br><span class="line"><span class="comment">// 其实相当于如下</span></span><br><span class="line">List&lt;String&gt; result = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div><p>Collectors中包含很多常用的转换器，如toList()、toSet()等。</p><p>toList默认生成的是ArrayList，toSet默认生成的是HashSet，如果想要指定其他容器，可以如下操作：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure></div><p>常用的转换器还有joining()、groupingBy()、toMap()。</p><p>joining和String.join()类似，将一系列字符串用某个字符进行分隔然后返回。</p><p>groupingBy和数据库中的groupBy一样都是分组，返回一个Map。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, D&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier,</span><br><span class="line">                                  Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                  Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure></div><p>groupingBy接收三个参数，分别为：</p><ul><li>classifier：分组按照什么分类</li><li>mapFactory：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为HashMap）</li><li>downstream：按照第一个参数分类后，对应的分类的结果如何收集，即下游收集器</li></ul><p>例如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将学生以年龄分组，每组中只存学生的名字而不是对象</span></span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = students.stream().</span><br><span class="line">                collect(Collectors.groupingBy(Student::getAge, Collectors.mapping(Student::getName, Collectors.toList())));</span><br></pre></td></tr></table></figure></div><p>toMap可以将List转化为Map，但是需要注意的是，默认转化用到的key需要是唯一的，不然会报如下错误：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Duplicate key</span><br></pre></td></tr></table></figure></div><p>可以传入第三个参数mergeFunction，用于处理key重复的情况，例如(o1, o2)-&gt;o2，这里的o1、o2可以理解为o1为老的，o2为新的，所以(o1, o2)-&gt;o2为当key重复时，用后面的值覆盖之前的值。</p></li></ol><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>通过parallel()可以将一个普通的流转化为并行处理的流即并行流，也可以直接使用parallelStream获取并行流。</p><p>实际上就是创建多个线程对流进行操作，能够借由多线程提升计算的性能？实际上对于百万级别以下的数据计算，并行流反而性能更差，因为线程上下文开销远远大于本身计算的时长。</p><p>因此并行化并不常用，在普通程序中使用最基础的串行普通流即可，如果数据量达到百万级别，需要使用并行流，收集时使用并发容器可以提升性能。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="惰性操作"><a href="#惰性操作" class="headerlink" title="惰性操作"></a>惰性操作</h4><p>流的中间操作是惰性的，如果一个流操作流程中只有中间操作，没有终结操作，那么这个流什么都不会做，整个流程中会一直等到遇到终结操作操作才会真正的开始执行，根据这个特性可以根据条件进行不同的中间操作。</p><h4 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h4><p>包括一类Short-circuiting，它能够改变流中元素的数量，一般这类API如果是中间操作，最好写在靠前位置：</p><h4 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h4><p>对于stream的每一步操作最好都单独一行，这样能够清晰明确每一步都做了什么，增加代码的易读性。同时由于Lambda表达式省略了参数类型，因此对于变量，尽量使用完成的名词，比如student而不是s，增加代码的可读性。</p>]]></content>
    
    
    <summary type="html">函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://yhxjs.github.io/tags/Java/"/>
    
    <category term="Lambda" scheme="https://yhxjs.github.io/tags/Lambda/"/>
    
    <category term="函数式" scheme="https://yhxjs.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
    <category term="Stream API" scheme="https://yhxjs.github.io/tags/Stream-API/"/>
    
  </entry>
  
  <entry>
    <title>重学JUC</title>
    <link href="https://yhxjs.github.io/2024/09/30/%E9%87%8D%E5%AD%A6JUC/"/>
    <id>https://yhxjs.github.io/2024/09/30/%E9%87%8D%E5%AD%A6JUC/</id>
    <published>2024-09-30T08:06:25.000Z</published>
    <updated>2024-10-01T03:42:03.551Z</updated>
    
    <content type="html"><![CDATA[<p>JUC是java.util.concurrent包的简称，方便开发者并发编程，包括线程池、异步IO和轻量级任务框架，还提供了设计用于多线程上下文中的Collection实现等。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池可以减少新建线程的开销，使得线程可以复用，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。</p><p>带来的好处：</p><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>提供了Executors工厂方法，调用如下方法即可创建对应的线程池：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();<span class="comment">//无界线程池，可以自动回收线程</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="type">int</span>);<span class="comment">//固定大小线程池</span></span><br><span class="line">Executors.newSingleThreadExecutor();<span class="comment">//单个后台线程</span></span><br></pre></td></tr></table></figure></div><p>线程池的继承结构：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor 负责线程的使用与调度的根接口</span><br><span class="line"> *   |--**ExecutorService 子接口，线程池的主要接口</span><br><span class="line"> *    |--ThreadPoolExecutor 线程池的实现类</span><br><span class="line"> *    |--ScheduledExecutorService 子接口：负责线程的调度</span><br><span class="line"> *     |--ScheduledThreadPoolExecutor 继承ThreadPoolExecutor，实现 ScheduledExecutorService</span><br></pre></td></tr></table></figure></div><p>通常会自定义线程池，通过指定一些关键参数来创建线程池交由Spring容器进行管理。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ExecutorService <span class="title function_">defaultExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(CORE_POOL_SIZE);<span class="comment">//核心线程数</span></span><br><span class="line">    executor.setMaxPoolSize(MAX_POOL_SIZE);<span class="comment">//最大线程数</span></span><br><span class="line">    executor.setKeepAliveSeconds(KEEP_ALIVE_TIME);<span class="comment">//非核心空闲线程存活时间</span></span><br><span class="line">    executor.setQueueCapacity(QUEUE_CAPACITY);<span class="comment">//等待队列数</span></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;default&quot;</span>);<span class="comment">//线程前缀</span></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<span class="comment">//拒绝策略</span></span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor.getThreadPoolExecutor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>线程池调度过程如下：</p><ol><li>判断核心线程是否已满，若未满则创建核心线程执行任务，否则进入2。</li><li>判断等待队列是否已满，若未满则将任务添加到队列之中，否则进入3。</li><li>判断线程池是否已满，若未满则创建非核心线程执行任务，否则进入4。</li><li>按照配置的拒绝策略进行处理。</li></ol><p>拒绝策略有如下几种：</p><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</p><p>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。</p><p>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</p><p>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolExecutor defaultExecutor;<span class="comment">//注入线程池</span></span><br><span class="line"></span><br><span class="line">方法一</span><br><span class="line">defaultExecutor.execute(Runnable);<span class="comment">//直接execute执行任务</span></span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">使用CompletableFuture时指定线程池</span><br><span class="line">CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, defaultExecutor);</span><br><span class="line">CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, defaultExecutor);</span><br><span class="line">CompletableFuture.allOf(future1, future2).join();</span><br></pre></td></tr></table></figure></div><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>每个线程Thread中都有一个ThreadLocalMap类型的成员变量，用于维护相关的ThreadLocal，ThreadLocalMap的key为每个ThreadLocal的弱引用，value为实际存放的值，每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了<strong>线程隔离</strong>。</p><blockquote><p>需要注意的是ThreadLocal中的key为弱引用，若未remove可能会造成不进行gc导致内存泄漏。</p><p><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候。</p><p><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。</p><p><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收。</p><p><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>场景一</p><p>每个线程需要使用一个独享的对象时，可以使用ThreadLocal来存储该对象，结合线程池使用就是核心线程不需要每次都新建一个对象，节省新建对象以及gc带来的开销。</p><p>场景二</p><p>线程上下文中需要多次使用的对象，例如登录的用户信息，可以在拦截器中对ThreadLocal进行维护，需要时从ThreadLocal中获取即可，无需在方法中不断传递，注意在拦截器的afterCompletion方法中进行ThreadLocal的remove，之所以是afterCompletion而不是postHandle是因为若抛出异常，postHandle则不会被调用，导致ThreadLocal未进行remove，进一步出现内存泄漏问题。</p><p>场景三</p><p>在ThreadLocal中保存traceId，而需要传递或者使用时维护ThreadLocal即可，而slf4j提供这样一个上下文ThreadLocal——MDC，直接使用即可。</p><p>服务发送请求时可以实现RequestInterceptor来将MDC中的traceId设置到请求头中，服务接受请求时，将请求头中的traceId存入MDC。</p><p>由于MDC时基于普通的ThreadLocal实现的，所以在多线程中需要将上下文传入线程之中，如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();</span><br><span class="line">    <span class="built_in">super</span>.execute(() -&gt; run(runnable, context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Runnable runnable, Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">        MDC.setContextMap(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MDC.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>消息队列需要在消息体中自定义traceId属性，接收方消费消息后，解析出traceId即可继续传递。</p><p>以上过程中，需要注意在结果返回前调用MDC.remove()。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="乐观锁vs悲观锁"><a href="#乐观锁vs悲观锁" class="headerlink" title="乐观锁vs悲观锁"></a>乐观锁vs悲观锁</h4><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了，<a href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB">原子变量类</a>就是使用其中的一种方式<a href="#CAS">CAS</a>实现的。高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder，用空间换时间），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能，主要针对的对象是单个共享变量。</p><h4 id="阻塞锁vs自旋锁"><a href="#阻塞锁vs自旋锁" class="headerlink" title="阻塞锁vs自旋锁"></a>阻塞锁vs自旋锁</h4><p>阻塞锁见名思意，即当线程加锁失败时，则会释放CPU给其他线程运行并进行阻塞即进入睡眠状态，直到被系统唤醒，而当锁被释放时，之前睡眠状态的线程会被唤醒变为就绪状态，然后内核会在合适的时间，把CPU切换给该线程运行。由于阻塞锁有线程状态的变化，此时就会产生一个操作——上下文切换，即将线程的私有数据、寄存器等不共享的数据进行切换，并且会在用户态和内核态之间进行切换，这样才能保证上下文是一致的。</p><p>自旋锁则是利用CPU周期进行忙等待，自旋锁开销少（因为不需要上下文切换），但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以需要注意锁住的时间，否则容易导致CPU资源被耗尽，一般实现自旋锁会设置一个超时时间，超过该时间则主动放弃，不继续执行，可以在一定程度上避免上述情况发生，自旋锁同样借鉴了<a href="#CAS">CAS</a>的思想。</p><p>自旋锁适用于锁定时间短、锁竞争不频繁的场景，而阻塞锁更适合锁定时间较长或锁竞争较频繁的场景。-</p><h4 id="公平锁vs非公平锁"><a href="#公平锁vs非公平锁" class="headerlink" title="公平锁vs非公平锁"></a>公平锁vs非公平锁</h4><p>公平还是不公平，这是门学问，咳咳咳。</p><p>公平锁和非公平锁是针对阻塞锁的概念，所谓公平则是按照先来后到的原则，按顺序唤醒阻塞的线程，可以有效避免造成线程饥饿（因为抢占而长时间获取不到锁），但由于需要保证有序，而唤醒一个线程时会有延时，相当于可以抢占时却白白增加了上下文切换的开销，而非公平锁则是若解锁时刚好有线程请求加锁，则会直接把锁给它，而不是唤醒阻塞的线程，同时唤醒顺序也可以不按阻塞顺序来，这样就可能会使阻塞的线程一直处于阻塞状态，导致线程饥饿，但有效提高了并发的性能，因为减少了不必要的上下文切换。</p><p>若不需要保证完全的有序，那么使用性能更优的非公平锁即可，反之则使用公平锁。</p><h4 id="可重入锁vs不可重入锁"><a href="#可重入锁vs不可重入锁" class="headerlink" title="可重入锁vs不可重入锁"></a>可重入锁vs不可重入锁</h4><p>可重入锁又称递归锁，指同一个线程可以在外层方法获取了锁，而在进入内层方法后依旧能获取到同一把锁，简单来说，就是同一个线程能继续获取它所拥有的锁，这就要求加锁和解锁是成对的，不然可能会发生死锁，不可重入锁则要求持有者仅且可以加锁一次，若持有者再申请加锁就会造成死锁，因此可重入锁可以在一定程度上避免死锁。</p><h4 id="共享锁vs排他锁"><a href="#共享锁vs排他锁" class="headerlink" title="共享锁vs排他锁"></a>共享锁vs排他锁</h4><p>共享锁和排他锁的经典实现就是读写锁，分别对应其中的读锁和写锁，排他锁即为只能被一个线程所持有，其他线程无法对锁住的资源进行操作，锁持有者则可以对资源进行读写，而共享锁是指能被多个线程同时持有，但获取锁后仅能读取资源，加上共享锁后不可继续加排他锁。</p><p>读写锁的实现是基于<a href="#AQS">AQS</a>的，ReentrantReadWriteLock是Java的一种读写锁，其中的WriteLock与ReadLock是靠内部类Sync实现的。由于读锁和写锁是分离的，读读不做互斥，因此在读多写少的情况下，相较于普通的排他锁，性能大幅提高。</p><h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>原子变量类依赖于CAS，CAS 的全称是Compare And Swap（比较与交换），用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>在Java中，实现CAS操作的一个关键类是Unsafe，提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的CAS操作，而Unsafe 提供的这些功能的实现需要依赖本地方法，直接调用底层的硬件指令来实现原子操作，保证不同系统的效果是一致的。</p><p>CAS最常见的问题就是ABA问题，即一个变量初次读取的值为A，而在后续操作中被修改成了B，然后又被改回A，此时再次读取还是A，就会误认为该变量没被修改过，显然是不合理的，解决该问题的方法就是引入版本号或者时间戳之类的唯一标识，变量值比较通过后再比较该标志，也比较通过后才修改变量的值。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>使用原子的方式更新基本类型，不同的基础类型的原子变量类提供的方法几乎相同，此处以AtomicInteger为例，常用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值</span></span><br></pre></td></tr></table></figure></div><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>使用原子的方式更新数组里的某个元素，以AtomicIntegerArray为例，常用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值</span></span><br></pre></td></tr></table></figure></div><p>除了是数组以外，和基本类型使用方法基本一致。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>AtomicReference类跟基本类型区别就是更新的类型为对象，可以实现新对象的替换，而想要细化到对象属性的话，需要使用Atomic***FieldUpdater，以AtomicIntegerFieldUpdater为例：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerFieldUpdater&lt;Person&gt; ageUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yhxjs&quot;</span>, <span class="number">23</span>);</span><br><span class="line">ageUpdater.incrementAndGet(person); <span class="comment">//自增</span></span><br><span class="line">ageUpdater.addAndGet(person, <span class="number">5</span>); <span class="comment">//增加5</span></span><br><span class="line">ageUpdater.compareAndSet(person, <span class="number">28</span>, <span class="number">30</span>); <span class="comment">//如果当前值是28，则设置为30，该方法会返回成功还是失败</span></span><br></pre></td></tr></table></figure></div><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>仅介绍部分并发容器，感兴趣可以自行查看JDK的源码。</p><p>ConcurrentHashMap: 线程安全的HashMap</p><p>CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于Vector。</p><p>BlockingQueue: 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>跟HashMap实现一样，底层为Node数组 + 链表&#x2F;红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p>ConcurrentHashMap初始化是通过自旋 + CAS实现的，添加元素流程如下：</p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>用当前 key 定位出Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，则需要进行扩容。</li><li>如果都不满足，则利用synchronized锁写入数据。</li><li>如果数量大于TREEIFY_THRESHOLD则要执行树化方法，在treeifyBin中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ol><p>查询元素流程如下：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的value。</li><li>如果头节点hash值小于0，说明正在扩容或者是红黑树，进行查找。</li><li>如果是链表，则遍历进行查找。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>从名字就可以看出CopyOnWriteArrayList线程安全的核心在于其采用了写时复制，当需要修改（ add，set、remove等操作）内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p><p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能，但由于每次数据修改都需要创建一个副本，这就带来了额外的开销以及内存的占用。由于是先对副本进行修改，因此存在一定的数据一致性问题，例如当进行写发操作时，处于副本写入的过程即还未替换为真正的数组，这时候读取还是从旧的数组中进行的，这就导致了读到‘脏数据’。</p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>阻塞队列被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>由此BlockingQueue被用于线程池，当核心线程无法及时处理任务时，这些任务都会扔到workQueue中，以常用的阻塞队列ArrayBlockingQueue为例。</p><p>ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁ReentrantLock，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞，尝试从一个空队列中取一个元素也会同样阻塞。</p><p>主要涉及的方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">put(E e)：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。</span><br><span class="line">take()：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。</span><br></pre></td></tr></table></figure></div><p>ArrayBlockingQueue也支持非阻塞获取和新增元素（例如poll()和offer(E e)方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为null，一般不会使用。</p><h2 id="并发流程"><a href="#并发流程" class="headerlink" title="并发流程"></a>并发流程</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>经常用来控制固定数量线程的流程，倒数结束前一直进行等待，直到倒数结束后即其他线程的操作执行完后，当前线程才会继续进行，主要函数如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch(<span class="type">int</span> count) <span class="comment">//初始化一个值为count的倒数门闩</span></span><br><span class="line">countDown() <span class="comment">//将count减1，当值为0时，唤醒等待的线程</span></span><br><span class="line">await() <span class="comment">//调用该方法的线程会被挂起，直至count值为0才会被唤醒</span></span><br></pre></td></tr></table></figure></div><p>常见的使用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个倒计数为 3 的 CountDownLatch</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 1&quot;</span>, <span class="number">2000</span>, latch));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 2&quot;</span>, <span class="number">3000</span>, latch));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">service3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Service</span>(<span class="string">&quot;服务 3&quot;</span>, <span class="number">4000</span>, latch));</span><br><span class="line"></span><br><span class="line">    service1.start();</span><br><span class="line">    service2.start();</span><br><span class="line">    service3.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有服务初始化完成</span></span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有服务都准备好了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> timeToStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Service</span><span class="params">(String name, <span class="type">int</span> timeToStart, CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.timeToStart = timeToStart;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(timeToStart);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 准备好了&quot;</span>);</span><br><span class="line">        latch.countDown(); <span class="comment">// 减少倒计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>将CountDownLatch传入主线程需要等待的线程，主线程调用await()进行等待，当线程执行完毕后调用countDown()方法减少计数，当计数为0时，主线程继续执行。</p><p>以上场景为一个线程等待多个线程执行完成，CountDownLatch也可以用于多个线程等待一个&#x2F;多个线程，例如资源的初始化的场景，初始化所有资源后才执行后续操作。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，熟悉C语言的小伙伴就知道C语言也有semaphore.h这个库，定义了信号量的一些操作，使用方法也是一致的，都是进行PV操作，即P操作负责分配资源，没有资源的时候就等着（进入阻塞队列）。V操作负责释放资源，在阻塞队列不为空的时候唤醒某个进程进入临界区。</p><p>主要方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(<span class="type">int</span> <span class="keyword">permits</span>) <span class="comment">//初始化一个许可证数量为permits的信号量，可以第二个参数指定其公平性，一般为true</span></span><br><span class="line">acquire() <span class="comment">// 尝试获取一个信号量，如果获取不到，就会阻塞当前线程，直到有线程释放信号量，对应P操作</span></span><br><span class="line">release() <span class="comment">//释放一个信号量，释放之后，会唤醒一个等待的线程，对应V操作</span></span><br><span class="line">tryAcquire() <span class="comment">//尝试获取一个信号量，如果获取不到，就会返回 false，不会阻塞当前线程</span></span><br></pre></td></tr></table></figure></div><p>Semaphore用来控制同时访问某个特定资源的操作数量，它并不保证线程安全，所以要保证线程安全，还需要加上同步锁。</p><p>acquire()还可以传入指定数量获取指定数量的信号量，release()也是一样，需要注意的是，获取与释放的信号量个数最好保持一致，不然容易造成信号量越来越少或者越来越多，最后不符合预期，甚至造成线程一直阻塞，形成类似死锁。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>条件对象，类似锁的条件锁，当满足一定条件再释放该锁，即可实现消费者和生产者的效果。</p><p>常用方法：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock.newCondition() <span class="comment">//条件对象依托于其他锁</span></span><br><span class="line">await() <span class="comment">//进入等待，会自动释放持有的锁</span></span><br><span class="line">signal() <span class="comment">//唤醒等待时间最长的线程</span></span><br><span class="line">signalAll() <span class="comment">//唤醒所有正在等待的线程</span></span><br></pre></td></tr></table></figure></div><p>实现消费者和生产者代码如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferResources</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//使用队列作为缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//生产者对应Condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//消费者对应Condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 当前缓冲区为空，等待生产中...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//消费者进入等待状态</span></span><br><span class="line">                    consumerCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行消费数据，从First开始消费，模拟队列</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费成功：&quot;</span> + value + <span class="string">&quot; 当前缓冲区size = &quot;</span> + queue.size());</span><br><span class="line">            <span class="comment">//消费完毕后，只唤醒生产者</span></span><br><span class="line">            producerCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要用finally执行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">(Integer value)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == maxSize) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 当前缓冲区满了，等待消费中...&quot;</span>);</span><br><span class="line">                <span class="comment">//生产者进入等待状态</span></span><br><span class="line">                producerCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进生产数据</span></span><br><span class="line">            queue.offer(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产成功：&quot;</span> + value + <span class="string">&quot; 当前缓冲区size = &quot;</span> + queue.size());</span><br><span class="line">            <span class="comment">//生产完毕后，只唤醒消费者</span></span><br><span class="line">            consumerCondition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要用finally执行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，它允许一组线程互相等待，直到到达某个公共屏障点。</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景，比如，将一个大任务分成10个小任务，用10个线程分别执行这10个小任务，当10个小任务都执行完之后，再合并这10个小任务的结果。</p><p>主要函数如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier(<span class="type">int</span> parties, Runnable barrierAction) <span class="comment">//初始化一个等待数量为parties、回调函数为barrierAction的循环栅栏</span></span><br><span class="line">await() <span class="comment">//进行等待，并且将等待计数减1，当等待数量达到parties，就会执行barrierAction，并且唤醒所有等待的线程</span></span><br></pre></td></tr></table></figure></div><p>常见的使用方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(numberOfThreads, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当所有线程都到达障碍点时执行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程都已到达屏障，进入下一阶段&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;Thread &quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在屏障处等待&quot;</span>);</span><br><span class="line">            barrier.await(); <span class="comment">// 等待所有线程到达障碍点</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已越过屏障.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>最终的任务编排工具，也是实际最常用的工具，可以完美覆盖其他工具的场景。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>Runnable接口不会返回结果或抛出检查异常，但是Callable接口可以，如果任务不需要返回结果或抛出异常使用Runnable即可。</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。当执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时可以继续执行其他事情，不用等待耗时任务执行完成。等其他事情干完后，再通过Future类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>主要方法如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消任务执行</span></span><br><span class="line"><span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"><span class="comment">// 判断任务是否被取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio;</span><br></pre></td></tr></table></figure></div><p>Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的get() 方法为阻塞调用，CompletableFuture就是为了解决这些缺点而生的。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>对于存在前后调用顺序关系的任务，可以进行任务编排。</p><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><ol><li>通过new关键字，跟Future一致。</li><li>基于CompletableFuture自带的静态工厂方法：runAsync()、supplyAsync() ，runAsync接受一个Runnable参数，而supplyAsync接收一个Callable参数。</li></ol><h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><ul><li>thenApply()</li><li>thenAccept()</li><li>thenRun()</li><li>whenComplete()</li></ul><p>thenApply用来处理结果，将接受到的结果进行相关处理。</p><p>thenAccept则是将结果作为输入，执行其他操作，无法改变结果，类似消费者。</p><p>thenRun是运行一个新的Runnable，无法接收结果。</p><p>whenComplete接受结果和异常，进行相关的处理。</p><h5 id="组合方法"><a href="#组合方法" class="headerlink" title="组合方法"></a>组合方法</h5><p>对任务进行组合，常用方法有thenCompose()和thenCombine()。</p><p>thenCompose()可以链接两个CompletableFuture对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</p><p>thenCombine()会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</p><p>allOf()可以使多个CompletableFuture并行运行，都运行完后才会返回，调用join()则会等待所有CompletableFuture执行完毕，anyOf()则是只要有一个执行完毕后就会返回。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于CompletableFuture默认使用的是全局线程池，会有OOM的风险，因此最好指定线程池来创建CompletableFuture。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>很多线程协作类内部都有一个类Sync，且Sync是继承了AQS即AbstractQueuedSynchronizer抽象同步队列，实现了其中的一些方法。</p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>AQS核心思想就是如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于CLH队列实现的。其定义了一套多线程访问共享资源的同步模板，解决了实现同步器时涉及的大量细节问题，能够极大地减少实现工作。</p><p>包含如下内容：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞及唤醒</li><li>队列的管理</li></ul><p>其中包含核心的三个部分：state同步状态、Node组成的CLH队列、ConditionObject条件变量。</p><h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>在AQS中维护了一个同步状态变量state，getState函数获取同步状态，setState、compareAndSetState函数修改同步状态，对于AQS来说，线程同步的关键是对state的操作，可以说获取、释放资源是否成功都是由state决定的，比如state &gt; 0代表可获取资源，否则无法获取，所以state的具体语义由实现者去定义，现有的ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch定义的state语义都不一样。</p><ul><li>ReentrantLock的state用来表示是否有锁资源</li><li>ReentrantReadWriteLock的state高16位代表读锁状态，低16位代表写锁状态</li><li>Semaphore的state用来表示可用信号的个数</li><li>CountDownLatch的state用来表示计数器的值</li></ul><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><p>CLH是AQS内部维护的FIFO（先进先出）双端双向队列（方便尾部节点插入），基于链表数据结构，当一个线程竞争资源失败，就会将等待资源的线程封装成一个Node节点，通过CAS原子操作插入队列尾部，最终不同的Node节点连接组成了一个CLH队列，所以说AQS通过CLH队列管理竞争资源的线程，具有如下优点：</p><ul><li>先进先出保证了公平性</li><li>非阻塞的队列，通过自旋锁和AS保证节点插入和移除的原子性，实现无锁快速插入</li><li>采用了自旋锁思想，所以CLH也是一种基于链表的可扩展、高性能、公平的自旋锁</li></ul><p>其内部类Node定义如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 节点正在以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，因为超时或者或者被中断，节点会被设置成取消状态。被取消的节点不会参与锁竞争，状态也不会再改变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示后继节点处于等待状态，如果当前节点释放了锁或者被取消，会通知后继节点去运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，表示节点处于condition队列中，正在等待被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus变量的可选值，下一次acquireShared应该无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 节点的等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个condition队列等待节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前驱节点或者抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>入队通过自旋CAS尝试往队列尾部插入节点，直到成功，自旋过程如果发现CLH队列不存在时会初始化CLH队列。</p><p>CLH队列中的节点都是获取资源失败的线程节点，当持有资源的线程释放资源时，会将head.next指向的线程节点唤醒（CLH队列的第二个节点），如果唤醒的线程节点获取资源成功，线程节点清空信息设置为头部节点，原头部节点出队。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>Object的wait、notify函数是配合Synchronized锁实现线程间同步协作的功能，AQS的ConditionObject条件变量也提供这样的功能，通过ConditionObject的await和signal两类函数完成。</p><p>不同于Synchronized锁，一个AQS可以对应多个条件变量，而Synchronized只有一个。</p><p>ConditionObject内部维护着一个单向条件队列，不同于CHL队列，条件队列只入队执行await的线程节点，并且加入条件队列的节点，不能在CHL队列， 条件队列出队的节点，会入队到CHL队列。</p><p>当某个线程执行了ConditionObject的await函数，阻塞当前线程，线程会被封装成Node节点添加到条件队列的末端，其他线程执行ConditionObject的signal函数，会将条件队列头部线程节点转移到CHL队列参与竞争资源。</p><h3 id="协作方法"><a href="#协作方法" class="headerlink" title="协作方法"></a>协作方法</h3><p>AQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>直接使用AQS提供的独占式模板，只需明确state的语义与实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可实现自定义协作类，AQS也支持同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><p>简单来说，仅需实现如下钩子方法：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">JUC工具包，全称为Java.util.concurrent工具包，是Java提供的用于实现多线程编程的工具集合。它是在Java 5版本中引入的，并在后续版本中得到了进一步的扩展和优化。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="JUC" scheme="https://yhxjs.github.io/tags/JUC/"/>
    
    <category term="多线程" scheme="https://yhxjs.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IOC和AOP原理</title>
    <link href="https://yhxjs.github.io/2024/08/06/IOC%E5%92%8CAOP%E5%8E%9F%E7%90%86/"/>
    <id>https://yhxjs.github.io/2024/08/06/IOC%E5%92%8CAOP%E5%8E%9F%E7%90%86/</id>
    <published>2024-08-06T12:23:23.000Z</published>
    <updated>2024-08-06T12:38:48.256Z</updated>
    
    <content type="html"><![CDATA[<p>通过对<a class="link"   href="https://github.com/DerekYRC/mini-spring" >mini-spring <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 代码的阅读，对IoC和AOP的原理有了进一步认识，二者都为构成Spring的基础概念，是框架底层的实现原理。</p><blockquote><p>mini-spring是对Spring IOC和AOP部分的简单实现，仅保留最基础的部分。</p></blockquote><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Ioc即控制反转，指的是容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接控制，控制权由应用代码中转到了外部容器，控制权的转移即所谓的反转。</p><p>对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系，因此，Ioc还有另一个名字——依赖注入，即组件之间的依赖关系由容器在运行期间决定，由容器动态地将某种依赖关系注入到组件之间。</p><p>所有的类都会在Spring容器中登记，告诉Spring这是个什么东西，然后当某个类需要什么东西，Spring就会在系统运行到适当的时候，将这个类要的东西主动赋予，同时对于其他类也是如此。所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。</p><p>依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。</p><p>IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>见 <a href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">bean的生命周期</a></p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>AOP面向切面编程基于IoC，是对OOP的有益补充，AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。</p><p>所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><p>AOP代表的是一个横向的关系，将“对象”比作一个空心的立体，其中封装的是对象的属性和行为，则面向切面编程的方法，就是将这个立体以切面形式剖开，选择性地提供业务逻辑，而剖开的切面，也就是所谓的“切面”了。</p><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行，二是采用静态织入的方式，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码。</p><p>Spring实现AOP：JDK动态代理和CGLIB代理。</p><ul><li>JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理，其核心的两个类是InvocationHandler和Proxy。</li><li>CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强，需要引入包asm.jar和cglib.jar。</li></ul><p>使用AspectJ注入式切面和@AspectJ注解驱动的切面实际上底层也是通过动态代理实现的。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>ProxyFactory是动态代理工厂，用来决定使用JDK动态代理还是CGLIB动态代理。</p><p>获取BeanFactory所有的AspectJExpressionPointcutAdvisor继承类，常用的有BeforeAdvice、AfterAdvice、AfterReturningAdvice等，当bean的类型与Advice的Pointcut规定的类型匹配时，则创建代理对象。</p><p>当方法执行时，获取拦截器链（首先获取全部切面，再判断当前代理对象是否匹配该Advisor，是否匹配当前调用method），依据拦截器链依次执行，执行过程相当于是一个递归的过程。</p><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./bean的生命周期.png"                      width="700px" height="auto" alt="bean的生命周期"                ><figcaption>bean的生命周期</figcaption></figure><ol><li>创建BeanFactory并读取XML文件，将定义的bean读取出来，将每个bean的属性参数解析到PropertyValues，当存在依赖其他的bean时，会新建一个BeanReference，然后封装为封装为一个BeanDefinition，通过beanFactory进行注册，而如果配置了包扫描，则会对配置的包下进行扫描，扫描出@Component的类同样封装为一个BeanDefinition进行注册，并注册internalAutowiredAnnotationProcessor以便实例化时对自动注入进行处理。</li><li>添加ApplicationContextAwareProcessor，让继承自ApplicationContextAware的bean能感知bean。</li><li>在bean实例化之前，执行注册的BeanFactoryPostProcessor，修改相关的BeanDefinition。</li><li>注册BeanPostProcessor。</li><li>初始化事件发布者和注册事件监听器。</li><li>注册类型转换器和提前实例化单例bean，只有当bean是单例且不为懒加载才会被创建。<ul><li>先从缓存中获取，如果获取到且为FactoryBean则从FactoryBean#getObject中创建bean。</li><li>否则获取BeanDefinition，并根据此创建bean<ul><li>如果bean需要代理，则直接返回代理对象，遍历BeanPostProcessor，对InstantiationAwareBeanPostProcessor的实现类进行处理，调用其postProcessBeforeInstantiation，若返回值不为null，即生成了被代理对象，再调用postProcessAfterInitialization即可生成最终的代理对象。</li><li>接下来就是未被代理的bean，首先调用类的无参构造方法，生成实例，为解决<strong>循环依赖</strong>问题，将实例化后的bean放进缓存中提前暴露，执行InstantiationAwareBeanPostProcessor，此时@Autowired等就会自动注入属性，然后通过反射设置属性，如果继承了BeanFactoryAware，则执行setBeanFactory，执行BeanPostProcessor的前置处理，调用初始化方法init，执行BeanPostProcessor的后置处理，注册有销毁方法的bean，最后，如果有代理对象，则会进行覆盖。</li></ul></li></ul></li><li>发布容器刷新完成事件</li></ol><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>这三个缓存都是定义在DefaultSingletonBeanRegistry类中的：</p><p>bean name –&gt; bean instance</p><p>单例对象的cache：一级缓存</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div><p>bean name –&gt; bean instance</p><p>提前暴光的单例对象的Cache：二级缓存</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></div><p>bean name –&gt; ObjectFactory</p><p>单例对象工厂的cache：三级缓存</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></div><p>循环依赖主要的三级缓存分别是：</p><ol><li>singletonObbjects：一级缓存单例池，主要存放最终形态的单例bean，一般获取一个bean都是从这个缓存中获取，需要说明的是并不是所有单例bean都存在这个缓存当中，有些特殊的单例bean不存在这个缓存当中。</li><li>earlySingletonObjects：二级缓存，主要存放的是过渡bean（原始对象&#x2F;原始对象的代理对象），也就是从三级缓存当中产生出来的对象，它的作用是防止在多级循环依赖的情况下重复从三级缓存当中创建对象，其他对象都可以直接从二级缓存中获取到原始对象&#x2F;原始对象的代理对象，因为三级缓存当中创建对象是需要牺牲一定得性能，有了这个缓存可以一定程度上提高效率（但是提高的效率并不明显）。只有在调用了三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject</strong>()方法获取原始对象&#x2F;原始对象的代理对象时，才会将原始对象&#x2F;原始对象的代理对象放入二级缓存，而调用三级缓存中的<strong>ObjectFactory</strong>的<strong>getObject</strong>()方法获取原始对象&#x2F;原始对象的代理对象这种情况只会发生在有循环依赖的时候，所以，<strong>二级缓存在没有循环依赖的情况下不会被使用到</strong>。二级缓存是为了提前暴露Bean来解决循环依赖问题，此时的Bean可能还没有进行属性注入，只有等完成了属性注入、初始化后的Bean才会上移到一级缓存（单例池）中。</li><li>singletonFactories三级缓存，用于存放原始对象对应的ObjectFactory，它的作用主要是为了产生一个对象，每生成一个原始对象，都会将这个原始对象对应的ObjectFactory放到三级缓存中，通过调用ObjectFactory的getObject()方法，就能够在需要动态代理的情况下为原始对象生成代理对象并返回，否则返回原始对象，以此来处理循环依赖时还需要动态代理的情况。</li></ol><p>简单来说：</p><ol><li>singletonObjects，一级缓存，存储的是所有创建好了的单例Bean。</li><li>earlySingletonObjects，完成实例化，但是还未进行属性注入及初始化的对象。</li><li>singletonFactories，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象。</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">finalBean</span> <span class="operator">=</span> bean;</span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, beanDefinition, finalBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第三级缓存就是坚决循环依赖问题的关键，而这个方法也是解决循环依赖的关键所在，这段代码发生在doCreateBean()方法中createBeanInstance之后，也就是说单例对象此时已经被实例化出来了。这个对象已经被生产出来了，虽然还未设置属性等其他操作，但是已经能被认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来，可以进行使用（此时为依赖注入）。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>当A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，这种情况就为循环依赖。A首先完成了创建的第一步（完成实例化），并且将自己提前曝光到singletonFactories中，此时进行创建的第二步（属性注入），发现自己依赖对象B，此时就尝试去getBean(B)，发现B还没有被create，所以走createBean(B)的流程，B在创建第一步的时候发现自己依赖了对象A，于是尝试getBean(A)，尝试查询一级缓存singletonObjects（肯定没有，因为A还没初始化完全），尝试查询二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象（即使A还没有初始化完全，但是因此解决了循环依赖的问题），B拿到A对象后顺利完成了创建过程，B完成创建后之后将自己放入到一级缓存singletonObjects中。此时返回A的创建流程中，A此时能拿到B的对象顺利完成自己的创建过程，最终A也完成了创建，将创建好的A添加到一级缓存singletonObjects中，而且需要说明的是，由于B拿到了A的对象引用，所以B现在持有的A对象也完成了最终的创建。<strong>简单来说，就是spring创造了一个循环依赖的结束点标识。</strong></p>]]></content>
    
    
    <summary type="html">通过对mini-spring代码的阅读，对IoC和AOP的原理有了进一步认识。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://yhxjs.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://yhxjs.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker和k8s的部署方案</title>
    <link href="https://yhxjs.github.io/2024/06/03/%E5%9F%BA%E4%BA%8EDocker%E5%92%8CK8s%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://yhxjs.github.io/2024/06/03/%E5%9F%BA%E4%BA%8EDocker%E5%92%8CK8s%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</id>
    <published>2024-06-03T14:59:16.000Z</published>
    <updated>2024-10-01T03:47:56.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于Docker和k8s的部署方案"><a href="#基于Docker和k8s的部署方案" class="headerlink" title="基于Docker和k8s的部署方案"></a>基于Docker和k8s的部署方案</h2><h3 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h3><h4 id="传统虚拟机"><a href="#传统虚拟机" class="headerlink" title="传统虚拟机"></a>传统虚拟机</h4><p>传统虚拟机泛指包含完整系统镜像，即带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里运行Ubuntu，就是一个普通文件，不需要了就删掉，对其他部分毫无影响。但带来的缺点显而易见，占用资源多，冗余步骤多，启动慢，为了解决上述缺点，容器应运而生。</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><h4 id="虚拟机与容器对比"><a href="#虚拟机与容器对比" class="headerlink" title="虚拟机与容器对比"></a>虚拟机与容器对比</h4><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程，而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便，镜像体积更小。每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>Docker借鉴了集装箱的概念。集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><ol><li><p>镜像</p><p>镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。相当于容器的“源代码“，Docker镜像文件类似于Java的类模板，而Docker容器实例类似于Java中new出来的实例对象。</p></li><li><p>容器</p><p>容器（Container）是独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以将容器看作是一个简易的Linux环境，包含内核、进程、用户、网络等一系列支持系统运行的部分。</p></li><li><p>仓库</p><p>仓库（Repository）是集中存放镜像文件的场所，可以把镜像发布到仓库中，需要的时候再从仓库中拉下来使用即可。</p><p>类似于Maven仓库，存放各种jar包的地方；github仓库，存放各种git项目的地方。</p><p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p><p>而喜闻乐见的需要国内镜像站才能稳定下载，如阿里云、清华源、中科大源等。</p></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Docker是一个Client-Server结构的系统，是一个松耦合架构，众多模块各司其职，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p>交互基本流程：</p><ol><li>用户使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client的请求。</li><li>Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li><li>Job的运行过程中，当需要容器镜像时，则从Docker Register中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。</li><li>当需要为Docker创建网络环境时，通过网络驱动Network driver创建并配置Docker容器网络环境。</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li><li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体容器进行的操作。</li></ol><h4 id="为什么快？"><a href="#为什么快？" class="headerlink" title="为什么快？"></a>为什么快？</h4><p>由于Docker不需要虚拟机实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会在效率上有明显优势。且Docker利用的是宿主机的内核，而不需要加载操作系统OS内核，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引导、加载操作系统内核返回等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个Docker容器只需要几秒钟。</p><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统叫UnionFS（联合文件系统），是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p><p>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含bootloader和kernel。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs(root file system)，在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p><p>Docker镜像层都是只读的，容器层是可写的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层”，”容器层”之下的都叫”镜像层”。所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。</p><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个基础类，自己再按需扩展。新镜像是从基础镜像一层一层叠加生成的，每安装一个软件，就在现有镜像的基础上增加一层。</p><h3 id="Docker简要使用"><a href="#Docker简要使用" class="headerlink" title="Docker简要使用"></a>Docker简要使用</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull 镜像名[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本地主机上的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建+启动容器</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明（常用）：</span><br><span class="line">--name=&quot;容器新名字&quot;：为容器指定一个名称</span><br><span class="line">-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)</span><br><span class="line">-i：以交互模式运行容器，通常与-t同时使用 </span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与-i同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class="line">-P: 随机端口映射，大写P</span><br><span class="line">-p: 指定端口映射，小写p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前所有正在运行的容器</span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">OPTIONS：</span><br><span class="line">-a: 列出当前所有正在运行的容器+历史上运行过的 </span><br><span class="line">-l：显示最近创建的容器</span><br><span class="line">-n：显示最近n个创建的容器</span><br><span class="line">-q：静默模式，只显示容器编号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器</span></span><br><span class="line">1、exit退出，容器停止</span><br><span class="line">2、ctrl+p+q退出，容器不停止</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已停止运行的容器</span></span><br><span class="line">docker start 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已停止的容器</span></span><br><span class="line">docker rm 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内运行的进程</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内部细节</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入正在运行的容器并以命令行交互</span></span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新进入</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure></div><blockquote><p>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止。</p><p>exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止。</p><p>一般来说，使用exec来进入终端。</p></blockquote><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝文件，可双向进行拷贝</span></span><br><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出容器</span></span><br><span class="line">docker export 容器ID &gt; 文件.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入容器</span></span><br><span class="line">docker import 文件.tar 镜像名[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射容器卷</span></span><br><span class="line">docker run -it -v /宿主机目录:/容器内目录</span><br><span class="line">默认为rw即读写，可:ro指定为只读，容器实例内部被限制，只能读取不能写。</span><br></pre></td></tr></table></figure></div><h4 id="Docker安装常规流程"><a href="#Docker安装常规流程" class="headerlink" title="Docker安装常规流程"></a>Docker安装常规流程</h4><p>以安装tomcat为例</p><ol><li><p>搜索镜像</p><p>docker search tomcat</p></li><li><p>拉取镜像</p><p>docker pull tomcat</p></li><li><p>查看镜像</p><p>docker images tomcat</p></li><li><p>启动容器</p><p>docker run -it -p 8080:8080 tomcat</p></li></ol><p>此时即可访问宿主机的8080端口，出现一只小猫。</p><blockquote><p>关于Docker网络，默认使用内部网桥来保证通信，一般无需修改，感兴趣的可前往官网查看教程。</p></blockquote><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>构建三步骤：</p><ol><li>编写DockerFile文件</li><li>docker build命令构建镜像</li><li>docker run运行容器实例</li></ol><p>构建大致流程：</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker在基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令执行完成</li></ol><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p><p>Dockerfile是软件的原材料</p><p>Docker镜像是软件的交付品</p><p>Docker容器则可以认为是软件镜像的运行态，即依照镜像运行的容器实例</p><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><h4 id="常用保留字指令"><a href="#常用保留字指令" class="headerlink" title="常用保留字指令"></a>常用保留字指令</h4><ol><li><p>FROM</p><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是FROM。</p></li><li><p>MANINTAINER</p><p>镜像维护者的姓名和邮箱地址。</p></li><li><p>Run</p><p>容器构建时需要运行的命令。</p><p>两种格式：</p><p>shell格式</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure></div><p>exec格式</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br></pre></td></tr></table></figure></div></li><li><p>EXPOSE</p><p>当前容器对外暴露出的端口。</p></li><li><p>WORKDIR</p><p>指定在创建容器后，终端默认登录后进来的工作目录。</p></li><li><p>USER</p><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root。</p></li><li><p>ENV</p><p>用来在构建镜像过程中设置环境变量。</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_PATH /usr/java</span><br><span class="line">这个环境变量可以在后续的任何<span class="keyword">RUN</span><span class="language-bash">指令中使用，这就如同在命令前面指定了环境变量前缀一样</span></span><br><span class="line">也可以在其它指令中直接使用这些环境变量</span><br><span class="line">比如：<span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MY_PATH</span></span></span><br></pre></td></tr></table></figure></div></li><li><p>ADD</p><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包。</p></li><li><p>COPY</p><p>类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件&#x2F;目录复制到新的一层镜像内的&lt;目标路径&gt;位置。</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src dest</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;dest&quot;</span>]</span></span><br></pre></td></tr></table></figure></div></li><li><p>VOLUME</p><p>容器数据卷，用于数据保存和持久化的工作。</p></li><li><p>CMD</p><p>指定容器启动后要干的事情。</p><blockquote><p>Dockerfile中可以有多个CMD指令，但是只有最后一个生效，CMD会被docker run之后的参数替换。</p></blockquote><p>与RUN的区别</p><p>CMD在docker run时运行；RUN在docker build时运行。</p></li><li><p>ENTRYPOINT</p><p>指定一个容器启动时要运行的命令。</p><p>类似于CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</p><p>可以和CMD组合使用，如下：</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>] <span class="comment">#定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment">#变参</span></span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>Docker命令</th><th>实际命令</th></tr></thead><tbody><tr><td>docker run nginx:test</td><td>nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td></tr><tr><td>docker run nginx:test -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td><td>nginx -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td></tr></tbody></table><blockquote><p>与CMD相同，如果存在多个ENTRYPOINT指令，仅最后一个生效。</p></blockquote></li></ol><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./Dockerfile.png"                      width="500px" height="auto" alt="Dockerfile"                ><figcaption>Dockerfile</figcaption></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>打包jdk到镜像中</p><h5 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h5><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像维护者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> yhxjs@****.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置初始路径</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/java</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行必要操作</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get -y install vim net-tools</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /usr/java/jdk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加jdk到容器中，安装包必须要和Dockerfile文件在同一位置 </span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-17_linux-x64_bin.tar.gz /usr/java/jdk/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk/jdk-<span class="number">17.0</span>.<span class="number">4.1</span></span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME /usr/java/jdk/jdk-<span class="number">17.0</span>.<span class="number">4.1</span></span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露80端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Java版本</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-version&quot;</span>]</span></span><br></pre></td></tr></table></figure></div><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myjava:0.1 .</span><br></pre></td></tr></table></figure></div><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it myjava:0.1</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">基于kubernetes构建Docker集群。</summary>
    
    
    
    <category term="运维" scheme="https://yhxjs.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="https://yhxjs.github.io/tags/Docker/"/>
    
    <category term="k8s" scheme="https://yhxjs.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>再识MyBatis-Plus</title>
    <link href="https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/"/>
    <id>https://yhxjs.github.io/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/</id>
    <published>2024-03-23T09:42:21.000Z</published>
    <updated>2024-04-14T14:01:27.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本人之前学习过 MyBatis-Plus，但实际自己开发还是用的 MyBatis，基本就是简单 sql，因此用注解进行开发，手写 sql 也还好，故并未采用 MyBatis-Plus进行开发，但新入职的公司需要用到，于是进行重温，才有了这篇简略的记录。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正如<a class="link"   href="https://mybatis.plus/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>所说的愿景：成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。MyBatis-Plus 相当于 MyBatis 的增强版插件，可以一起使用，事半功倍，省去编写简单 sql 的功夫，具体介绍可自行去官网查看。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ol><li><p>@TableName</p><p>标识实体类对应的数据库表。</p></li><li><p>@TableId</p><p>标识主键属性。</p></li><li><p>@TableField</p><p>标识对应数据库字段。</p></li><li><p>@TableLogic</p><p>标识删除类型。</p></li></ol><h3 id="基本crud"><a href="#基本crud" class="headerlink" title="基本crud"></a>基本crud</h3><p>所有的基本 crud 都在 BaseMapper 接口中定义，只需要继承并指定具体实体类即可。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>BaseMapper 接口如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 更新</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity)</span>;</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 批量查询</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询一条数据</span></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询记录总数</span></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">selectPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">selectMapsPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;奕凰轩祭侍&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">userMapper.insert(user);</span><br><span class="line"><span class="comment">// 获取插入数据的主键 ID</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> user.getId();</span><br></pre></td></tr></table></figure></div><p>一般使用@TableId(type &#x3D; IdType.AUTO)来指定数据库主键，然后数据库还存在另外一个唯一标识符，一般由后端进行UUID或者雪花算法生成，该标识符相当于业务中使用的主键。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">10059249854L</span>); <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><p>根据主键删除，也可以直接传入对象，会根据标识的主键属性进行删除，以及可以根据其他条件删除，条件构造在<a href="#%E6%9F%A5">查询</a>中介绍。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">10059249854L</span>);</span><br><span class="line">user.setGender(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 实际执行的 SQL : UPDATE user SET gender=1 WHERE id=10059249854;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.updateById(user);  <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>在使用前需要进行 sql 条件语句的构建，有三种条件构建格式：</p><ol><li>常规条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapperr&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapperr</span>&lt;User&gt;();</span><br><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//今年刚满18岁~</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>lamda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lambda().eq(User::getName,<span class="string">&quot;劳大&quot;</span>); <span class="comment">//see you again（</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>lambda格式条件构建格式</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lt(User::getPlay, <span class="string">&quot;Genshin Impact&quot;</span>); <span class="comment">//原神启动！</span></span><br></pre></td></tr></table></figure></div><h5 id="常见的单条件查询"><a href="#常见的单条件查询" class="headerlink" title="常见的单条件查询"></a>常见的单条件查询</h5><h6 id="lt匹配"><a href="#lt匹配" class="headerlink" title="lt匹配"></a>lt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="le匹配"><a href="#le匹配" class="headerlink" title="le匹配"></a>le匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.le(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="eq匹配"><a href="#eq匹配" class="headerlink" title="eq匹配"></a>eq匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//等同于=18</span></span><br></pre></td></tr></table></figure></div><h6 id="gt匹配"><a href="#gt匹配" class="headerlink" title="gt匹配"></a>gt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;18</span></span><br></pre></td></tr></table></figure></div><h6 id="ge匹配"><a href="#ge匹配" class="headerlink" title="ge匹配"></a>ge匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ge(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;=18</span></span><br></pre></td></tr></table></figure></div><h6 id="ne匹配"><a href="#ne匹配" class="headerlink" title="ne匹配"></a>ne匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.ne(User::getAge,<span class="number">18</span>); <span class="comment">//等同于!=18</span></span><br></pre></td></tr></table></figure></div><h6 id="between匹配"><a href="#between匹配" class="headerlink" title="between匹配"></a>between匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.between(User::getAge, <span class="number">17</span>, <span class="number">19</span>); <span class="comment">//等同于&gt;=17 &amp;&amp; &lt;= 19</span></span><br></pre></td></tr></table></figure></div><h6 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a>like匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.likeLeft(User::getName, <span class="string">&quot;奕&quot;</span>); <span class="comment">//相当于like %奕，还有like对应like %奕%、likeRight对应like 奕%</span></span><br></pre></td></tr></table></figure></div><p>还有其他的一些条件，例如orderByAsc对应升序等，具体可以自己操作看看。</p><h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>且</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">17</span>).lt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><p>或</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">17</span>).or().gt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div><h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h5><p>可以通过 condition 参数动态拼接条件，例如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.gt(minAge != <span class="literal">null</span>, User::getAge, minAge);</span><br><span class="line">userWrapper.lt(maxAge != <span class="literal">null</span>, User::getAge, maxAge);</span><br></pre></td></tr></table></figure></div><h5 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h5><h6 id="查询部分属性"><a href="#查询部分属性" class="headerlink" title="查询部分属性"></a>查询部分属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(User::getName, User::getAge);</span><br></pre></td></tr></table></figure></div><h6 id="查询未定义属性"><a href="#查询未定义属性" class="headerlink" title="查询未定义属性"></a>查询未定义属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userWrapper.select(<span class="string">&quot;count(*) as count&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">   .groupBy(<span class="string">&quot;age&quot;</span>)  <span class="comment">//分组字段</span></span><br><span class="line">           .having(<span class="string">&quot;COUNT(*)&gt;5&quot;</span>); <span class="comment">// 添加having筛选条件</span></span><br></pre></td></tr></table></figure></div><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子查询 select id from user where id &lt;= 10059249854</span></span><br><span class="line">userWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 10059249854&quot;</span>);</span><br><span class="line">userWrapper.select(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">userWrapper.last(<span class="string">&quot;LIMIT 10&quot;</span>);</span><br><span class="line"><span class="comment">// 实际执行 SQL : SELECT name,age FROM user WHERE (id IN (select id from user where id &lt;= 10059249854)) LIMIT 10;</span></span><br></pre></td></tr></table></figure></div><blockquote><p>ps:然而调到了另一个小组，没用到（</p></blockquote>]]></content>
    
    
    <summary type="html">最终还是拥抱了MyBatis-Plus。</summary>
    
    
    
    <category term="后端" scheme="https://yhxjs.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://yhxjs.github.io/tags/Java/"/>
    
    <category term="MyBatis-Plus" scheme="https://yhxjs.github.io/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>ND协议</title>
    <link href="https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yhxjs.github.io/2024/03/06/ND%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-03-06T04:35:35.000Z</published>
    <updated>2024-03-06T09:40:42.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</p><p>什么是邻居？即一个链路上的相邻主机或者路由器，主机与主机，主机和路由器，路由器和路由器可以互为邻居。</p><p>地址解析放在ICMP层，通过使用ICMPv6报文实现功能。</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format.png"                      width="400px" height="auto" alt="IPv6报头格式"                ><figcaption>IPv6报头格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_packet_head_format_wireshark.png"                      width="550px" height="auto" alt="IPv6报头(Wireshark)"                ><figcaption>IPv6报头(Wireshark)</figcaption></figure><p><strong>版本号</strong>(version)：同IPv4，指示IP版本</p><p><strong>流量等级</strong>(Traffic Class)：类似IPv4中的TOS字段，指示IPv6数据流通信类别或优先级</p><p><strong>流标签</strong>（FlowLabel)：标记需要特殊处理的数据流，用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据</p><p><strong>传输数据长度</strong>(Payload Length)：包含有效载荷数据的IPv6报文总长度</p><p><strong>下一个报头</strong>(Next Header)：该字段定义了紧跟在IPv6报头后面的第一个扩展报头(如果存在)的类型，或者上层协议数据单元中的协议类型</p><p><strong>跳限制</strong>(Hop Limit)：类似于IPv4中的TTL字段，它定义了IP数据包所能经过路由器的最大跳数</p><p><strong>源地址</strong>(Source Address)：128bit的IPv6地址</p><p><strong>目的地址</strong>(Destination Address)：128bit的IPv6地址</p><h4 id="与IPv4对比"><a href="#与IPv4对比" class="headerlink" title="与IPv4对比"></a>与IPv4对比</h4><p><strong>IPv6报头结构的改善</strong>：基本的IPv4报头长度为20个字节，基本的IPv6报头长度为40个字节</p><p><strong>取消了IP的校验</strong>：由于2层与4层的校验已经足够健壮，取消了IP的三层校验</p><p><strong>取消中间节点的分片功能</strong>：分片重组功能由源端实现，通过Path MTU机制来发现路径MTU</p><p><strong>定义最长的IPv6报头</strong>：有利于硬件的快速处理，中间节点节约大量资源</p><p><strong>安全选项的支持</strong>：IPv6提供了对IPsec的完美支持，上层协议省去大量安全选项，例如OSPFv3取消了认证</p><p><strong>增加流标签</strong>：提高QoS效率</p><h3 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h3><p>邻居发现协议定义了五种不同的ICMP包类型：路由请求RS（Router Solicitation）和路由告知RA（ Router Advertisement）消息，邻居请求NS（Neighbor Solicitation）和邻居告知NA（Neighbor Advertisements）消息，以及重定向（Redirect message）消息。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_packet_type.png"                      width="450px" height="auto" alt="ND协议报文类型"                ><figcaption>ND协议报文类型</figcaption></figure><h4 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h4><p>当一个接口变为可用时，主机可以发出路由请求消息来要求路由器马上生成路由告知（ Router Advertisement）消息，而不是等它的下一个固定生成时间。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./rs_packet_format.png"                      width="500px" height="auto" alt="RS报文格式"                ><figcaption>RS报文格式</figcaption></figure><p>源地址：接口的地址或者全0</p><p>目的地址：全部路由器组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：133</p><p>ICMP6 CODE：0</p><h4 id="路由告知"><a href="#路由告知" class="headerlink" title="路由告知"></a>路由告知</h4><p>路由器周期地用此消息通告它们的存在及各种链路参数和互联网参数，或响应Router Solicitation消息。Router Advertisements包括前缀，这些前缀用于确定是否另一个地址共享相同链路(on-link确认)和&#x2F;或地址配置，建议的跳数限制值，等等。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ra_packet_format.png"                      width="500px" height="auto" alt="RA报文格式"                ><figcaption>RA报文格式</figcaption></figure><p><strong>当前跳数值</strong>（Current Hop Limit）字段，用法如下：链路上的结点发送IPv6报文时，会用该字段的值来填充IPv6报文头的跳数限制字段。如果该字段值为0，说明路由器并不确定该值为多少。</p><p><strong>M位</strong>被称为管理地址配置（Managed Address Configuration）标志位，当该位被置1时，说明DHCPv6可用于结点地址配置。</p><p><strong>O位</strong>被称为其它有状态配置（Other Stateful Configuration）标志位，当该位被置1时，说明DHCPv6可用于获得非地址相关的配置信息，如DNS名称服务器的IPv6地址。</p><p><strong>路由器生命期</strong>字段是一个16位无符号数，计量单位为秒，它指示链路上的结点把该路由器做为默认路由器的时间为多长，最大值为18.2小时。该字段为0表示发送该报文的路由器不做为默认路由器，这时，结点在发送报文时，不会选择该路由器做为下一跳路由器。</p><p><strong>可达时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在收到一个邻居可达的确认报文后，认为该邻居仍然可达的时间。在这段时间内，如果结点没有再收到邻居可达的确认报文，结点会执行邻居不可达检测以确认邻居是否可达。该字段为0表示路由器不指定该参数。</p><p><strong>重传时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在执行邻居不可达检测或者地址解析时，连续发送邻居请求报文中间的时间间隔。该字段为0表示路由器不指定该参数。</p><p><strong>前缀</strong>选项，通过该选项，路由器向链路上通告本链路所有可达的前缀，并且通过标志位指出哪些前缀可用于结点的地址自动配置。</p><p>源地址：接口的本地链路地址</p><p>目的地址：发送路由器请求的主机的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：134</p><p>ICMP6 CODE：0</p><h4 id="邻居请求"><a href="#邻居请求" class="headerlink" title="邻居请求"></a>邻居请求</h4><p>节点发送该消息以确定某个邻居的链路层地址，或者用来验证通过缓存里的链路层地址是否依然能够到达该邻居。也经常用来做地址重复检测。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ns_packet_format.png"                      width="500px" height="auto" alt="NS报文格式"                ><figcaption>NS报文格式</figcaption></figure><p><strong>目标地址</strong>字段是一个IPv6地址，一般与目的地址相同，填的是请求的地址，该字段不能是多播地址。</p><p><strong>源链路层地址</strong>选项，协议建议携带，一般为源MAC</p><p>源地址：接口的地址或者未指定地址</p><p>目的地址：目标地址或者目标地址对应的请求节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：135</p><p>ICMP6 CODE：0</p><h4 id="邻居告知"><a href="#邻居告知" class="headerlink" title="邻居告知"></a>邻居告知</h4><p>邻居请求消息的回应。节点也可以发送非请求的Neighbor Advertisements，通知链路层地址改变。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./na_packet_format.png"                      width="500px" height="auto" alt="NA报文格式"                ><figcaption>NA报文格式</figcaption></figure><p><strong>R位</strong>是路由器（IsRouter）标志位，当这个标志位置1时，说明发送者是路由器。</p><p><strong>S位</strong>是被请求（Solicited）标志位，当这个标志位置1时，说明发送者发送邻居通告报文是因为接收到一个邻居请求报文，这个邻居通告报文的目的地址是单播地址；如果邻居通告报文目的地址是多播地址，则该位置0。</p><p><strong>O位</strong>是覆盖（Override）标志位，当这个标志位置1时，接收到该报文的结点查看邻居缓存，如果缓存中有发送该邻居通告报文结点的链路层地址，则更新之。否则忽略该邻居通告报文。</p><p><strong>目标地址</strong>字段是一个IPv6地址，如果邻居通告报文是由邻居请求报文触发的，则该地址是邻居请求报文中的目标地址。如果邻居通告报文是因为链路层地址变化触发的，则该地址是和变化的链路层地址相关的IPv6地址。该字段不能包含一个多播地址。</p><p><strong>目标链路层地址</strong>选项。如果邻居通告报文目的地址是多播地址，必须包含目标链路层地址选项。</p><p>源地址：接口的地址</p><p>目的地址：发送邻居请求节点的源地址或者全部节点组播地址</p><p>跳数：255</p><p>ICMP6 TYPE：136</p><p>ICMP6 CODE：0</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>由路由器使用，用于通知主机有到目的地的较好的第一跳。路由器收到一个报文后，如果发现报文的目的地址和源地址是同一个链路的，或者到目的地址有一个更优的路由器，都会发送重定向报文。重定向报文的源地址必须使用链路本地地址。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./redirect_packet_format.png"                      width="500px" height="auto" alt="重定向报文格式"                ><figcaption>重定向报文格式</figcaption></figure><p><strong>重定向报文头</strong>选项包含了引发重定向报文的原始报文的内容。</p><p>源地址：接口的链路本地地址</p><p>目的地址：触发重定向的数据包的源地址</p><p>跳数：255</p><p>ICMP6 TYPE：137</p><p>ICMP6 CODE：0</p><blockquote><p>主机不能发送路由器通告，路由器不能发送路由器请求。</p><p>主机不能发送重定向报文，路由器不能处理重定向报文。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><a href="#%E8%A7%A3%E6%9E%90%E9%82%BB%E5%B1%85%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80">解析邻居的链路层地址</a></li><li><a href="#%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%EF%BC%88DAD%EF%BC%89">地址冲突检测（DAD）</a></li><li><a href="#%E9%82%BB%E5%B1%85%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%A3%80%E6%B5%8B%EF%BC%88NUD%EF%BC%89">邻居不可达检测（NUD）</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E5%89%8D%E7%BC%80%E5%8F%91%E7%8E%B0">路由器和前缀发现</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91">路由重定向</a></li></ul><h3 id="解析邻居的链路层地址"><a href="#解析邻居的链路层地址" class="headerlink" title="解析邻居的链路层地址"></a>解析邻居的链路层地址</h3><p>IPv6取消ARP协议，通过邻居请求（NS）和邻居通告（NA）报文来解析三层地址对应的链路层地址。</p><p>邻居请求NS使用组播，比ARP效率高，邻居公告NA返回则直接使用单播。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_address_resolution.png"                      width="650px" height="auto" alt="IPv6地址解析"                ><figcaption>IPv6地址解析</figcaption></figure><p>一整个ping的过程跟ARP一样相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./ipv6_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show ipv6 nd-packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_ipv6_nd_packet_history.png"                      width="100%" height="auto" alt="show ipv6 nd-packet history"                ><figcaption>show ipv6 nd-packet history</figcaption></figure><h3 id="地址冲突检测（DAD）"><a href="#地址冲突检测（DAD）" class="headerlink" title="地址冲突检测（DAD）"></a>地址冲突检测（DAD）</h3><p>DAD首先发送源地址为未分配地址，目的地址为要进行DAD检测的地址所对应被请求节点的组播地址，然后目标IP携带要进行DAD检测的地址的NS报文，若有冲突，则被请求节点发送源地址为DAD检测的地址，目的地址为全局组播地址，并目标IP携带DAD检测的地址，以及源链路层选项附上自己的链路层地址的NA报文。</p><h3 id="邻居不可达检测（NUD）"><a href="#邻居不可达检测（NUD）" class="headerlink" title="邻居不可达检测（NUD）"></a>邻居不可达检测（NUD）</h3><p>NUD首先发送源地址为接口的链路本地地址，目的地址为要进行NUD检测的单播地址，然后目标IP携带要进行NUD检测的单播地址的NS报文，若可达，则被请求节点发送源地址为NUD检测的地址，目的地址为NS的源地址，并目标IP携带NUD检测的地址，并将S位置为1的NA报文。</p><h3 id="路由器和前缀发现"><a href="#路由器和前缀发现" class="headerlink" title="路由器和前缀发现"></a>路由器和前缀发现</h3><p>当主机未配置单播地址时，就会发送RS，路由器和本地链路节点会发送RA，以使主机进行自动地址配置。</p><p>当主机接收到RA后，使用其中的前缀信息和本地接口ID自动形成IPV6地址，还可根据其中的路由器信息设置默认路由器。</p><p>RS可定位邻居路由器，同时学习和自动配置有关的前缀和配置参数。</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>假设链路上一个结点发送一个报文，源地址是A，目的地址是B，路由器收到该报文后，发送一个重定向报文，重定向报文中目标地址字段是C，该地址是告诉结点更好的下一跳地址，目的地址字段是B，该地址是结点发出去报文的目的地址，和上面的B是同一个地址。如果C和B不同，说明C地址是一个更优的路由器地址，如果C和B相同，说明B地址是同一个链路上结点的地址。</p><h2 id="表项状态"><a href="#表项状态" class="headerlink" title="表项状态"></a>表项状态</h2><p>ND表项有五种状态：</p><p><strong>INCOMPLETE</strong>（未完成的）地址解析在进行中，邻居的链路层地址还没有被确定。</p><p><strong>REACHABLE</strong>（可到达的）粗略讲，已知邻居最近(几十秒前)是可达的。</p><p><strong>STALE</strong>（陈旧的）邻居不再被认为是可达的，但是直到流量发送给该邻居时，不应当尝试改变它的可达性。</p><p><strong>DELAY</strong>（延时）邻居不再被认为是可达的，最近流量已经发送到该邻居。然而，不立即探测该邻居的可达性，延时一段时间发送探测消息，以便给上层协议一个机会提供可达性确认。</p><p><strong>PROBE</strong>（探测）邻居不再被认为是可达的，并且发送了单播NS探测消息以便验证可达性。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./nd_entry_state.png"                      width="700px" height="auto" alt="ND表项状态机"                ><figcaption>ND表项状态机</figcaption></figure><p><strong>EMPTY</strong>状态代表邻居表项不存在或者被删除。发送IPv6报文时，如果下一跳不在邻居表中，那么创建一条状态为INCOMPLETE的邻居表项，发送多播邻居请求报文，每隔1秒钟发一次，连发3次，直到收到应答为止。如果连发3次邻居请求报文都没有收到应答，那么删除邻居表项。如果收到应答，邻居表项的状态迁移到REACHABLE。</p><p><strong>REACHABLE</strong>状态的持续时间缺省值是30秒，即在30秒钟内认为邻居可到达，30秒以后，迁移到STALE状态。如果在REACHABLE状态，收到邻居请求或者公告，发现MAC地址变化了，表项迁移到STALE状态。</p><p>处于<strong>STALE</strong>状态，如果发送报文时命中这条邻居表项，那么迁移到DELAY状态，准备进行邻居不可达检测。对于STALE状态的持续时间，RFC没有规定。</p><p>处于<strong>DELAY</strong>状态，5秒钟以后进入PROBE状态。</p><p>处于<strong>PROBE</strong>状态，开始进行邻居不可达检测，发单播邻居请求，每秒发一次，连发3次，直到收到应答为止。如果收到应答，迁移到REACHABLE状态。如果连发3次仍然没有收到应答，就认为邻居不可达，删除邻居表项。</p><p>收到邻居请求，创建新的邻居表项，状态必须是STALE，因为收到邻居请求只能证明对方发送的报文可到达自己，而不能确定自己发送的报文能到达对方。</p><p>在进行邻居不可达检测时，结点发送的邻居请求报文可以包含源链路层地址选项，也可以不包含。如果邻居请求报文中没有包含源链路层地址选项。接收结点在发送邻居通告报文时，可能还需要执行地址解析操作。所以RFC2461建议邻居请求报文发送者包含源链路层地址选项。</p>]]></content>
    
    
    <summary type="html">邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</summary>
    
    
    
    <category term="通信" scheme="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="通信" scheme="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
    <category term="ND" scheme="https://yhxjs.github.io/tags/ND/"/>
    
  </entry>
  
  <entry>
    <title>ARP协议</title>
    <link href="https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yhxjs.github.io/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-03-05T13:11:28.000Z</published>
    <updated>2024-03-06T09:37:46.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARP即地址解析协议，将IP地址解析为MAC地址。数据要在以太网中传输，需要完成以太网封装，这项工作由网络层负责。要完成以太网的数据封装，需要知道目的设备的MAC地址。</p><p>注意：ARP报文不能穿越路由器，不能被转发到其他广播域</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format.png"                      width="400px" height="auto" alt="ARP报文格式"                ><figcaption>ARP报文格式</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_format_wireshark.png"                      width="450px" height="auto" alt="ARP报文格式(Wireshark)"                ><figcaption>ARP报文格式(Wireshark)</figcaption></figure><p><strong>硬件类型</strong>：表示硬件地址的类型（其中，值为1表示以太网地址，其他还可能表示令牌环地址）。</p><p><strong>协议类型</strong>：表示要映射的协议地址类型（其中，0x0800表示IP地址，其他还可能是ICMP&#x2F;IGMP）。</p><p><strong>硬件地址长度</strong>：指出该报文中硬件地址的长度（ARP报文中，它的值为6）。</p><p><strong>协议地址长度</strong>：指出该报文中协议地址的长度（ARP报文中，它的值为4）。</p><p><strong>op</strong>：操作字段，共有4种类型（1.ARP请求，2.ARP应答，3.RARP请求，4.RARP应答）。</p><p><strong>源MAC地址</strong>：发送方设备的硬件地址。</p><p><strong>源IP地址</strong>：发送方设备的IP地址。</p><p><strong>目的MAC地址</strong>：接收方设备的硬件地址。</p><p><strong>目的IP地址</strong>：接收方设备的IP地址。</p><p>ARP报文解析主要关心的是后五个字段。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_workflow.png"                      width="450px" height="auto" alt="ARP工作流程"                ><figcaption>ARP工作流程</figcaption></figure><ol><li>先查看ARP表，如果ARP表中没有目的IP地址对应的MAC表项，则发送ARP请求包</li><li>源主机广播发送ARP request 数据包，请求目的主机的MAC地址</li><li>同网段内的所有主机都能收到ARP request请求包，但只有目的主机才会回复ARP reply数据包</li><li>源主机收到ARP reply后，将目的主句的IP-MAC对应关系添加进ARP表中，完成数据的以太网封装，进行数据交互</li></ol><p>通过Wireshark抓包可以看到整个过程。</p><p>IP为192.168.56.105的主机A广播目的IP为192.168.56.1的ARP请求，当IP为192.168.56.1的主机B收到该请求后，应答自己的MAC地址给主机A：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_request_wireshark.png"                      width="450px" height="auto" alt="ARP请求(Wireshark)"                ><figcaption>ARP请求(Wireshark)</figcaption></figure><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_reply_wireshark.png"                      width="450px" height="auto" alt="ARP应答(Wireshark)"                ><figcaption>ARP应答(Wireshark)</figcaption></figure><p>而一整个ping的过程相当于两个来回：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_ping_wireshark.png"                      width="800px" height="auto" alt="ping(Wireshark)"                ><figcaption>ping(Wireshark)</figcaption></figure><p>通过我开发的show arp packet history命令也可以看到整个过程：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./show_arp_packet_history.png"                      width="100%" height="auto" alt="show arp packet history"                ><figcaption>show arp packet history</figcaption></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table><thead><tr><th>类别</th><th>含义</th><th>作用</th><th>属性</th></tr></thead><tbody><tr><td>静态</td><td>手动配置（优先级高）、认证下发</td><td></td><td>永久、表项不更新</td></tr><tr><td>动态</td><td>通过报文学得</td><td></td><td>老化、表项更新</td></tr><tr><td>可信任</td><td>客户端认证时候，会在网关交换机上添加arp，该arp是真实有效的</td><td>位于交换机端ARP表项中，防止ARP欺骗</td><td>具有静、动态属性</td></tr><tr><td>免费</td><td>源、目的IP都是自己的广播arp报文</td><td>IP地址冲突检测、MAC地址变化通知其他设备</td><td>可以定时发送免费ARP，若无IP冲突不能应答</td></tr><tr><td>代理</td><td>源目的不属于同一网段，设备知道目的ip的路由信息时，则进行代替arp响应</td><td></td><td></td></tr><tr><td>本地代理</td><td>以网关自身的MAC回应本网段的IP地址的ARP请求</td><td>用于二层端口隔离时，主机先获取网关的mac，之后在网关设备上报文会被上送三层，通过三层路由实现同一网段内主机通讯</td><td></td></tr><tr><td>any ip</td><td>任意IP地址都可以上网，ARP请求的源IP和设备不在同网段，且目的IP可能不是自己，但网关仍然发送ARP应答，并且为主机的IP地址生成直连路由</td><td>场景：无需修改IP与网关即可正常上网，例如网吧、酒店等地方</td><td></td></tr><tr><td>探测</td><td>源IP为0，目的IP为待探测地址</td><td>收到应答则说明该IP被使用</td><td></td></tr></tbody></table><h2 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h2><p>首先底层对报文进行处理，将二进制报文转化为可处理的格式，然后交由控制层进行处理。</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./arp_packet_processing.png"                      width="300px" height="auto" alt="ARP报文处理逻辑"                ><figcaption>ARP报文处理逻辑</figcaption></figure><ol><li><p>操作码op，源接口和二层接口协议状态，格式检查，MAC合法性，IP合法性，免费ARP检查，ACL检查等，经过上述一系列检查后，源IP和目的IP都不为0，且都是合法的。</p></li><li><p>判断源IP和源接口是否处于同一网段，主要区分就是VRRP的虚IP和开启了any-ip-arp要进行特殊处理，经过判断后，如果是同一网段就进行处理，否则就丢弃即忽略。只要源IP和本机IP是一致的，都认为IP地址冲突，查看源MAC和源接口的MAC是否相同，如若相同，则说明是自己发的，不进行处理，否则进行冲突应答。如果目的IP为本机IP，判断是否是发给自己的，如果是则继续进行处理，否则进行相关的代理。</p></li><li><p>普通处理</p><p>处理request报文：</p><ol><li><p>目的地址是我们的IP，则不更新表项，只应答。</p></li><li><p>目的地址不是我们的IP，则不应答。</p></li><li><p>如果MAC地址不一样，需要代理冲突应答，并走老化逻辑。</p></li></ol><p>处理reply报文：如果源IP匹配到了表项或者开启了某种学习才进行表项的学习更新。</p></li></ol>]]></content>
    
    
    <summary type="html">ARP即地址解析协议，将IP地址解析为MAC地址。</summary>
    
    
    
    <category term="通信" scheme="https://yhxjs.github.io/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="ARP" scheme="https://yhxjs.github.io/tags/ARP/"/>
    
    <category term="通信" scheme="https://yhxjs.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>学习路线</title>
    <link href="https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://yhxjs.github.io/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2024-03-03T10:39:23.000Z</published>
    <updated>2024-10-02T15:40:20.903Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重新输入。" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="dcdbaa2fec1f799cea29b2380eca655ef29bcfc1415171c76851cb6dfd97cf9c">7e302a64c19ca2d3ce010e4131597270786b1bb1aaf244198f42d692eb66feb4bc070be16da0a052557145b88b06a7387e3029ffbbbb6130fe0a097cb8511ca043a3a1ac49a1c8d6e3209fbd33f4b5ec808511bbbcbf9eed5db3d988448945fdaf4926c793654b80518ba075a6b012b2b528ba26ffb32b6aa542d403457d3f99e138490ec2452377bb9d0aa0876d21a39ad74194eaaae82bac2f29811278064ba1ad8d323242753fcec2d647caf57e8c68a1631c6ea4b6795455aa5bddb4a7a5a6984c24e714e3a1d4b6a1f5b40d103dff22152cb5767dc0a07e63d419d50e66a3bacd98da6b63001b6dca188b97684ded665fa39e575da0bb50467826e5ab6c4e9bc7c13e5ffd851a763e80e8888f1eb158ace8a3adae10e4952a59972ded7b629425a5ba52a89aa1eb7f33f9f7a05e2282c8dd2eebdff6cbc5ff68888ad769e483801c95580f6dd44181059e723b45f1fad1441331cea7c03cf97f53e7bbceb448a73794b615a27670c7f537a9c0a360483360caa5392103a0a8887c3638cb9e49ef68db8040d2bfba1151e13c678a03996de7eb7942afe332a110eac08fa47e6c6e0ac1170d4ede7d0cc4e3cfc361c8e7e46aa9772c81e54cc1b1860fd6d08f2eb449ec0070f9f3a8162522a544bab118fb9a3234c10d03c9fdef4589ca16f812d81e033618be3866d1dc6668f8a08cb1cd9cefc5c7f6dcfe027c736e704176c9c3f75175d7c8c0852104d043665cbe3e2aca512baaf852962b738a979e4a0c0aae312650f44bc3239b826102c17e1e9d7f63fe28418a2487b913515c15782cd7a799666617bb8c49f1f6b6f4e4c758a8ba1f52b017517a27f5824b06817b4c24374441f553427fc8caf213d20e780d69ca47bc27a799bff3d895b50b5dc1a9773881963fa87203c2d78abed04f544dd4302843677e7e3fefac05e85f4879404a1fae894d13a6ca799b0b6e2c9f6222c7973239865cf5f59d645d62349f8645c2e852d24366c5149903c8042effb49e3b513f7138905e63070c65e09036604217472a4e1b29e6f6fe3e4b5c6ec873275af907d941e05fea1c9a009519b4b22d60c43f7661efea590b5a85170908fde78956f72a07c619eab9211dc2b2c7deb69fb6924b659d0e9e620f264c67af600828e4f3271a017f36249688ef1c45fcb2e0ad046ea84df8b3453e599365a3ed4a2d3123e88c84d23fb5d252bffb78ce4f7743912face06c5f0509b96c59f7ab815c00c5c7ff19d4edf909f0797610aacd54e12819bd04e9322ab69c9c0a969191ada2d3926f588e7ad54cd323632033cbec7c345891d53cf2c7dd566a888fbff271258b42f01cfaef3b87d6b660a928889bddbcede75e86cc0b28e8a7e5f8cfbfb75743436c86a48116ca0a24126bcd4790114ad22f2254d4f54ae663437574bcbd53a3a7a81dc066e2b37601836679b9eb5bf061368d82d99fd3ec79037eb24bcaf6130d7eedb69eef6fc0d3a3bcf197f4d243a61f272407c7399a446da734325a3d057459ae9b486045bd55d2d5e3c50c2aca45f13257a3d916dec48ce80382f53e5295a691c4842c74b02407228849e96782179788918da40ef252656db9e7c524ba793e5965dbcfb4a8e8e0d5d3a3fc0e155f5ff2b3debbf4f0d261bf6c61e251e28f068d212722aca95a476410f12aa2580dfbb0ef0163532a61925506e645da8dc4cd5ae960ccbd8bd05094ba81016a3ee4181bd7c383e0b5bd573e5eef0ef546b1a0846af0c6b3b583a2cbad7dcf7aabc61a27bd36aa997a1c4508ebcfec0459960cfc35bc55477158a0923d1e79fd04e5414b6e219df9727d7030a2b05c37243264470b9c491b71b840c499d06d4ff19232b800579722d0fb8c281df6b5a54e4b0fe252fecc5c3dd081da3fcdb629c8d4f274d003155890883791c1b6e731ea0bd2f297cde53a49d1aea1233a39103cab73d3454e3a6ae70a310d6be786d4d9dc40d2b7d74bffec2a76d3444fabf4309ea25fe6113f2b771125804c24394966bfc50ab206519ba84bbccefcb715d69a020651fe01f797486c12c54405bb0ca40a50a7b193e5e3617178d982d35370517af59205004ae784934c108fba3568433b7eaaf184fef2a88342af90a2cf1f92d5f78b293e5044b47d4e064ff496a05714e531619477eb38953faed1ea67380fa73df0afec0e415978d1afa6b9a2fb952575a197bb86351946df3965dd858bdbc55ff067b26c252dc7cc13fcd3f3206f82ce231f5970e43aa65dc9c53cefd494b30776d9128fdbdc9eec0f969d53b2905a47a92e4e19ad224b7ab950344043c6d53cdaec9e739a4968d6d86f2c833d283d9fb88ce043fb203fbb7bbea6c9db3683efaf2426a8847df5730c920a637f4f324bf7dfefa70f7096fd9fbc0481ca5fc0b5b89d0b605c428ebe71d1c59c06620670f316d0c9e90fa6e29006446d2b3af79fc84ff604c4192db8548f1c2373bbd401ea9b3153195a0bf7a6e2858ecbacbec605fe763840d8eb1b899750e6064b890a362398871604d7b8bad7065e5cc6dc6c19d9ee8723161c7989723b315608bd4e2b37f9c7c44776d925f120c4cd1408a62dc8e57fce927789a09aa54e46875cd78f5af37720d890113b24e68a12d97da5f4a395a383b242e1570c31160f0a4c948c810dc59979d51971f90a6c5be91e7ef1abe178e25978a2a187872b6d0fb6086ec078a83111cb223f9f2843ecf636ef594c44c48409f8a9cc71d55d1c40266356c1b32f7e3753cfaa4670976b6f5245de0eaac54f9d8b4d36c166673749114159c186212d59f6f486141a314a43fd0153939a861ac8d09fcd911f0e6f006d019861f2e22f8a53ddbd7706982727fb759e7989250580a723d714e81c1772ebb0d74c5795d2a5d881724ae5a574e22402ad02097c64fad3d2f921f04799230cccc327c2a1c3979dc3a0b7e7f5c012b50e4607c6ba1f0efaef9abf57dd3053d6c95c5c8b9b49f6784e6f70ccc31a0a1f9d6002ae7a14a14e02f3b211c8c6188a581f42a17e0eae92f9d0c765ddcc2bb1aad1688ba5191cf950cbf4d77dcb61999aa0022cd6a3bbf8bb4660aaff9e03430937649f73b5f368e11a849fbd80cd243c2c5200e2c322c6864d4493db52ef92441e597bb691342c2ee2bde1d6c0d89658e6b5da26e2ef99817d58e607e4f685ddbf0ddb801d979412c4cdfaaf503e2ee4fc37067f0ae27c49af14680b9543e55d72e8b90de6e6690f23754f14fb13b4389dc98d3f90ec147219310ed97d939380fe496695aae506eba74131619cd4f4835b2396f7a5f7ea958a78362465a11a330af9ed23f2fdb160a78a90b40a3a24616dd0c3fcbc38cc3309483bb667e36bea412ff9b87e092b3f969c2d307be0bc91295b6590257be4dd82f8d984b8237f601f4248371f92a7be29caf3ae43861e1ee0b622c17e5db7eb710bb397d15e869cc3f2b80dad790d9593a7658236a7c08c4d0e205e84c6345228aa84d7342487c8411af7dc35283a7c1c388ab081ba1246242154c90e39d1cde511f20e0499a6822de5e851aa3fb901e259e512ef0c9f9c841fa459f54e74bd58359cfef4406427763a7f88dad64777df66c0cc6942bb6184089488d9a4b422d523f01964d403cf54725d49ba1ae7938c72d1ecdccf188dd0e6ad808f8de81ae37578f8339360ad9378fb5e2e24149eaf969836c5b35a5f6171f5dbf22d2b53a8279e945fbbed794eda5c92b3e7748f97162d9cb476ae1b516c9f637e1e2c31f0945301f41ffa01705670920e56719399f32b1f9cafd331673f68ab8d55edf28b0167f06d18a96bdd64243db44b935dbfe9a644b428b12186fa8bf4acfaabcb11a989d7ab62c3789074ebe442c131c2d8a82f328f87d6bdd17676ab16c8244400e740fddb58e7b9984432f976837f23244d8c34c84c0e22d9184e3feea47bd41fa78443f34683d1cb2653dc001da20b43b0a6865a4a550481752cf6d04666a5465b3c8ebe4a6f0a8818ccfd2610b5ebc9ca55bdeef887ff5c4352147ca8cfaea7639dbcf40edbc229ccffe0cc9d666b3cde15d7a3e2cc98bf32be412bb6fb5b07af5163abb9587e69ee296c0b943431bbd8a70e5ca213671a2beefc93ff915c1fa294a7221b43aa754dfe207f66144829b54225b78f0cdc5aa4dea708a55b7afa4e4ca8ff3d21a208c1ead06267d4e812ecdc88d502d389e2f3ec36d7b0df032e57161f5654b2f333cbb1c58442a23390807b8550b3ade2b7c388ad9195cda968573fea7d29bd9713bafec94f771cfbdde04aa3fb969203ff3bd931a13e1b135bd7cfcba26bcaa27a9b8fa07144904eca7e6b2b3915a67b96737d89b6852ec6b013d05a970127e85aee3890b711ee2125b9d26ec3ddf1ebeb82f34b058b4994d26004a005f15201e49cfde2d5e60bd04449f5b7b0ee4172c409a88dac97eafcd1a593fbe1c349ee3e539cdf60b2c108772ce28a28a81a427a969318c4968a4f673d4b0dc8fafa6e1b6988f0d91ec9ccb87e22f8f7ae7b3095c2658670407b6be7d8978eb629d788a2a89906493b1b25907e1d3b1ee350cb051ad1f8f7dd466cfd1c77594d475e32dba488a8082c223b5f26472e4b2100732180e1a8d5f78e335497715f4d198706d3d74e57545d224c0e12bc2c357c40b82f9225c3c6a5a7dfbc59081a9498179da23791071a4e952c06a3aa38d3161aa66ae42e5f96226215707eb66aa53621f835fa6381c900b91d1c9e3bedececa3b2cd21fb96205c769d1749db1a679c01d24fb12bb41d85ab83846e7c170a73fd6c9f58d6464f2904e1cd9b3275931996a77e3de350a721a7ff980cbe4e8344de99c8742cbd808a2c96664debae18f3c927a43fb9018d220d52500160de9fe276cf9e774524804ab2a09d00eb59849cc924bbf5bbe8b50710632fe15c53fde549bbff87943658cc002f02ee6b58276efc134d54da316d2fb7e5d3191ffd1cbe9f3ff430a15de9a603a277ac6f210a73b14a6c02dafd8777baa252928cae0352596371ce7dae21478d584f7d3b9f5e6d8cfa02589f6be72b4970e4e5a8b53d3832e68679c5bb0e74127c77ba17d30545ec51aa5636c465f6594890b7f7d57a10084492773783dacece151910f33e2663068a0e839a813516c4575ae1c5cf3b7ac245f6380c8b61554518175f0d4b2006ca52fb8140269596927c9364adda884a103b5595ff928fb770f0db84d40fcb16fa8a1b6ec4b88c9ab3c620fd61a0026de6d0bdd2beccff3121f2d75bbfb47bc95b8d70201f77a3ffa852d28152a139f1342857e15ed11cbd55e7a2454ac1dab1f3caedf0b033388c6109c28fd3161e63164616f654b5cc83455694793c47a00ec64300ed9015024174b255c1b24854334c7814ad38867b5f9d79e43b46b3a68da18f25314465d64cac31851062b8861910719fd2f23d1997ef4e4529ec998a2385112fa4fb17186d0056c4678d6dace5ead238ed884d1c8ae6da03f2b3e2f27a0e9632e1702d2f18479e40e4a670db8121bda27c9a3fb9e9415bc76efce05d538f8cd47c3df61525fea19b4f1cd6e309c2b8d018d36e690e85b326fc6268805b8fd21d5cebfe1438e901f1bdcd553da9f150d8bbf1b3a16e04c9982b2f3ca44a6131b356903bef1aea798eea535ff27082d554f98166516789c92fae85b583c6dbcde9f6bf740e6a66235463a151a6397701fb243532792b65b98885b0df85df3f58e93d4e86fe279adf3e85df002a5739853c9bcaa6f942a700cc3cf8b1df77a7bf15a880c073e7815b0cc67884295d086d035d97d9e821e424f923270165bcdfca1cc22d75b157a5c7fc02b50ed5f7520aa0051d614bc0d2a5653a08a5a89cd58e51066c9cb3fd0e1f299cf26c74906a9ef73a75c6c47a29002ddc69dc883f1d090a84ac61e8ee81290129daafa6812bcf47973dae7e033261fe37a70b737a0c0fb28c3ed6703dd00077d22d9951bd17a7d134af5083a6383bca5627a6f3f9ad1ee96923083dd088c366be4c01b235f46ddbf9920f58214849585be4f31b4b6aa67889d351a11f1c42513e08d9167f498c2e774d7de4d2bf1cfd255bf14cdcaf1f9f4dd3d849ae69d7145b4906234a7091a94626cda6ba5bebd243b5d48a68da6100c187aa3569640259af311c4fe2decd09278ffaf16807ba98b729d2648941e3665261398de482a6363081cffea214596a99c48e352a97aca253e460c5b21cda9825a262bd81a9b589ccf728226058694d0aa7f7a056bbd98da2db9b29fbae6c62c03570807ca5c1f881a6be477b1cd8a9bb13f7767241d6619f7e39ecf743e2d6251d7e52c4be2a03d05d958a64791b39bfa575f0a95456c69712b31f81cd99b5bdd004b0270a428de4e795c39eff1246c9d94a3e227e9d7d170e5b1695aa5236262555fa70facd15d7fd0ed63eb7ba9095cd5544d7c768cda4b171e2261c724cbdfee682463dee65f24662c8fc1ef2321419263dc73d7505942a56b71070fef06484d2504440f1311ab1a6fd6c78d775ee3c1a35babe1ee80cd44650745b16a249831b954c2f1f26462c6d97f0ef4d59ba03af5f4cdc497354cb9ff5f428192e8dfa0457f828ecc2ba6cea856dc6994cfdbe77052bfd8bf70346b57ac6be489cfcd910da57e9883e3351c76ab2c87b69a13cd5474b332d3905178a27aceeee79502de6fcbf62ef10c2f51bb2dbfe9114137588fa5245d32b440478090317d933d8bff15379fda0ada2e6022735e533ae742b844decbe29886d2ce436cb23db0419397cb88f5bfcf1c24dda53bb1141c0eace5cceef10e6621340bd573cf3d1824a2a08d76c55aa922c7324c2e8808bee5ee5a6453ab562f782bc8fb8254fcf0b537d0bc556405b0057308cfcfe4119a153bd615c9296c93c9b4e97b06a5f7eafcd6fcdc44e7cbfac82e96ed9b41e84782977b8274256b817f529eb49fdc3e05c19640154f28e54fba4eb7fceced2924bc45fa534efed83096185ea6aee6107f9ba8c9b27f80c8014d83f62bc9e7e4bc4ca2731a325fe04c46a08112311588ab7ab45bc5dcd32c933275cf1e8252820e37c6372f9ce3d62004efaf177f30cafa0a73045e7c3e44d220253be1da61057eb8b3f69b148e2ba19bdb758cfe15f00f121bb5a591ab89c2a40a609f9c2aabf5466fdcfa68b27c41575692b991cbf9fbaa4778359c4c166e46568668d349e8914b13d645357b319447865803c84e27187735f743c83f2007c342a938ae2ce30afe6ab1f7547cc8e4069e0a6192c10507a99db84b6d63fe61d208f3682bd85f2e382f7c562318a9ab6e8de93f5733f7ecc5455086a56828b08025f249f4b6d77161e95ec1032fdecdc8130adb5cf91a0ef4e011cf851f0b03ec383071e527691bc1ab6c330aca1387216af07445da5ac4bdc485f9093867ce0a6280d2eb8c969e6982445cc509787111ea66844e60b205f9c222923e4f3804b629fcca086739b457d3e7a64f1b2a5a88ef1fbce64b7a74ebe4104b49d7fef535b06cec71dfac3d825e951dfaedae9c12bc890f9114c43b1f814814dc269cf321d0dbe9dcc6bdc953ecc3d96934ffb7720e96aa6fafef6715d31d4431064297a25dce8877473b2f64361252d0ab435a91aa7351ff53e15c53cf3e3efe11d627f5b64e1678497f5efc148975800182085f9bf9bcf81ded4f91fdabae2423d772d828b1ce73503bf80605fade594e6677b0b1fe973c4064ae94546b999c28353aad143765e59058f09d24acaa25bbd3e33428ce54d84c93c8d6cba0385f2a71262dc6440fa41c86eeb4101ee9932e04064864166b258149a20963282f1b03ae14e07302785ba21d4a64d34613e3a8b08ac79e485fad089a1a2bd5954c25da10ac547bb281e97ee4ddf5abad391d68af8053d51ac2420d449f5d156e2f46cf30e3d7e601c3bef5e9e28d94e679a32f45e5f108fb89f63e9a7f8cd6479fecca6d337bd7e1dbfe9ba4f623780f12b0fae8dc168591f1c46f34c079ce709a347aa7003db1732f3985c72046db925bc32a498cf606fff8159d17573e4f51a31e29db6080a43c2f8fd142bb7f75fac437bf00f30f3ba86fec3fbf2b4bca5c13897eebb77bb177c61886ed329ca6eeb3e2a4114964ef00fffc2a7cd97e46354df5ead15d7b33a7d5701e57c748b0642ca76744c637ddbe4f71d19444f5efc4abacddd4ec2d3133ec93ec884f7b6326dc8105d8ab38ec14652fc4b8fe8770edefd9d4e80059e62852a4d99d3b6c91648dbe178701d335721cfdac9d0d71c94e2f045fa71a83f1370d07bf34fb1e97169e5f9eddb51d79fb21e819c0c0b9790146566fc1d969d5843c0624b2159b3965701aa6496347db926225ee7fa4de7ad2e7b762140ce7fd134eb5e8109781c97d21e03fd29359db749a205ad8229286544d4d5f2a3e2308666fbaf34d06ff6654bc2949dda5301417be8a1fb94c71e85befae3ad34f6605bc733da3a3b26fd0db51852bbb510883b3374383c11ff9876d42ca0c739b40d207d9f26fc0fd5aed383bdfb9a41725ccc1bc8bcbcb5d5b606bbcd24d1f5631dc8e9c9a307e026a2a89cf2b3c0b9761554b3734ea67ff2229912350216f7278c2b3f29f3c52e88c9c52e80c1b612d068d1bd19cc33897d73b6f43c128058e02972e8a82a1791a0973c7ca78f35238d574594a8ff3eedb3f26850a306cd69dd5f73a01b644da3f54e1c07694b2159158ecd19c10711ab394b405c87adb140904ed8f795557431012be1bddf5e71b8816202d70c882cfbea9a49dc84d5f5b84fe42f29a96165aafbea7aa9dbe26d07d031eab5d14bb96f81d6cfd8d97b960e2e714c0739e157cd8f4973ac825d8fbda434d3b1d88db3d6802944f271a5e5701cf8ffb4e89c62ef7ae98ecb5804d5881e1893fdb3da7a59031fc4c9e443401c10fc73732dfec15f46ff0c19da6718bcba3c7b8ed0472ddb4aaf9f178910ca3ab779ef0b6197528315195cc60481480d60270c5351079e2ef04fc66df6a5bcf94a1ba02481217b8bb45797a676ee2d97506e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以查看此内容</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">加密内容，输入密码后方可查看。</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="学习路线" scheme="https://yhxjs.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置</title>
    <link href="https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/"/>
    <id>https://yhxjs.github.io/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/</id>
    <published>2024-02-29T12:08:40.000Z</published>
    <updated>2024-03-06T09:41:43.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm 和 git，因此需要搭建本地操作环境，安装 <a class="link"   href="https://nodejs.org/en" >Node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" >Git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>具体教程可参考 <a class="link"   href="https://blog.csdn.net/WHF__/article/details/129362462" >Node.js下载安装及环境配置教程  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://blog.csdn.net/mukes/article/details/115693833" >Git 详细安装教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><p>安装所需依赖后，可以开始安装 Hexo 了。</p><p>新建一个文件夹用来存放 Hexo 的程序文件，在终端输入以下命令安装 Hexo 的命令行工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div><p>安装完毕后输入 hexo -v 即可查看到版本信息，没问题即可继续。</p>  <div class="note p-4 mb-4 rounded-small success">    <figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/hexo-v.png"                      class="" alt="hexo -v"                ><figcaption>hexo -v</figcaption></figure>  </div><p>在GitHub上创建个人页仓库，命名格式为 <strong>用户名.github.io</strong></p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./creat_repository.png"                      width="600px" height="auto" alt="创建个人页仓库"                ><figcaption>创建个人页仓库</figcaption></figure><p>至此，前期工作已准备完毕，接下来进行具体配置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="初始化并安装依赖组件"><a href="#初始化并安装依赖组件" class="headerlink" title="初始化并安装依赖组件"></a>初始化并安装依赖组件</h3><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init# 初始化</span><br><span class="line">npm i# 安装组件</span><br></pre></td></tr></table></figure></div><p>完成后输入以下命令即可开启本地服务器进行预览：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g# 生成页面</span><br><span class="line">hexo s  # 启动服务器</span><br></pre></td></tr></table></figure></div><p>访问<a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，即可看到默认页面，至此，本地安装结束。</p><p>Hexo 程序目录：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./directory_structure.png"                      width="400px" height="auto" alt="目录结构"                ><figcaption>目录结构</figcaption></figure><h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>输入以下命令来安装部署工具：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><p>然后修改 <strong>_config.yml</strong> 的末尾</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div><p>最后运行 <span class="bg-grey">hexo d</span> 即可将网页push到GitHub上，大功告成！访问 https:&#x2F;&#x2F;用户名.github.io 就可以看到自己的博客了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo官方网站有不少主题可供使用 <a class="link"   href="https://hexo.io/themes/" >Hexo 主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，挑选一个心仪的主题并进行下载。</p><p>本博客使用的主题是 <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，用该主题介绍如何进行安装。</p><p>事先根据提供的文档进行安装，一般都提供git clone的方式，还有npm安装的方式：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br><span class="line">npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div><p>安装完毕后，修改 <strong>_config.yml</strong> ：</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div><p>最后一般都要在Hexo程序根目录下新建一个主题的配置文件，例如 <strong>_config.redefine.yml</strong>， 具体的根据官方文档进行。</p><p>完美！接下来重新启动服务器查看有多么炸裂吧。</p><h3 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h3><p>如果使用的主题是 Redefine，已经集成了不少有用的插件，在此不再赘述，可以参考 <a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行相关配置，此处推荐的是额外的插件，如果有需要也可以自己去 <a class="link"   href="https://hexo.io/plugins/" >Hexo 插件广场 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 挑选，甚至可以自己开发一个。</p><h4 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h4><p>生成站点地图，利于SEO，地址：<a href="hexo-generator-sitemap">hexo-generator-sitemap</a></p><h4 id="hexo-simple-image"><a href="#hexo-simple-image" class="headerlink" title="hexo-simple-image"></a>hexo-simple-image</h4><p>新建文章时自动在相同路径下生成存放图片的文件夹，使得文章引用图片方便不少，地址：<a class="link"   href="https://github.com/ZaiZheTingDun/hexo-simple-image" >hexo-simple-image <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>使用时可以直接像下面这样：</p><div class="highlight-container" data-rel="Md"><figure class="iseeu highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{% asset_img "span>" '"" "<span class="string">my post image</span>"' %}</span><br><span class="line">或者</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./new_post.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span>   &lt;!-- 注意img的话不需要加文件夹名字，因为生成时会自动合并 --&gt;</span><br></pre></td></tr></table></figure></div><h4 id="hexo-tag-mdline"><a href="#hexo-tag-mdline" class="headerlink" title="hexo-tag-mdline"></a>hexo-tag-mdline</h4><p>生成时间线，地址：<a class="link"   href="https://github.com/wangwei1237/hexo-tag-mdline" >hexo-tag-mdline <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="hexo-tag-bilibili"><a href="#hexo-tag-bilibili" class="headerlink" title="hexo-tag-bilibili"></a>hexo-tag-bilibili</h4><p>生成哔哩哔哩视频卡片，地址：<a class="link"   href="https://github.com/Z4Tech/hexo-tag-bilibili" >hexo-tag-bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>建议将url修改为不进行自动播放和默认静音，修改 node_modules\bilibili-embed-convert\index.js，将标出的位置进行修改：</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./bilibili_url.png"                      width="700px" height="auto" alt="修改哔哩哔哩url"                ><figcaption>修改哔哩哔哩url</figcaption></figure>]]></content>
    
    
    <summary type="html">Hexo简要配置指南</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="配置" scheme="https://yhxjs.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Hexo" scheme="https://yhxjs.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>重构</title>
    <link href="https://yhxjs.github.io/2023/11/06/%E9%87%8D%E6%9E%84/"/>
    <id>https://yhxjs.github.io/2023/11/06/%E9%87%8D%E6%9E%84/</id>
    <published>2023-11-06T12:37:09.000Z</published>
    <updated>2024-04-14T13:52:47.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重构，即对程序内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构以增加程序的可维护性、可靠性，这是门学问，这与古老的谚语“程序能跑就不要动它”背道而驰，这句谚语也是屎山如何形成的最根本原因，没有定期地重构不合理的代码，使得埋下的坑越来越深，解bug就像探宝一样，时不时能发现其他宝藏：更难解的bug，这就是为什么bug越解越多。当然，重构总是与bug如影随形，这就要求以最小的步伐来进行重构，每一次重构完成时要进行详尽的测试，最好是提供统一稳定的测试环境，按照相同的方法进行测试，以免重构引入bug。</p><p>重复的代码块IDE会进行提醒，如果有两个及以上重复就可以考虑抽象出一个函数了，这样当这块代码出错，就无需修改每处地方，仅需修改那个函数，这就是重构，其实我们每天都在进行重构，提炼、分析，从而选出最适合的数据结构，或者逻辑顺序。重构有许多种方法，其中按照既有模版进行重构是最简单的，因此了解设计模式以及类似的思想是很有必要的，可以减少编写代码出错的概率。重构就像是在梳理代码，只有理解了具体的逻辑，重构才成为可能，这就是代码可理解性的重要性，难以理解的设计非常不利于重构，因此，代码可读性优先于其他要义（如果不考虑性能的情况下，如果要进行性能优化，可能就会摒弃可读性，这是没办法的，不过也可以增加适当的注解来提高可读性，不要让别人揣测你代码的意思，而是浅显易懂，这才是好的设计）。讲个笑话，当有天回过头来看之前写的代码，会看不懂，惊呼一句卧槽这啥*玩意，那么就需要进行重构了，如果当初代码的作者都看不明白了，那么指望别人能快速理解代码意图是不太可能了。</p><h2 id="设计大于编码"><a href="#设计大于编码" class="headerlink" title="设计大于编码"></a>设计大于编码</h2><p>良好的设计才是快速开发的秘诀，恶劣的设计会使得开发大半的时间都花在不断重复地调试当中，因为程序状况百出，不得不每每打断开发的进度，甚至因为修复bug而打上的补丁会影响后续的开发，使代码愈来愈臃肿，这是我们不希望看见的，因此，我再次强调设计思想的重要性，这是重构的前提。</p><p>事先做好设计可以有效减少返工次数，即进行重构的次数，甚至无需进行重构，就能完美符合需求且代码结构清晰，维护容易，当然，不要过度设计，过于揣测之后的变化是不利于开发的，应该能够在满足需求的情况下，然后一定限度地对风险进行预测，考虑增加容错，而不是一上来就“疑神疑鬼”。掌握设计和编码难度的平衡性也是挺困难的，设计为需求而服务，但满足需求并不一定能够实际落地，需要切实考虑编码难度、时间花费、风险控制等等因素，而不是盲目地追求所谓好的设计。在设计前请务必理清需求和度量系统，不要臆测，想当然地以为那样就是那样，需要不断沟通以完善设计。</p><h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h3><p>这是再正常不过的坏味道了，当一段代码在多处出现，那就要考虑是否需要进行重构了，提炼出重复代码，然后封装到一个函数中，这样出问题只需改一处即可，而不是牵一发而动全身。</p><h3 id="过长函数"><a href="#过长函数" class="headerlink" title="过长函数"></a>过长函数</h3><p>当一个函数过长，就要注意了，函数越长，逻辑就越难理清，也就越难维护，所谓屎山就是堆砌起来的，当一段冗长的代码摆在面前，且没有相应注释，我想是个人都会抗拒去阅读它，将这类代码分割成一小块一小块，每一块都是单独的一段逻辑，然后再串联起来，这样不仅能减少临时变量，且还能让逻辑变得清晰明了，最重要的是，复用性大大增加。</p>]]></content>
    
    
    <summary type="html">重构是一种艺术。</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="重构" scheme="https://yhxjs.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://yhxjs.github.io/2023/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yhxjs.github.io/2023/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-01T15:05:40.000Z</published>
    <updated>2024-03-26T12:36:05.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式提供了一套在特定问题场景下解决软件设计问题的标准化解决方案，能够帮助开发者避免重复造轮子，提高代码的可复用性、可维护性和可扩展性，并且能够使开发过程更加高效、有条理。</p><p>在介绍之前先了解下三个原则：单一职责原则、开放-封闭原则和依赖倒转原则。</p><blockquote><p>单一职责原则</p><p>如字面意思所示，对于一个类来说最好只有一个引起它变化的原因。如果一个类承担的职责过多，就相当于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。如果根据职责进行划分，即根据功能进行细化，后续的改动甚至是移植都会变得容易许多，可维护性大大提升，而不是一堆shit mountain摆在面前，不知道从何入手。当然，无需过度细分，实际上，在开发中一般是以功能模块进行划分，而模块内部的各个细节再进行具体划分，做到粗中有细。</p></blockquote><blockquote><p>开放-封闭原则</p><p>如字面意思所示，可以进行扩展，但不能进行修改。此处的不能修改并不绝对，而是需要开发者事先预知可能的变化，将这种变化进行抽象，从而实现隔离变化，当发生变化时，只需要增加新代码，而不是修改现有代码。当然，仅需要对频繁做出改变的部分进行抽象，而不是事无巨细，反而会导致过度修改。</p></blockquote><blockquote><p>依赖倒转原则</p><p>首先先了解里氏代换原则，即一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换为它的子类，程序的行为并未发生变化，简单来说，就是子类型必须能够替换掉它们的父类型。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象，即针对接口编程，不要对实现编程，高层模块不应该依赖低层模块，两个都应该依赖抽象。由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是这三类设计模式的简要概述：</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这类模式主要关注对象的创建方式，使系统独立于对象的创建、组合和表示方式。常见的创建型模式包括：</p><h4 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h4><p>即确保一个类仅存在单个实例，并为该实例提供访问方法，当多线程时，需要提供锁来保证单实例。</p><p>单例模式分为饿汉式和懒汉式，饿汉式即一开始就创建实例，而懒汉式则是用到时才构建实例。</p><h4 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h4><p>即用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实际上就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建的细节，将对象初始化为被克隆的对象，然后再根据需要修改部分属性，而不需要从头开始初始化。</p><blockquote><p>此处克隆分为浅拷贝和深拷贝，这是一个老生常谈的问题，浅拷贝只是引用传递，即拷贝对象只将对象的引用进行拷贝，而真正的数据并有拷贝，即数据只有一份，只要一个地方进行了修改，其他拷贝的地方也会跟着产生变化，如果不想这样，就需要值传递，实现深拷贝方法，重新创建一个跟被拷贝对象一样数据的对象，曾经在写Vue的时候遇到这个坑，直接用等于号赋值，结果临时变量的改变也导致了原本变量的改变，从而导致模版重新渲染，这里就不展开说了，感兴趣的可以搜搜看。对于Java、C#等等面向对象语言来说，都会提供一个Cloneable类，只需要继承该类即可调用clone方法来复制实例，不过此处的clone方法是浅拷贝，如果需要深拷贝，可以进行重写。</p></blockquote><h4 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h4><p>首先需要了解简单工厂模式，即运用多态，在构造时，构造工厂根据某个属性创建对应的类，这些类都继承于某个抽象类，实现某个公有方法，从而只需要调用该方法即可，不用关心方法是如何实现，当需要变动时，只需要改变对应类的实现，而不用关心其他类的实现。</p><p>工厂方法模式将简单工厂模式进一步抽象，把工厂也分为一个个具体的工厂，将原先在工厂内判断的逻辑移动到外部，进一步加强了开放-封闭原则。定义了一个创建对象的接口，让子类决定实例化哪个类。</p><h4 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h4><p>创建一系列相关或相互依赖的对象，而无需指定它们具体的类。常常和依赖注入和反射相结合，根据传入的依赖创建不同的实例，从而调用不同的方法，例如数据库连接池druid，它并不感知具体的数据库类型，不论是MySQL还是oracle，都有一套标准，即连接器，只需要方法一致即可。</p><h4 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h4><p>即将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>将构建流程标准化形成一个抽象类建造者，其中包含各个步骤，然后再去继承这个抽象类，然后必须实现其中的所有方法，因此不会有遗漏，而再抽象出一个流程类指挥者，传入建造者，调用各个步骤，从而形成具体的流程。部分定制化可以概括这个模式的特点，流程是定死的，但是步骤可定制化，经过不同的步骤，最后呈现的结果也是不同的，但万变不离其宗。</p><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这类模式主要涉及到类和对象的组合，用于构建大型的对象结构，帮助确保系统的灵活性和高效性。常见的结构型模式包括：</p><h4 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h4><p>即将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>适配器模式主要应用于希望复用一些现存的类，但是又与复用环境要求不一致的情况，字面意思，可以联想到电源适配器，将市电转化为直流电，供设备运行，一样的思想，适配，适配，适应配置，当存在复杂且繁杂的代码时，无法对其进行重构，或者重构成本过于昂贵，这时就可以运用适配器模式进行相应的适配，当然，还有第三方接口和自己的接口不匹配，此时也需要进行适配。</p><h4 id="装饰者（Decorator）"><a href="#装饰者（Decorator）" class="headerlink" title="装饰者（Decorator）"></a>装饰者（Decorator）</h4><p>即将所需的功能按正确的顺序串联起来控制，动态地给一个对象添加一些额外的职责。</p><p>可以理解为一种另类的递归，装饰对象的被装饰物其实还是其他对象的装饰对象，每次先执行之前“装饰”的方法，再执行自己的方法，串成一串，这样就实现了可装配的增强功能，当需要时，可按需进行串联，例如事先的数据校验，增加新的字段，新的逻辑等等。注意，装饰的顺序是很重要的，例如数据校验、加密，不能等到业务处理结束后才进行。装饰模式可以有效地将核心功能和装饰功能分离开来，按照需要进行必要的增强，而不修改核心功能。</p><h4 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h4><p>即为其他对象提供一种代理以控制这个对象的访问。</p><p>如果有部署过Nginx的应该不陌生，代理服务器，即将收到的请求发送到另一个服务器，收到应答后再将该应答返回，相当于多了一个代理人的概念，当然在传递期间可以做一些额外的事，甚至经过处理而不用继续传递直接返回，一般来说，代理能处理的事，就不用劳烦被请求的对象了。</p><h4 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h4><p>即为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加易用。</p><p>在设计初期阶段，应该有意识的定义不同的层，每个层都有不同的职责，然后层与层之间通过接口访问，使得耦合大大降低，例如网络的TCPIP模型，再比如后端的数据访问层、业务逻辑层、表示层等等，各司其职，对外提供一组接口供其他层调用，只需要知道这个接口是干啥的，而无需过分关注其中的实现，只要功能没变，调用该接口的地方就无需变动。</p><h4 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h4><p>即将抽象部分与它的实现部分分离，使它们都可以单独地变化，简单来说，就是将类的功能层次结构和类的实现层次结构连接起来。</p><p>就像系统和软件之间存在的关系，软件在不同的系统中实现有所不同，但是功能是一样的，即仅需定义好功能，然后调用实现即可，功能侧无需关心具体实现。</p><p>想要新增功能时，只需在功能侧添加功能类，不必对实现侧进行修改，增加后的功能能被所有实现使用。</p><h4 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h4><p>即将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p>文件树、窗口视图、权限管理等等，都可以采用组合模式，即可以进行嵌套，当然需要注意有没有嵌套自身，不然就会无限递归下去。</p><h4 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h4><p>即运用共享技术有效地支持大量细粒度的对象。</p><p>例如字符串常量就可以理解为是享元，相同的字符串常量实际上是在同一块内存，还有线程池、数据库连接池，其实也是享元，只不过是事先建立多个线程或者连接，然后共享，本质是一样的，C语言的文件描述符也是如此，可以事先进行创建，还能节省时间，因为创建比较耗费时间。</p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这类模式专注于对象之间的通信，用于增强对象之间的协作和职责分配。常见的行为型模式包括：</p><h4 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h4><p>即将策略（算法）从单个类剥离出来，定义一个父类，然后分成不同的类继承该父类，这些类都实现对某个问题的处理方法，这样只需要在需要构造的类（上下文）中传入需要的策略，即可调用处理方法，而无需关注内部如何实现。</p><p>策略类只需要实现必要的接口，具体的策略类需要实现策略类中定义的接口，而上下文类负责使用策略类，用多态传入不同的具体的策略类。</p><p>策略模式有效地将算法和实际应用剥离开来，后续如果要新增策略或者修改策略对应的算法时，只需要对相应的部分进行新增或者修改即可，相当于是委托，是一种弱关联关系，可以很方便地进行替换。</p><p>策略模式可以和简单工厂模式相结合，上下文构造时传入的可以是某个属性，再将该属性映射到具体的类。不同模式是可以进行嵌套的，最终境界就是看似没有应用模式，实际都是模式，不需要刻意使用，即化有形为无形。</p><h4 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h4><p>又叫发布-订阅模式，即让多个观察者订阅某一个对象，当这个对象状态发生变化时，会通知所有观察者对象执行相应的动作。</p><p>消息队列就是经典的观察者模式，以及基于事件驱动的websocket，都是根据“状态”变化来触发对应动作，也就是回调，并不关心是谁触发的，而是关注什么事件被触发了。</p><h4 id="责任链（Chain-of-Responsibility）"><a href="#责任链（Chain-of-Responsibility）" class="headerlink" title="责任链（Chain of Responsibility）"></a>责任链（Chain of Responsibility）</h4><p>即使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>相当于踢皮球一样，先看看自身能不能处理，不能就踢给下一个人，以此类推，直到有人进行处理，当然，最后必须保证能处理，不然就没有意义了，就像现实中无意义的互相甩锅（手动狗头</p><h4 id="命令（Command）"><a href="#命令（Command）" class="headerlink" title="命令（Command）"></a>命令（Command）</h4><p>即将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>可以理解为事件驱动，事件触发时将要做的操作加入队列中，或者将操作从队列中删除，当收到执行事件时，将队列中的操作一一执行。</p><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>即用状态决定对象的行为。</p><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，用类表示状态，将冗长的判断切分为一个个状态，分而治之，可以将状态迁移交给各个状态，由自己判断什么时候迁移状态，也可以在外部进行迁移，通过有限状态机可以更好地理解各个状态之间的关系。</p><h4 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h4><p>即将数据结构和处理分离开来，使得可以不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>该模式适用于数据结构相对稳定的系统，这就使得它的优缺点都十分明显，优点就是操作解耦，增加新操作无需修改先前的代码，而缺点就是一旦数据结构变化，需要修改的地方就会分散到各个角落里，难以维护，因此只适用于稳定的数据结构。</p><h4 id="中介者（Mediator）"><a href="#中介者（Mediator）" class="headerlink" title="中介者（Mediator）"></a>中介者（Mediator）</h4><p>即用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>相当于由一个路由器决定请求该发往哪里，在web应用中可以用Redis解决跨域问题，不同的网站请求同一个Redis即可，存的cookie可以很容易共享，跟发布&#x2F;订阅模式很像。</p><h4 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h4><p>即将对象的状态保存起来，需要时可以进行恢复，就像游戏中的存档和读档。</p><p>可以藉由该模式实现状态恢复、状态暂存，甚至还能覆盖保存的状态，可以将状态保存到Redis里，需要时进行取用，可以实现二阶段提交等功能。</p><h4 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h4><p>即提供一种方式顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>该模式实际已经加入语言实现当中，iterator即迭代器，使用该元素即可对集合进行遍历然后进行相同的操作。</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><a class="link"   href="https://baike.baidu.com/item/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7427270" >《Head First设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262" >《大话设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>强烈推荐！！！以浅显易懂地方式介绍了各个模式，建议先阅读，挺有趣的</p><p><a class="link"   href="https://baike.baidu.com/item/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22699708" >《图解设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>具体案例可以看这本，加深理解</p><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>技术是在总结和否定中不断发展，设计模式就是总结前人惯用的一些思维模式，抽象出来具体的方法，让后来者可以借鉴，领略其中的精妙之处，但23个设计模式并不足以概括此前贡献者的智慧，在我看来，只是冰山一角，更多的奥妙，还需要在接下来的编码生涯中慢慢体会，仔细品味。</p><p>不同的语言之间存在实现上的差异，但是处处可见设计模式的身影，这说明了设计模式的技巧被广泛运用，其实这是个先有鸡还是先有蛋的问题，是先有所谓的设计模式，还是先有的技巧，我觉得并不重要，重要的是如何运用所谓的设计模式，要融会贯通，而不仅仅是套用，虽然套用可以省去一些无谓的开销，但是结合具体场景需要对模版进行改进以适应需求。有的时候，套用模版并不是一件好事，这样容易将简单的事情复杂化，个人觉得，需要设计模式的时候，那么这个功能一定是繁杂的，不容易理清的，才需要设计模式的协助，减少出错的概率，就像C语言，并不是面向对象的语言，但是这并不影响面向对象思想的运用，这就要问问神奇的宏了，可以实现多态，进而实现各个设计模式，让我不由得感叹前人的智慧，精妙！</p><p>集设计模式为大成的MVC模式，即模型-视图-控制器，最近貌似被DDD模式给创飞了，即领域驱动设计，我对于DDD的了解甚少，在前不久才知道有这么个模式，不过貌似这两个模式可以并存，DDD模式实际上是一种思想。</p><p>MVC是一种常见的软件架构模式，用于组织和分离应用程序的逻辑层、表示层和用户交互层。模型负责表示和处理数据，视图负责显示用户界面，控制器负责处理用户交互和调度逻辑。MVC的核心目标是将应用程序的不同功能和职责解耦，使得各个组件可以独立变化，并且提高了应用程序的可维护性和可扩展性。</p><p>DDD是一种面向复杂业务领域的软件设计方法，它将关注点放在领域模型的设计和开发上，强调领域专家和开发团队的紧密合作，以达到更好的业务理解和设计实现。它提倡通过领域模型来反映业务需求，将业务逻辑和业务概念抽象为领域对象、值对象、聚合等概念，通过领域模型来实现业务规则和业务流程的核心逻辑。它的核心思想包括战略设计和和战术设计，其中战略设计关注领域模型的整体结构和组织，战术设计则关注具体领域对象和业务逻辑的实现。</p><p>二者都是软件开发中的设计模式和思想，它们的目标都是提高软件系统的可维护性、可扩展性和可理解性。二者可以结合使用，DDD的领域模型可以作为MVC模型中的模型部分，MVC模式提供了一种良好的架构和开发模式来组织和展现DDD的领域模型。</p>]]></content>
    
    
    <summary type="html">设计模式是一种在特定情境下解决特定问题的方法论。</summary>
    
    
    
    <category term="杂项" scheme="https://yhxjs.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="设计模式" scheme="https://yhxjs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>伤</title>
    <link href="https://yhxjs.github.io/2022/06/29/%E4%BC%A4/"/>
    <id>https://yhxjs.github.io/2022/06/29/%E4%BC%A4/</id>
    <published>2022-06-29T14:31:06.000Z</published>
    <updated>2024-04-15T14:39:15.378Z</updated>
    
    <content type="html"><![CDATA[<p>伤，是人之所感，亦是这世间可随处可见的一种现象，为自己所伤，为世人所伤，无论主体，无论手段，又如刀锋上跳动的冷光，亦如火焰上蔓延的灼烧感，将人拽入深渊，并不是简单的，混杂着不同的情感，正是如此复杂，不能进行量化，描述的仅仅只是其中一小部分，无法将其彻底阐述，只能凭借心中所想，掏出一部分展现出来，畸形的，蠕动着，尖叫着，掏出的那部分化为一个空洞，深不见底，惊恐地望着自己，这是谁？如此丑陋，如此不堪，只能无能地嚎叫。</p><p>伤，附着在生物上，负面的影响是它的养分，它不断扩散，若外部没有事物阻止它，便会向深处爬去，贪婪地吮吸着，血液的醇香，或是内心的影子，皆让其欢喜，躲藏在那邪恶的背后，跳动着指挥，指挥着那傀儡。</p><p>伤，其本源是贪婪。人总是怀着最大的恶意去揣测他人，当人对某样事物产生渴望时，会不择手段地去获取它，如果发现自己无法够到时，要么就此放弃，另行寻找目标，要么就将其抹黑，无论这黑是真实存在还是子虚乌有，这时，伤随之孕育而生，伤其中又孕育着伤的种子，一旦时机成熟，种子就会疯一般地生长，伸出的藤蔓向外蔓延，寻找能进一步寄生的宿主，而其根部越扎越深，随时间的流逝，越难将其根除，直至严重得只能限制其生长。</p><p>世间万物皆是如此，遍布着伤痕。伤无处不在，因外部所受的伤害化为实体和阴霾，实体即为可见的创伤，阴霾则为笼罩在心中的悸动，因内在所受的伤害化为压抑的负面情绪，时而外露，更多是隐藏在内心深处，不让外界触及，带上一层层枷锁，给自己戴上面具，成为双面人。</p><p>伤，会制造混乱，当种子萌发，吸收养分，释放黑暗，包裹着潘多拉魔盒，如同恶鬼一般扑向目光所及的光芒，追寻着光明，却是为了毁灭源头，同化曾向往光明的那些事物，低语着克苏鲁的咒文，如同厉魄一般撕咬着火种，绝望油然而生，而这绝望源源不断，化作美味被其吞咽而下，负面的一切，即最好的养料。</p><p>伤，与疼伴生，当感受到带来的那份苦楚，不由自主地颤抖，回想着世间的美好，借由其温存冲淡心中不适，但适得其反，曾经珍惜的回忆在痛感面前，显得那么的虚无，仿佛不真切地发生过。混乱的思绪牵扯着伤口，随着负面情绪不断蚕食，最后一丝理智丧失了，转向曾经爱过的事物，歇斯底里地怒吼，像受伤的野兽一般，伸出利爪，伤害着靠近的一切，直至只剩自己独立于天地，渐渐被黑暗吞噬，变成非人存在。</p><p>舔舐着伤口，自我感动地寻求着“同类”，聚集起来的非人们，哄骗着入世未深的，拖入深渊吃干抹尽，不断将伤播种。我想，我也是其中一员吧。。。</p>]]></content>
    
    
    <summary type="html">世间万物皆是如此，遍布着伤痕。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>小丑</title>
    <link href="https://yhxjs.github.io/2021/08/16/%E5%B0%8F%E4%B8%91/"/>
    <id>https://yhxjs.github.io/2021/08/16/%E5%B0%8F%E4%B8%91/</id>
    <published>2021-08-16T08:59:10.000Z</published>
    <updated>2024-04-14T13:53:21.879Z</updated>
    
    <content type="html"><![CDATA[<p>破碎的天空沉入海底，泛起阵阵涟漪，<br>孤独的太阳浮出海面，映着波光粼粼。</p><p>黑白的人间恶鬼游荡，<br>没有镜子，<br>看不清笑容背后，<br>阳光黯淡，<br>照不亮眼泪，<br>火炬已灭，<br>想不起。</p><p>哀嚎着，<br>究竟是人是鬼？</p><p style="text-align:right;">写于2021-8-16</p><figure class="image-caption"><img                       lazyload                     src="/images/loading.svg"                     data-src="./joker.jpg"                      width="500px" height="auto" alt="小丑"                ><figcaption>小丑</figcaption></figure>]]></content>
    
    
    <summary type="html">观小丑电影有感。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>告别高中</title>
    <link href="https://yhxjs.github.io/2019/06/28/%E5%91%8A%E5%88%AB%E9%AB%98%E4%B8%AD/"/>
    <id>https://yhxjs.github.io/2019/06/28/%E5%91%8A%E5%88%AB%E9%AB%98%E4%B8%AD/</id>
    <published>2019-06-28T14:33:46.000Z</published>
    <updated>2024-04-14T15:05:59.383Z</updated>
    
    <content type="html"><![CDATA[<p>回想高中三年，有许多说不清道不明的意味，就好像天边的云彩，随着风飘动变得灵动万分，随着太阳的映射变得多姿多彩，但云终究是由液滴组成的，在不断的变化过程中，化为泡影，虽大气是不断循环的，但我就好比是其中的一个不起眼的水滴，终究会脱离这个大群体，融入另一个集体之中，这是必然性的结果。</p><p>来不及说声告别，就恍如昨天，梦幻一般，煽情的话语已是不及我内心情感的激荡，一切尽在不言中，虽说这三年，我说实话并未真正了解任何一个人，但尽管如此，我们还是共度了高中，经历了高考的洗礼，有的人收获了喜悦，有的人却不尽人意，不论如何，我们必定拥有了属于自己的那一份悸动，愿今后我们能朝着前方，秉持信仰，一路披荆斩棘，这就是我的所感所想，一个在路上的准大一学生。</p>]]></content>
    
    
    <summary type="html">至逝去的三年（高中）。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>致百日誓师的我</title>
    <link href="https://yhxjs.github.io/2018/09/16/%E8%87%B4%E7%99%BE%E6%97%A5%E8%AA%93%E5%B8%88%E7%9A%84%E6%88%91/"/>
    <id>https://yhxjs.github.io/2018/09/16/%E8%87%B4%E7%99%BE%E6%97%A5%E8%AA%93%E5%B8%88%E7%9A%84%E6%88%91/</id>
    <published>2018-09-16T11:25:45.000Z</published>
    <updated>2024-04-14T13:53:55.098Z</updated>
    
    <content type="html"><![CDATA[<p>当我审视自己，我看到了无数个视角下不同的我，为了他人目光活着，有点累，而我却看不清真实的自己到底是哪个，还是说，我早已不是当初的那个我，我曾以为我便是我，一个自由放纵的我，可现实却击中了我，把我击倒在地，我强忍着伤痛，匍匐前进，前方始终是黑暗，我心逐渐绝望，终于，我看清了，我就是我，一个独一无二的我，也许他人目光将我弄得遍体鳞伤，但我终究是我，随自己的心意而活，可是，真的吗？我不禁陷入了深思，我真的能吗？我想这是不可能的，生活本就是一个囚笼，你无法打破它，只能去学会接受它，去改造它，让它变得更加美好，哪怕再不堪，也要好好的，没有人能真正按照自己心意而活，生活本就是如此，面对他人的目光，不要去逃避，不然你终将会被其击倒在地，我挣扎着爬起来，哪怕前方没有光亮，我也要用我这心，去照亮前方，只为那当初的我，于是，我便不断前行，披荆斩棘。</p><p>我知道你内心挣扎，并全力克制着疑惑，我理解你每次每次哭泣时的痛苦与无奈，但我早已没了眼泪，被生活磨去了棱角，你本能再坚强一点的，把握明天将给予的一切，但是等待我们的往往是狂风骤雨，不要害怕，去感受它，敞开心胸，让它来吧，学会接受恐惧给你带来的感受，是那么黑暗，那么纯粹，而带来恐惧的正是你的心，不要抵触，让它成为你的一部分，让它驱使你前进，哪怕跟当初的我一样，你也要前行，因为你一旦停止了脚步，你将迷失在这黑暗之中，陷入深潭，恐惧将会吞噬你，所以，接受它吧，没有人能真正按照自己的心意而活，我也不例外，如今我已完全醒悟，过去那些将我击倒的，逐渐使我升华，所以，请不要灰心，相信明天将会是美好的，哪怕狂风骤雨，但你也不怕了，不是吗？勇敢的去面对它，我知道，真正的敌人就在我内心深处，那里是恐惧本源，我须战胜自我，去降服他，可是，我的双手早已无力，我的内心早已千疮百孔，我已无心战斗，但我的灵魂不允许我松懈，于是，我便不断前行，披荆斩棘。</p><p>那么，便努力吧，努力做自己，去冲。</p><p style="text-align:right;">——致百日誓师的我</p><p style="text-align:right;">写于2018-9-16</p>]]></content>
    
    
    <summary type="html">“鸡汤”。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>我</title>
    <link href="https://yhxjs.github.io/2018/05/06/%E6%88%91/"/>
    <id>https://yhxjs.github.io/2018/05/06/%E6%88%91/</id>
    <published>2018-05-06T13:23:22.000Z</published>
    <updated>2024-04-14T13:54:34.221Z</updated>
    
    <content type="html"><![CDATA[<p>飘浮着<br>流荡着<br>望着远方的夕阳<br>我知道你已逝去</p><p>踌躇着<br>漫步着<br>听着身旁的乐声<br>我知道你已归来</p><p>也许<br>来来往往<br>你已老去</p><p>但是<br>往复之间<br>越发真切</p><p>我知道<br>你<br>一直在追逐<br>追逐那心中念想</p><p>我知道<br>你<br>一直在幻想<br>幻想那世间美好</p><p>我也知道<br>你<br>曾多少次暗自神伤</p><p>我亦知道<br>你<br>曾多少次触景生情</p><p>因为<br>我知道<br>我便是你</p><p style="text-align:right;">写于2018-5-6</p>]]></content>
    
    
    <summary type="html">是谁？</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>溺水</title>
    <link href="https://yhxjs.github.io/2017/04/08/%E6%BA%BA%E6%B0%B4/"/>
    <id>https://yhxjs.github.io/2017/04/08/%E6%BA%BA%E6%B0%B4/</id>
    <published>2017-04-08T10:35:18.000Z</published>
    <updated>2024-04-14T13:55:21.203Z</updated>
    
    <content type="html"><![CDATA[<p>渐渐丧失知觉，阳光仿佛随我一起消失在这河里，逐渐黯淡，岸上的呼喊声在耳边若隐若现。有那么几刻，我甚至怀疑这并不真实，仿佛做梦一般飘渺，它就那样将我拉入万丈深渊，我不禁想要挣扎，去挣脱它的控制，但毫无成效，反而使我越陷越深，我感到一丝无力与绝望，不甘就这么死去，世间的种种在眼前浮现，我不禁笑了笑，是啊，又有什么可怀念的呢？放弃挣扎的我慢慢下沉，我仿佛看到世间最美的景色，一切是那么安静，祥和，我闭上眼睛，想去感受死亡所带来的一丝不安与恐惧，但我感受到的只有无尽的黑暗和一片虚无。</p><p>岸上的那人仿佛冷漠无比，事不关己地看着我，渐渐死去，于是，我便长眠于此，世间再无我的容身之地，我已不复存在，接管这个皮囊的是另一种存在，一种未知的存在，它就在那，就那么默默注视着我，看着我渐渐堕落，迷失自我，取代我的便是它，是我助长它的存在，使它慢慢腐蚀我的灵魂，侵入我的内心，但对此我一无所知，直至此刻，我死了，我才领悟，但也没有什么值得我去留念了，当初的信念早已覆灭，随着我一同消散在这世间。</p><p style="text-align:right;">写于高中某天</p>]]></content>
    
    
    <summary type="html">看《溺水》有感。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>沉默的大多数</title>
    <link href="https://yhxjs.github.io/2017/01/14/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/"/>
    <id>https://yhxjs.github.io/2017/01/14/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/</id>
    <published>2017-01-14T13:03:02.000Z</published>
    <updated>2024-04-14T13:55:39.014Z</updated>
    
    <content type="html"><![CDATA[<p>沉默，一切无言，对于世间的种种，我只能冷眼相对，不是冷漠，而是心力交瘁，感觉内心充满了黑暗，却装出一副无所谓、不在乎的样子，仅仅是为了更好地融入这个虚伪的世界，那又能怎么样呢？迷失了方向，只有家的光芒仍引导着我向前走，尽管前路茫茫，但，路在前方，坚持走下去，哪怕是为了自己的信念，也要咬牙坚持走下去。</p><p>可是，却早已无力，瘫倒在冰冷的地上，看着天空，白茫茫的一片覆盖了蓝天，仅露出些空隙，光从中渗透出来，洒满了大地，也照到我的脸上，麻木的脸颊甚至感受不到丝毫暖意，此刻太阳仿佛冷焰一般，燃烧着，却冷到无感，这早已不是火，而是晃动着的光球，散发着寒人的光芒，世间这一切仿佛失色，在这天地间，仅剩我一人，自由地飞翔在冰冷的大地上，内心燃烧起一团火，双眼只剩下无尽的深邃，毫无感情，无奈化作脸上那唯一的标志——沉默，无尽的沉默。</p><p>曾几何时，可笑的认为这世间如此美好，却在一瞬之间，破灭了，一点点消散在内心深处，化为一道道无法修复的伤痕，触目惊心，却又蕴含着对从前的回忆，不禁交杂着一种复杂的情感，在笑的时候，眼角却冒出了眼泪，内心痛苦，牵动着神经，身体做出抗拒的表现，想要发泄，却又不能，只能任由它肆意破坏曾经美好的感受，剩下一片废墟，慢慢沙化，渴望雨水将其冲刷干净，却只有几滴眼泪。</p><p>无言，岁月流逝，也许废墟会重建，但一切早已不是原来的模样，只有那面目全非的痕迹才能证明这曾经存在过，只能独自缅怀逝去的青春，却无人能懂，烦闷瞬间爆炸，将我炸得血肉横飞。一次又一次地隐忍，早已受不了那倦怠，我只想逃离，逃离这一切。</p><p style="text-align:right;">写于高中某天</p>]]></content>
    
    
    <summary type="html">看《沉默的大多数》有感。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>呐喊</title>
    <link href="https://yhxjs.github.io/2016/10/30/%E5%91%90%E5%96%8A/"/>
    <id>https://yhxjs.github.io/2016/10/30/%E5%91%90%E5%96%8A/</id>
    <published>2016-10-30T13:29:05.000Z</published>
    <updated>2024-04-14T13:55:59.117Z</updated>
    
    <content type="html"><![CDATA[<p>回想过去，多么怀念曾经的美好时光，但却早已只剩下那渐行渐远的一个个瞬间仍然徘徊，转瞬即逝。深入骨髓的孤独感慢慢侵蚀着我，迷失在人海中，与自己的影子为伍，不时躲闪来往的行人，我只想躲到阴暗的角落，回想过去的点点滴滴，仅此而已，但外在虚伪的皮囊早已机械麻木，与这繁华世界格格不入。此刻，我只想呐喊。<br>内心的苦楚遍布在每一个角落，想呐喊，却不行，就像一个异类，不被人所正视，即便有，那也是不长久的，顷刻间，可能往昔的情分早已烟消云散，不复存在，只剩下那充斥着虚伪笑容的脸仍留在脑中，久久挥之不去，仿佛在讥讽，嘲笑，我想这是不能呐喊的原因吧，因为它无时无刻不在压抑你，让你无法置身事外，世间种种皆是如此，想要逃离这一切，却发现自己早已被捆绑住了，无法挣脱，甚至无法发声，身边的人诧异地看着你，你的那些看似有些另类的行为不被人所接受，因为人们习惯于司空见惯，而当一些不正常的东西出现的时候，他们会质疑它，甚至去摧残它。</p><p>呐喊，我只想呐喊，在广袤无垠的田野中肆意呐喊，在这里，没有人去讥讽、嘲笑你，似乎很畅意，但我不能，虽然世间的种种把我压得喘不过气来，但在这一片黑暗中还有零星的灯火——真正爱你的人，回到他们的身边，种种不安、惶恐都消失了，尽管只有一段段短暂的时间，但内心却是如此光明。也许将来你们会离开我的身边，但我还是会挺住这苦楚的肆虐，在这万象丛生的世界活下去，去为了寻找一个能够陪伴我走下去的挚爱。</p><p>在这之前，我只想呐喊，当我渐渐长大，亦或是变老，头发渐渐苍白，如今炽热的心也许会随之降温，但我仍有信念，仍有为之一生的目标，这便足够了。哪怕世人无法理解，但我保持自我，我还是我，放纵着我，在这世界中茫茫一点，不奢求改变什么，但求初心不变，这便足够了。</p><p>在这世界，有许多不公平，但这往往是表象，许多人想逃离这种不公平的现象，转而追求那些看似公平的选择，这本没有错，但这些人为了公平，将不公平强加于他人，只为了一时的利益，并不能说人心险恶，这只是人们为了自我保护和那万恶的欲望作的祟，这可能会毁了一个人的一生，但人们却不管不顾，仍旧如此，只有当其波及家人或自我的时候，这才会看清本质，停止那愚蠢的行为，但有些人仍旧被蒙蔽，做出无法挽回的事，这充斥在人世间，几乎每时每刻都在发生，我厌倦了这种选择和拒绝的过程，而结果也不再那么重要了，无非是为了欲望，还有那可笑的自我保护，所以，我只想呐喊。</p><p>生活中的某些事物会将我们置之于一处险地，在这里，只有你自己，周围黑漆漆的一片，这强烈的压抑感会使人喘不过气，但又不得不去面对它，独自地，将它打败，你才能走出去，这时，你的心境会变得更加强韧，但往往会有许多事物会影响你的心智，妨碍甚至阻止你做出关键的选择，如果你放弃了，那么你将沦为它的奴隶，自此难以自拔，只能任由它侵蚀你，肆虐你，直到你的最后一道防线被攻破，那么，你早已不是你，你将会被改变，变得麻木，没有丝毫情感，一切都将无法阻止你的决定，你的选择，你的一切，因为你已不是人，只是机械动物，我怕，会成为这样的存在，所以，我只想呐喊。</p><p>啊——这一切究竟是为了什么？也许究其一生都不会知道，只能默默、平凡地活着，让尸骨腐烂在地底，让世界遗忘我曾经存在过，而这一切，都将成为消失那一点。</p><p>我真的只想呐喊。</p><p style="text-align:right;">写于2016-10-30</p><p align="right" style="text-align:right;text-indent:32.0pt"><span style="font-size:16.0pt;font-family:楷体;color:#215868">蚝油<span></span></span></p>]]></content>
    
    
    <summary type="html">我真的只想呐喊。</summary>
    
    
    
    <category term="随笔" scheme="https://yhxjs.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
