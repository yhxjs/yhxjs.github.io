<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARP协议</title>
    <url>/2024/03/05/ARP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARP即地址解析协议，将IP地址解析为MAC地址。数据要在以太网中传输，需要完成以太网封装，这项工作由网络层负责。要完成以太网的数据封装，需要知道目的设备的MAC地址。</p>
<p>注意：ARP报文不能穿越路由器，不能被转发到其他广播域</p>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_packet_format.png"
                      width="400px" height="auto" alt="ARP报文格式"
                ><figcaption>ARP报文格式</figcaption></figure>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_packet_format_wireshark.png"
                      width="450px" height="auto" alt="ARP报文格式(Wireshark)"
                ><figcaption>ARP报文格式(Wireshark)</figcaption></figure>

<p><strong>硬件类型</strong>：表示硬件地址的类型（其中，值为1表示以太网地址，其他还可能表示令牌环地址）。</p>
<p><strong>协议类型</strong>：表示要映射的协议地址类型（其中，0x0800表示IP地址，其他还可能是ICMP&#x2F;IGMP）。</p>
<p><strong>硬件地址长度</strong>：指出该报文中硬件地址的长度（ARP报文中，它的值为6）。</p>
<p><strong>协议地址长度</strong>：指出该报文中协议地址的长度（ARP报文中，它的值为4）。</p>
<p><strong>op</strong>：操作字段，共有4种类型（1.ARP请求，2.ARP应答，3.RARP请求，4.RARP应答）。</p>
<p><strong>源MAC地址</strong>：发送方设备的硬件地址。</p>
<p><strong>源IP地址</strong>：发送方设备的IP地址。</p>
<p><strong>目的MAC地址</strong>：接收方设备的硬件地址。</p>
<p><strong>目的IP地址</strong>：接收方设备的IP地址。</p>
<p>ARP报文解析主要关心的是后五个字段。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_workflow.png"
                      width="450px" height="auto" alt="ARP工作流程"
                ><figcaption>ARP工作流程</figcaption></figure>

<ol>
<li>先查看ARP表，如果ARP表中没有目的IP地址对应的MAC表项，则发送ARP请求包</li>
<li>源主机广播发送ARP request 数据包，请求目的主机的MAC地址</li>
<li>同网段内的所有主机都能收到ARP request请求包，但只有目的主机才会回复ARP reply数据包</li>
<li>源主机收到ARP reply后，将目的主句的IP-MAC对应关系添加进ARP表中，完成数据的以太网封装，进行数据交互</li>
</ol>
<p>通过Wireshark抓包可以看到整个过程。</p>
<p>IP为192.168.56.105的主机A广播目的IP为192.168.56.1的ARP请求，当IP为192.168.56.1的主机B收到该请求后，应答自己的MAC地址给主机A：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_request_wireshark.png"
                      width="450px" height="auto" alt="ARP请求(Wireshark)"
                ><figcaption>ARP请求(Wireshark)</figcaption></figure>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_reply_wireshark.png"
                      width="450px" height="auto" alt="ARP应答(Wireshark)"
                ><figcaption>ARP应答(Wireshark)</figcaption></figure>

<p>而一整个ping的过程相当于两个来回：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_ping_wireshark.png"
                      width="800px" height="auto" alt="ping(Wireshark)"
                ><figcaption>ping(Wireshark)</figcaption></figure>

<p>通过我开发的show arp packet history命令也可以看到整个过程：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./show_arp_packet_history.png"
                      width="100%" height="auto" alt="show arp packet history"
                ><figcaption>show arp packet history</figcaption></figure>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table>
<thead>
<tr>
<th>类别</th>
<th>含义</th>
<th>作用</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>静态</td>
<td>手动配置（优先级高）、认证下发</td>
<td></td>
<td>永久、表项不更新</td>
</tr>
<tr>
<td>动态</td>
<td>通过报文学得</td>
<td></td>
<td>老化、表项更新</td>
</tr>
<tr>
<td>可信任</td>
<td>客户端认证时候，会在网关交换机上添加arp，该arp是真实有效的</td>
<td>位于交换机端ARP表项中，防止ARP欺骗</td>
<td>具有静、动态属性</td>
</tr>
<tr>
<td>免费</td>
<td>源、目的IP都是自己的广播arp报文</td>
<td>IP地址冲突检测、MAC地址变化通知其他设备</td>
<td>可以定时发送免费ARP，若无IP冲突不能应答</td>
</tr>
<tr>
<td>代理</td>
<td>源目的不属于同一网段，设备知道目的ip的路由信息时，则进行代替arp响应</td>
<td></td>
<td></td>
</tr>
<tr>
<td>本地代理</td>
<td>以网关自身的MAC回应本网段的IP地址的ARP请求</td>
<td>用于二层端口隔离时，主机先获取网关的mac，之后在网关设备上报文会被上送三层，通过三层路由实现同一网段内主机通讯</td>
<td></td>
</tr>
<tr>
<td>any ip</td>
<td>任意IP地址都可以上网，ARP请求的源IP和设备不在同网段，且目的IP可能不是自己，但网关仍然发送ARP应答，并且为主机的IP地址生成直连路由</td>
<td>场景：无需修改IP与网关即可正常上网，例如网吧、酒店等地方</td>
<td></td>
</tr>
<tr>
<td>探测</td>
<td>源IP为0，目的IP为待探测地址</td>
<td>收到应答则说明该IP被使用</td>
<td></td>
</tr>
</tbody></table>
<h2 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h2><p>首先底层对报文进行处理，将二进制报文转化为可处理的格式，然后交由控制层进行处理。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./arp_packet_processing.png"
                      width="300px" height="auto" alt="ARP报文处理逻辑"
                ><figcaption>ARP报文处理逻辑</figcaption></figure>

<ol>
<li><p>操作码op，源接口和二层接口协议状态，格式检查，MAC合法性，IP合法性，免费ARP检查，ACL检查等，经过上述一系列检查后，源IP和目的IP都不为0，且都是合法的。</p>
</li>
<li><p>判断源IP和源接口是否处于同一网段，主要区分就是VRRP的虚IP和开启了any-ip-arp要进行特殊处理，经过判断后，如果是同一网段就进行处理，否则就丢弃即忽略。只要源IP和本机IP是一致的，都认为IP地址冲突，查看源MAC和源接口的MAC是否相同，如若相同，则说明是自己发的，不进行处理，否则进行冲突应答。如果目的IP为本机IP，判断是否是发给自己的，如果是则继续进行处理，否则进行相关的代理。</p>
</li>
<li><p>普通处理</p>
<p>处理request报文：</p>
<ol>
<li><p>目的地址是我们的IP，则不更新表项，只应答。</p>
</li>
<li><p>目的地址不是我们的IP，则不应答。</p>
</li>
<li><p>如果MAC地址不一样，需要代理冲突应答，并走老化逻辑。</p>
</li>
</ol>
<p>处理reply报文：如果源IP匹配到了表项或者开启了某种学习才进行表项的学习更新。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>ARP</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>伤</title>
    <url>/2022/06/29/%E4%BC%A4/</url>
    <content><![CDATA[<p>伤，是人之所感，亦是这世间可随处可见的一种现象，为自己所伤，为世人所伤，无论主体，无论手段，又如刀锋上跳动的冷光，亦如火焰上蔓延的灼烧感，将人拽入深渊，并不是简单的，混杂着不同的情感，正是如此复杂，不能进行量化，描述的仅仅只是其中一小部分，无法将其彻底阐述，只能凭借心中所想，掏出一部分展现出来，畸形的，蠕动着，尖叫着，掏出的那部分化为一个空洞，深不见底，惊恐地望着自己，这是谁？如此丑陋，如此不堪，只能无能地嚎叫。</p>
<p>伤，附着在生物上，负面的影响是它的养分，它不断扩散，若外部没有事物阻止它，便会向深处爬去，贪婪地吮吸着，血液的醇香，或是内心的影子，皆让其欢喜，躲藏在那邪恶的背后，跳动着指挥，指挥着那傀儡。</p>
<p>伤，其本源是贪婪。人总是怀着最大的恶意去揣测他人，当人对某样事物产生渴望时，会不择手段地去获取它，如果发现自己无法够到时，要么就此放弃，另行寻找目标，要么就将其抹黑，无论这黑是真实存在还是子虚乌有，这时，伤随之孕育而生，伤其中又孕育着伤的种子，一旦时机成熟，种子就会疯一般地生长，伸出的藤蔓向外蔓延，寻找能进一步寄生的宿主，而其根部越扎越深，随时间的流逝，越难将其根除，直至严重得只能限制其生长。</p>
<p>世间万物皆是如此，遍布着伤痕。伤无处不在，因外部所受的伤害化为实体和阴霾，实体即为可见的创伤，阴霾则为笼罩在心中的悸动，因内在所受的伤害化为压抑的负面情绪，时而外露，更多是隐藏在内心深处，不让外界触及，带上一层层枷锁，给自己戴上面具，成为双面人。</p>
<p>伤，会制造混乱，当种子萌发，吸收养分，释放黑暗，包裹着潘多拉魔盒，如同恶鬼一般扑向目光所及的光芒，追寻着光明，却是为了毁灭源头，同化曾向往光明的那些事物，低语着克苏鲁的咒文，如同厉魄一般撕咬着火种，绝望油然而生，而这绝望源源不断，化作美味被其吞咽而下，负面的一切，即最好的养料。</p>
<p>伤，与疼伴生，当感受到带来的那份苦楚，不由自主地颤抖，回想着世间的美好，借由其温存冲淡心中不适，但适得其反，曾经珍惜的回忆在痛感面前，显得那么的虚无，仿佛不真切地发生过。混乱的思绪牵扯着伤口，随着负面情绪不断蚕食，最后一丝理智丧失了，转向曾经爱过的事物，歇斯底里地怒吼，像受伤的野兽一般，伸出利爪，伤害着靠近的一切，直至只剩自己独立于天地，渐渐被黑暗吞噬，变成非人存在。</p>
<p>舔舐着伤口，自我感动地寻求着“同类”，聚集起来的非人们，哄骗着入世未深的，拖入深渊吃干抹尽，不断将伤播种。我想，我也是其中一员吧。。。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo配置</title>
    <url>/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm 和 git，因此需要搭建本地操作环境，安装 <a class="link"   href="https://nodejs.org/en" >Node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" >Git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>具体教程可参考 <a class="link"   href="https://blog.csdn.net/WHF__/article/details/129362462" >Node.js下载安装及环境配置教程  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://blog.csdn.net/mukes/article/details/115693833" >Git 详细安装教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>安装所需依赖后，可以开始安装 Hexo 了。</p>
<p>新建一个文件夹用来存放 Hexo 的程序文件，在终端输入以下命令安装 Hexo 的命令行工具：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div>

<p>安装完毕后输入 hexo -v 即可查看到版本信息，没问题即可继续。</p>

  <div class="note p-4 mb-4 rounded-small success">
    <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/02/29/Hexo%E9%85%8D%E7%BD%AE/hexo-v.png"
                      class="" alt="hexo -v"
                ><figcaption>hexo -v</figcaption></figure>
  </div>

<p>在GitHub上创建个人页仓库，命名格式为 <strong>用户名.github.io</strong></p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./creat_repository.png"
                      width="600px" height="auto" alt="创建个人页仓库"
                ><figcaption>创建个人页仓库</figcaption></figure>

<p>至此，前期工作已准备完毕，接下来进行具体配置。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="初始化并安装依赖组件"><a href="#初始化并安装依赖组件" class="headerlink" title="初始化并安装依赖组件"></a>初始化并安装依赖组件</h3><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init	# 初始化</span><br><span class="line">npm i		# 安装组件</span><br></pre></td></tr></table></figure></div>

<p>完成后输入以下命令即可开启本地服务器进行预览：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo g	# 生成页面</span><br><span class="line">hexo s  # 启动服务器</span><br></pre></td></tr></table></figure></div>

<p>访问<a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，即可看到默认页面，至此，本地安装结束。</p>
<p>Hexo 程序目录：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./directory_structure.png"
                      width="400px" height="auto" alt="目录结构"
                ><figcaption>目录结构</figcaption></figure>

<h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>输入以下命令来安装部署工具：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div>

<p>然后修改 <strong>_config.yml</strong> 的末尾</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<p>最后运行 <span class="bg-grey">hexo d</span> 即可将网页push到GitHub上，大功告成！访问 https:&#x2F;&#x2F;用户名.github.io 就可以看到自己的博客了。</p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo官方网站有不少主题可供使用 <a class="link"   href="https://hexo.io/themes/" >Hexo 主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，挑选一个心仪的主题并进行下载。</p>
<p>本博客使用的主题是 <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，用该主题介绍如何进行安装。</p>
<p>事先根据提供的文档进行安装，一般都提供git clone的方式，还有npm安装的方式：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br><span class="line">npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div>

<p>安装完毕后，修改 <strong>_config.yml</strong> ：</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div>

<p>最后一般都要在Hexo程序根目录下新建一个主题的配置文件，例如 <strong>_config.redefine.yml</strong>， 具体的根据官方文档进行。</p>
<p>完美！接下来重新启动服务器查看有多么炸裂吧。</p>
<h3 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h3><p>如果使用的主题是 Redefine，已经集成了不少有用的插件，在此不再赘述，可以参考 <a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行相关配置，此处推荐的是额外的插件，如果有需要也可以自己去 <a class="link"   href="https://hexo.io/plugins/" >Hexo 插件广场 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 挑选，甚至可以自己开发一个。</p>
<h4 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h4><p>生成站点地图，利于SEO，地址：<a href="hexo-generator-sitemap">hexo-generator-sitemap</a></p>
<h4 id="hexo-simple-image"><a href="#hexo-simple-image" class="headerlink" title="hexo-simple-image"></a>hexo-simple-image</h4><p>新建文章时自动在相同路径下生成存放图片的文件夹，使得文章引用图片方便不少，地址：<a class="link"   href="https://github.com/ZaiZheTingDun/hexo-simple-image" >hexo-simple-image <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>使用时可以直接像下面这样：</p>
<div class="highlight-container" data-rel="Md"><figure class="iseeu highlight md"><table><tr><td class="code"><pre><span class="line">{% asset_img "span>" '"" "<span class="string">my post image</span>"' %}</span><br><span class="line">或者</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./new_post.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span>   &lt;!-- 注意img的话不需要加文件夹名字，因为生成时会自动合并 --&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="hexo-tag-mdline"><a href="#hexo-tag-mdline" class="headerlink" title="hexo-tag-mdline"></a>hexo-tag-mdline</h4><p>生成时间线，地址：<a class="link"   href="https://github.com/wangwei1237/hexo-tag-mdline" >hexo-tag-mdline <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="hexo-tag-bilibili"><a href="#hexo-tag-bilibili" class="headerlink" title="hexo-tag-bilibili"></a>hexo-tag-bilibili</h4><p>生成哔哩哔哩视频卡片，地址：<a class="link"   href="https://github.com/Z4Tech/hexo-tag-bilibili" >hexo-tag-bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>建议将url修改为不进行自动播放和默认静音，修改 node_modules\bilibili-embed-convert\index.js，将标出的位置进行修改：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./bilibili_url.png"
                      width="700px" height="auto" alt="修改哔哩哔哩url"
                ><figcaption>修改哔哩哔哩url</figcaption></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>也许那么...</title>
    <url>/2016/09/25/%E4%B9%9F%E8%AE%B8%E9%82%A3%E4%B9%88/</url>
    <content><![CDATA[<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./time.jpg"
                      width="400px" height="auto" alt="时光里"
                ><figcaption>时光里</figcaption></figure>

<p>那么<br>曾经喜欢过，<br>也许<br>现在还喜欢，<br>但是<br>早已过去。</p>
<p>曾经铭记于心，<br>现在隐藏内心。<br>包裹着<br>一层又一层的皮囊；<br>感受着<br>一次又一次的煎熬；<br>回想着<br>过去的点点滴滴；<br>不禁<br>心有感悟。</p>
<p>过去的人和事，<br>如若还在身边，<br>那么这形同陌路，<br>却不如不见。<br>可不见，<br>却又倍加思念，<br>不知该何去何从，<br>便只能做好如今的事。</p>
<p>那么不如待我如初见——至逝去的三年（初中）</p>
<p style="text-align:right;">写于2016-09-25</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>ND协议</title>
    <url>/2024/03/06/ND%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>邻居发现协议，相当于IPv4中ARP、ICMP路由器发现和ICMP重定向这三种协议的组合。</p>
<p>什么是邻居？即一个链路上的相邻主机或者路由器，主机与主机，主机和路由器，路由器和路由器可以互为邻居。</p>
<p>地址解析放在ICMP层，通过使用ICMPv6报文实现功能。</p>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ipv6_packet_head_format.png"
                      width="400px" height="auto" alt="IPv6报头格式"
                ><figcaption>IPv6报头格式</figcaption></figure>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ipv6_packet_head_format_wireshark.png"
                      width="550px" height="auto" alt="IPv6报头(Wireshark)"
                ><figcaption>IPv6报头(Wireshark)</figcaption></figure>

<p><strong>版本号</strong>(version)：同IPv4，指示IP版本</p>
<p><strong>流量等级</strong>(Traffic Class)：类似IPv4中的TOS字段，指示IPv6数据流通信类别或优先级</p>
<p><strong>流标签</strong>（FlowLabel)：标记需要特殊处理的数据流，用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据</p>
<p><strong>传输数据长度</strong>(Payload Length)：包含有效载荷数据的IPv6报文总长度</p>
<p><strong>下一个报头</strong>(Next Header)：该字段定义了紧跟在IPv6报头后面的第一个扩展报头(如果存在)的类型，或者上层协议数据单元中的协议类型</p>
<p><strong>跳限制</strong>(Hop Limit)：类似于IPv4中的TTL字段，它定义了IP数据包所能经过路由器的最大跳数</p>
<p><strong>源地址</strong>(Source Address)：128bit的IPv6地址</p>
<p><strong>目的地址</strong>(Destination Address)：128bit的IPv6地址</p>
<h4 id="与IPv4对比"><a href="#与IPv4对比" class="headerlink" title="与IPv4对比"></a>与IPv4对比</h4><p><strong>IPv6报头结构的改善</strong>：基本的IPv4报头长度为20个字节，基本的IPv6报头长度为40个字节</p>
<p><strong>取消了IP的校验</strong>：由于2层与4层的校验已经足够健壮，取消了IP的三层校验</p>
<p><strong>取消中间节点的分片功能</strong>：分片重组功能由源端实现，通过Path MTU机制来发现路径MTU</p>
<p><strong>定义最长的IPv6报头</strong>：有利于硬件的快速处理，中间节点节约大量资源</p>
<p><strong>安全选项的支持</strong>：IPv6提供了对IPsec的完美支持，上层协议省去大量安全选项，例如OSPFv3取消了认证</p>
<p><strong>增加流标签</strong>：提高QoS效率</p>
<h3 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h3><p>邻居发现协议定义了五种不同的ICMP包类型：路由请求RS（Router Solicitation）和路由告知RA（ Router Advertisement）消息，邻居请求NS（Neighbor Solicitation）和邻居告知NA（Neighbor Advertisements）消息，以及重定向（Redirect message）消息。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./nd_packet_type.png"
                      width="450px" height="auto" alt="ND协议报文类型"
                ><figcaption>ND协议报文类型</figcaption></figure>

<h4 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h4><p>当一个接口变为可用时，主机可以发出路由请求消息来要求路由器马上生成路由告知（ Router Advertisement）消息，而不是等它的下一个固定生成时间。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./rs_packet_format.png"
                      width="500px" height="auto" alt="RS报文格式"
                ><figcaption>RS报文格式</figcaption></figure>

<p>源地址：接口的地址或者全0</p>
<p>目的地址：全部路由器组播地址</p>
<p>跳数：255</p>
<p>ICMP6 TYPE：133</p>
<p>ICMP6 CODE：0</p>
<h4 id="路由告知"><a href="#路由告知" class="headerlink" title="路由告知"></a>路由告知</h4><p>路由器周期地用此消息通告它们的存在及各种链路参数和互联网参数，或响应Router Solicitation消息。Router Advertisements包括前缀，这些前缀用于确定是否另一个地址共享相同链路(on-link确认)和&#x2F;或地址配置，建议的跳数限制值，等等。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ra_packet_format.png"
                      width="500px" height="auto" alt="RA报文格式"
                ><figcaption>RA报文格式</figcaption></figure>

<p><strong>当前跳数值</strong>（Current Hop Limit）字段，用法如下：链路上的结点发送IPv6报文时，会用该字段的值来填充IPv6报文头的跳数限制字段。如果该字段值为0，说明路由器并不确定该值为多少。</p>
<p><strong>M位</strong>被称为管理地址配置（Managed Address Configuration）标志位，当该位被置1时，说明DHCPv6可用于结点地址配置。</p>
<p><strong>O位</strong>被称为其它有状态配置（Other Stateful Configuration）标志位，当该位被置1时，说明DHCPv6可用于获得非地址相关的配置信息，如DNS名称服务器的IPv6地址。</p>
<p><strong>路由器生命期</strong>字段是一个16位无符号数，计量单位为秒，它指示链路上的结点把该路由器做为默认路由器的时间为多长，最大值为18.2小时。该字段为0表示发送该报文的路由器不做为默认路由器，这时，结点在发送报文时，不会选择该路由器做为下一跳路由器。</p>
<p><strong>可达时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在收到一个邻居可达的确认报文后，认为该邻居仍然可达的时间。在这段时间内，如果结点没有再收到邻居可达的确认报文，结点会执行邻居不可达检测以确认邻居是否可达。该字段为0表示路由器不指定该参数。</p>
<p><strong>重传时间</strong>字段是一个32位无符号数，计量单位为毫秒，它指示链路上的结点在执行邻居不可达检测或者地址解析时，连续发送邻居请求报文中间的时间间隔。该字段为0表示路由器不指定该参数。</p>
<p><strong>前缀</strong>选项，通过该选项，路由器向链路上通告本链路所有可达的前缀，并且通过标志位指出哪些前缀可用于结点的地址自动配置。</p>
<p>源地址：接口的本地链路地址</p>
<p>目的地址：发送路由器请求的主机的源地址或者全部节点组播地址</p>
<p>跳数：255</p>
<p>ICMP6 TYPE：134</p>
<p>ICMP6 CODE：0</p>
<h4 id="邻居请求"><a href="#邻居请求" class="headerlink" title="邻居请求"></a>邻居请求</h4><p>节点发送该消息以确定某个邻居的链路层地址，或者用来验证通过缓存里的链路层地址是否依然能够到达该邻居。也经常用来做地址重复检测。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ns_packet_format.png"
                      width="500px" height="auto" alt="NS报文格式"
                ><figcaption>NS报文格式</figcaption></figure>

<p><strong>目标地址</strong>字段是一个IPv6地址，一般与目的地址相同，填的是请求的地址，该字段不能是多播地址。</p>
<p><strong>源链路层地址</strong>选项，协议建议携带，一般为源MAC</p>
<p>源地址：接口的地址或者未指定地址</p>
<p>目的地址：目标地址或者目标地址对应的请求节点组播地址</p>
<p>跳数：255</p>
<p>ICMP6 TYPE：135</p>
<p>ICMP6 CODE：0</p>
<h4 id="邻居告知"><a href="#邻居告知" class="headerlink" title="邻居告知"></a>邻居告知</h4><p>邻居请求消息的回应。节点也可以发送非请求的Neighbor Advertisements，通知链路层地址改变。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./na_packet_format.png"
                      width="500px" height="auto" alt="NA报文格式"
                ><figcaption>NA报文格式</figcaption></figure>

<p><strong>R位</strong>是路由器（IsRouter）标志位，当这个标志位置1时，说明发送者是路由器。</p>
<p><strong>S位</strong>是被请求（Solicited）标志位，当这个标志位置1时，说明发送者发送邻居通告报文是因为接收到一个邻居请求报文，这个邻居通告报文的目的地址是单播地址；如果邻居通告报文目的地址是多播地址，则该位置0。</p>
<p><strong>O位</strong>是覆盖（Override）标志位，当这个标志位置1时，接收到该报文的结点查看邻居缓存，如果缓存中有发送该邻居通告报文结点的链路层地址，则更新之。否则忽略该邻居通告报文。</p>
<p><strong>目标地址</strong>字段是一个IPv6地址，如果邻居通告报文是由邻居请求报文触发的，则该地址是邻居请求报文中的目标地址。如果邻居通告报文是因为链路层地址变化触发的，则该地址是和变化的链路层地址相关的IPv6地址。该字段不能包含一个多播地址。</p>
<p><strong>目标链路层地址</strong>选项。如果邻居通告报文目的地址是多播地址，必须包含目标链路层地址选项。</p>
<p>源地址：接口的地址</p>
<p>目的地址：发送邻居请求节点的源地址或者全部节点组播地址</p>
<p>跳数：255</p>
<p>ICMP6 TYPE：136</p>
<p>ICMP6 CODE：0</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>由路由器使用，用于通知主机有到目的地的较好的第一跳。路由器收到一个报文后，如果发现报文的目的地址和源地址是同一个链路的，或者到目的地址有一个更优的路由器，都会发送重定向报文。重定向报文的源地址必须使用链路本地地址。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./redirect_packet_format.png"
                      width="500px" height="auto" alt="重定向报文格式"
                ><figcaption>重定向报文格式</figcaption></figure>

<p><strong>重定向报文头</strong>选项包含了引发重定向报文的原始报文的内容。</p>
<p>源地址：接口的链路本地地址</p>
<p>目的地址：触发重定向的数据包的源地址</p>
<p>跳数：255</p>
<p>ICMP6 TYPE：137</p>
<p>ICMP6 CODE：0</p>
<blockquote>
<p>主机不能发送路由器通告，路由器不能发送路由器请求。</p>
<p>主机不能发送重定向报文，路由器不能处理重定向报文。</p>
</blockquote>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><a href="#%E8%A7%A3%E6%9E%90%E9%82%BB%E5%B1%85%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80">解析邻居的链路层地址</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%EF%BC%88DAD%EF%BC%89">地址冲突检测（DAD）</a></li>
<li><a href="#%E9%82%BB%E5%B1%85%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%A3%80%E6%B5%8B%EF%BC%88NUD%EF%BC%89">邻居不可达检测（NUD）</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E5%89%8D%E7%BC%80%E5%8F%91%E7%8E%B0">路由器和前缀发现</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91">路由重定向</a></li>
</ul>
<h3 id="解析邻居的链路层地址"><a href="#解析邻居的链路层地址" class="headerlink" title="解析邻居的链路层地址"></a>解析邻居的链路层地址</h3><p>IPv6取消ARP协议，通过邻居请求（NS）和邻居通告（NA）报文来解析三层地址对应的链路层地址。</p>
<p>邻居请求NS使用组播，比ARP效率高，邻居公告NA返回则直接使用单播。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ipv6_address_resolution.png"
                      width="650px" height="auto" alt="IPv6地址解析"
                ><figcaption>IPv6地址解析</figcaption></figure>

<p>一整个ping的过程跟ARP一样相当于两个来回：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./ipv6_ping_wireshark.png"
                      width="800px" height="auto" alt="ping(Wireshark)"
                ><figcaption>ping(Wireshark)</figcaption></figure>

<p>通过我开发的show ipv6 nd-packet history命令也可以看到整个过程：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./show_ipv6_nd_packet_history.png"
                      width="100%" height="auto" alt="show ipv6 nd-packet history"
                ><figcaption>show ipv6 nd-packet history</figcaption></figure>

<h3 id="地址冲突检测（DAD）"><a href="#地址冲突检测（DAD）" class="headerlink" title="地址冲突检测（DAD）"></a>地址冲突检测（DAD）</h3><p>DAD首先发送源地址为未分配地址，目的地址为要进行DAD检测的地址所对应被请求节点的组播地址，然后目标IP携带要进行DAD检测的地址的NS报文，若有冲突，则被请求节点发送源地址为DAD检测的地址，目的地址为全局组播地址，并目标IP携带DAD检测的地址，以及源链路层选项附上自己的链路层地址的NA报文。</p>
<h3 id="邻居不可达检测（NUD）"><a href="#邻居不可达检测（NUD）" class="headerlink" title="邻居不可达检测（NUD）"></a>邻居不可达检测（NUD）</h3><p>NUD首先发送源地址为接口的链路本地地址，目的地址为要进行NUD检测的单播地址，然后目标IP携带要进行NUD检测的单播地址的NS报文，若可达，则被请求节点发送源地址为NUD检测的地址，目的地址为NS的源地址，并目标IP携带NUD检测的地址，并将S位置为1的NA报文。</p>
<h3 id="路由器和前缀发现"><a href="#路由器和前缀发现" class="headerlink" title="路由器和前缀发现"></a>路由器和前缀发现</h3><p>当主机未配置单播地址时，就会发送RS，路由器和本地链路节点会发送RA，以使主机进行自动地址配置。</p>
<p>当主机接收到RA后，使用其中的前缀信息和本地接口ID自动形成IPV6地址，还可根据其中的路由器信息设置默认路由器。</p>
<p>RS可定位邻居路由器，同时学习和自动配置有关的前缀和配置参数。</p>
<h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>假设链路上一个结点发送一个报文，源地址是A，目的地址是B，路由器收到该报文后，发送一个重定向报文，重定向报文中目标地址字段是C，该地址是告诉结点更好的下一跳地址，目的地址字段是B，该地址是结点发出去报文的目的地址，和上面的B是同一个地址。如果C和B不同，说明C地址是一个更优的路由器地址，如果C和B相同，说明B地址是同一个链路上结点的地址。</p>
<h2 id="表项状态"><a href="#表项状态" class="headerlink" title="表项状态"></a>表项状态</h2><p>ND表项有五种状态：</p>
<p><strong>INCOMPLETE</strong>（未完成的）地址解析在进行中，邻居的链路层地址还没有被确定。</p>
<p><strong>REACHABLE</strong>（可到达的）粗略讲，已知邻居最近(几十秒前)是可达的。</p>
<p><strong>STALE</strong>（陈旧的）邻居不再被认为是可达的，但是直到流量发送给该邻居时，不应当尝试改变它的可达性。</p>
<p><strong>DELAY</strong>（延时）邻居不再被认为是可达的，最近流量已经发送到该邻居。然而，不立即探测该邻居的可达性，延时一段时间发送探测消息，以便给上层协议一个机会提供可达性确认。</p>
<p><strong>PROBE</strong>（探测）邻居不再被认为是可达的，并且发送了单播NS探测消息以便验证可达性。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./nd_entry_state.png"
                      width="700px" height="auto" alt="ND表项状态机"
                ><figcaption>ND表项状态机</figcaption></figure>

<p><strong>EMPTY</strong>状态代表邻居表项不存在或者被删除。发送IPv6报文时，如果下一跳不在邻居表中，那么创建一条状态为INCOMPLETE的邻居表项，发送多播邻居请求报文，每隔1秒钟发一次，连发3次，直到收到应答为止。如果连发3次邻居请求报文都没有收到应答，那么删除邻居表项。如果收到应答，邻居表项的状态迁移到REACHABLE。</p>
<p><strong>REACHABLE</strong>状态的持续时间缺省值是30秒，即在30秒钟内认为邻居可到达，30秒以后，迁移到STALE状态。如果在REACHABLE状态，收到邻居请求或者公告，发现MAC地址变化了，表项迁移到STALE状态。</p>
<p>处于<strong>STALE</strong>状态，如果发送报文时命中这条邻居表项，那么迁移到DELAY状态，准备进行邻居不可达检测。对于STALE状态的持续时间，RFC没有规定。</p>
<p>处于<strong>DELAY</strong>状态，5秒钟以后进入PROBE状态。</p>
<p>处于<strong>PROBE</strong>状态，开始进行邻居不可达检测，发单播邻居请求，每秒发一次，连发3次，直到收到应答为止。如果收到应答，迁移到REACHABLE状态。如果连发3次仍然没有收到应答，就认为邻居不可达，删除邻居表项。</p>
<p>收到邻居请求，创建新的邻居表项，状态必须是STALE，因为收到邻居请求只能证明对方发送的报文可到达自己，而不能确定自己发送的报文能到达对方。</p>
<p>在进行邻居不可达检测时，结点发送的邻居请求报文可以包含源链路层地址选项，也可以不包含。如果邻居请求报文中没有包含源链路层地址选项。接收结点在发送邻居通告报文时，可能还需要执行地址解析操作。所以RFC2461建议邻居请求报文发送者包含源链路层地址选项。</p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>ND</tag>
      </tags>
  </entry>
  <entry>
    <title>再识MyBatis-Plus</title>
    <url>/2024/03/23/%E5%86%8D%E8%AF%86MyBatis-Plus/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本人之前学习过 MyBatis-Plus，但实际自己开发还是用的 MyBatis，基本就是简单 sql，因此用注解进行开发，手写 sql 也还好，故并未采用 MyBatis-Plus进行开发，但新入职的公司需要用到，于是进行重温，才有了这篇简略的记录。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正如<a class="link"   href="https://mybatis.plus/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>所说的愿景：成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。MyBatis-Plus 相当于 MyBatis 的增强版插件，可以一起使用，事半功倍，省去编写简单 sql 的功夫，具体介绍可自行去官网查看。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ol>
<li><p>@TableName</p>
<p>标识实体类对应的数据库表。</p>
</li>
<li><p>@TableId</p>
<p>标识主键属性。</p>
</li>
<li><p>@TableField</p>
<p>标识对应数据库字段。</p>
</li>
<li><p>@TableLogic</p>
<p>标识删除类型。</p>
</li>
</ol>
<h3 id="基本crud"><a href="#基本crud" class="headerlink" title="基本crud"></a>基本crud</h3><p>所有的基本 crud 都在 BaseMapper 接口中定义，只需要继承并指定具体实体类即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>BaseMapper 接口如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line">	<span class="comment">// 根据 ID 删除</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line">	<span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line">	<span class="comment">// 删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 根据 ID 批量删除数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line">	<span class="comment">// 根据 ID 更新</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity)</span>;</span><br><span class="line">	<span class="comment">// 更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line">	<span class="comment">// 根据 ID 查询</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line">	<span class="comment">// 根据 ID 批量查询</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line">	<span class="comment">// 查询数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line">	<span class="comment">// 查询一条数据</span></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 查询记录总数</span></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 查询多条数据</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">selectPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">	<span class="comment">// 分页查询</span></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">selectMapsPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;奕凰轩祭侍&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">userMapper.insert(user);</span><br><span class="line"><span class="comment">// 获取插入数据的主键 ID</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> user.getId();</span><br></pre></td></tr></table></figure></div>

<p>一般使用@TableId(type &#x3D; IdType.AUTO)来指定数据库主键，然后数据库还存在另外一个唯一标识符，一般由后端进行UUID或者雪花算法生成，该标识符相当于业务中使用的主键。</p>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">10059249854L</span>); <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div>

<p>根据主键删除，也可以直接传入对象，会根据标识的主键属性进行删除，以及可以根据其他条件删除，条件构造在<a href="#%E6%9F%A5">查询</a>中介绍。</p>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">10059249854L</span>);</span><br><span class="line">user.setGender(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 实际执行的 SQL : UPDATE user SET gender=1 WHERE id=10059249854;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.updateById(user);  <span class="comment">//返回受影响的行数</span></span><br></pre></td></tr></table></figure></div>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>在使用前需要进行 sql 条件语句的构建，有三种条件构建格式：</p>
<ol>
<li>常规条件构建格式</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapperr&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapperr</span>&lt;User&gt;();</span><br><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//今年刚满18岁~</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>lamda格式条件构建格式</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lambda().eq(User::getName,<span class="string">&quot;劳大&quot;</span>); <span class="comment">//see you again（</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>lambda格式条件构建格式</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; userWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">userWrapper.lt(User::getPlay, <span class="string">&quot;Genshin Impact&quot;</span>); <span class="comment">//原神启动！</span></span><br></pre></td></tr></table></figure></div>

<h5 id="常见的单条件查询"><a href="#常见的单条件查询" class="headerlink" title="常见的单条件查询"></a>常见的单条件查询</h5><h6 id="lt匹配"><a href="#lt匹配" class="headerlink" title="lt匹配"></a>lt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="le匹配"><a href="#le匹配" class="headerlink" title="le匹配"></a>le匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.le(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&lt;=18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="eq匹配"><a href="#eq匹配" class="headerlink" title="eq匹配"></a>eq匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.eq(User::getAge,<span class="number">18</span>); <span class="comment">//等同于=18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="gt匹配"><a href="#gt匹配" class="headerlink" title="gt匹配"></a>gt匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="ge匹配"><a href="#ge匹配" class="headerlink" title="ge匹配"></a>ge匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.ge(User::getAge,<span class="number">18</span>); <span class="comment">//等同于&gt;=18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="ne匹配"><a href="#ne匹配" class="headerlink" title="ne匹配"></a>ne匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.ne(User::getAge,<span class="number">18</span>); <span class="comment">//等同于!=18</span></span><br></pre></td></tr></table></figure></div>

<h6 id="between匹配"><a href="#between匹配" class="headerlink" title="between匹配"></a>between匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.between(User::getAge, <span class="number">17</span>, <span class="number">19</span>); <span class="comment">//等同于&gt;=17 &amp;&amp; &lt;= 19</span></span><br></pre></td></tr></table></figure></div>

<h6 id="like匹配"><a href="#like匹配" class="headerlink" title="like匹配"></a>like匹配</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.likeLeft(User::getName, <span class="string">&quot;奕&quot;</span>); <span class="comment">//相当于like %奕，还有like对应like %奕%、likeRight对应like 奕%</span></span><br></pre></td></tr></table></figure></div>

<p>还有其他的一些条件，例如orderByAsc对应升序等，具体可以自己操作看看。</p>
<h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>且</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.gt(User::getAge,<span class="number">17</span>).lt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div>

<p>或</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.lt(User::getAge,<span class="number">17</span>).or().gt(User::getAge, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h5><p>可以通过 condition 参数动态拼接条件，例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.gt(minAge != <span class="literal">null</span>, User::getAge, minAge);</span><br><span class="line">userWrapper.lt(maxAge != <span class="literal">null</span>, User::getAge, maxAge);</span><br></pre></td></tr></table></figure></div>

<h5 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h5><h6 id="查询部分属性"><a href="#查询部分属性" class="headerlink" title="查询部分属性"></a>查询部分属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.select(User::getName, User::getAge);</span><br></pre></td></tr></table></figure></div>

<h6 id="查询未定义属性"><a href="#查询未定义属性" class="headerlink" title="查询未定义属性"></a>查询未定义属性</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">userWrapper.select(<span class="string">&quot;count(*) as count&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">		   .groupBy(<span class="string">&quot;age&quot;</span>)  <span class="comment">//分组字段</span></span><br><span class="line">           .having(<span class="string">&quot;COUNT(*)&gt;5&quot;</span>); <span class="comment">// 添加having筛选条件</span></span><br></pre></td></tr></table></figure></div>

<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子查询 select id from user where id &lt;= 10059249854</span></span><br><span class="line">userWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 10059249854&quot;</span>);</span><br><span class="line">userWrapper.select(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">userWrapper.last(<span class="string">&quot;LIMIT 10&quot;</span>);</span><br><span class="line"><span class="comment">// 实际执行 SQL : SELECT name,age FROM user WHERE (id IN (select id from user where id &lt;= 10059249854)) LIMIT 10;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>ps:然而调到了另一个小组，没用到（</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title>告别高中</title>
    <url>/2019/06/28/%E5%91%8A%E5%88%AB%E9%AB%98%E4%B8%AD/</url>
    <content><![CDATA[<p>回想高中三年，有许多说不清道不明的意味，就好像天边的云彩，随着风飘动变得灵动万分，随着太阳的映射变得多姿多彩，但云终究是由液滴组成的，在不断的变化过程中，化为泡影，虽大气是不断循环的，但我就好比是其中的一个不起眼的水滴，终究会脱离这个大群体，融入另一个集体之中，这是必然性的结果。</p>
<p>来不及说声告别，就恍如昨天，梦幻一般，煽情的话语已是不及我内心情感的激荡，一切尽在不言中，虽说这三年，我说实话并未真正了解任何一个人，但尽管如此，我们还是共度了高中，经历了高考的洗礼，有的人收获了喜悦，有的人却不尽人意，不论如何，我们必定拥有了属于自己的那一份悸动，愿今后我们能朝着前方，秉持信仰，一路披荆斩棘，这就是我的所感所想，一个在路上的准大一学生。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/03/%E5%9F%BA%E4%BA%8EDocker%E5%92%8CK8s%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="基于Docker和k8s的部署方案"><a href="#基于Docker和k8s的部署方案" class="headerlink" title="基于Docker和k8s的部署方案"></a>基于Docker和k8s的部署方案</h2><h3 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h3><h4 id="传统虚拟机"><a href="#传统虚拟机" class="headerlink" title="传统虚拟机"></a>传统虚拟机</h4><p>传统虚拟机泛指包含完整系统镜像，即带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里运行Ubuntu，就是一个普通文件，不需要了就删掉，对其他部分毫无影响。但带来的缺点显而易见，占用资源多，冗余步骤多，启动慢，为了解决上述缺点，容器应运而生。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
<h4 id="虚拟机与容器对比"><a href="#虚拟机与容器对比" class="headerlink" title="虚拟机与容器对比"></a>虚拟机与容器对比</h4><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程，而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便，镜像体积更小。每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p>
<h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>Docker借鉴了集装箱的概念。集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p>
<h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><ol>
<li><p>镜像</p>
<p>镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。相当于容器的“源代码“，Docker镜像文件类似于Java的类模板，而Docker容器实例类似于Java中new出来的实例对象。</p>
</li>
<li><p>容器</p>
<p>容器（Container）是独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p>可以将容器看作是一个简易的Linux环境，包含内核、进程、用户、网络等一系列支持系统运行的部分。</p>
</li>
<li><p>仓库</p>
<p>仓库（Repository）是集中存放镜像文件的场所，可以把镜像发布到仓库中，需要的时候再从仓库中拉下来使用即可。</p>
<p>类似于Maven仓库，存放各种jar包的地方；github仓库，存放各种git项目的地方。</p>
<p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p>
<p>而喜闻乐见的需要国内镜像站才能稳定下载，如阿里云、清华源、中科大源等。</p>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Docker是一个Client-Server结构的系统，是一个松耦合架构，众多模块各司其职，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p>
<p>交互基本流程：</p>
<ol>
<li>用户使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li>
<li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client的请求。</li>
<li>Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li>
<li>Job的运行过程中，当需要容器镜像时，则从Docker Register中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。</li>
<li>当需要为Docker创建网络环境时，通过网络驱动Network driver创建并配置Docker容器网络环境。</li>
<li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li>
<li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体容器进行的操作。</li>
</ol>
<h4 id="为什么快？"><a href="#为什么快？" class="headerlink" title="为什么快？"></a>为什么快？</h4><p>由于Docker不需要虚拟机实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会在效率上有明显优势。且Docker利用的是宿主机的内核，而不需要加载操作系统OS内核，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引导、加载操作系统内核返回等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个Docker容器只需要几秒钟。</p>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统叫UnionFS（联合文件系统），是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含bootloader和kernel。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs(root file system)，在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p>
<p>Docker镜像层都是只读的，容器层是可写的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层”，”容器层”之下的都叫”镜像层”。所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。</p>
<p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个基础类，自己再按需扩展。新镜像是从基础镜像一层一层叠加生成的，每安装一个软件，就在现有镜像的基础上增加一层。</p>
<h3 id="Docker简要使用"><a href="#Docker简要使用" class="headerlink" title="Docker简要使用"></a>Docker简要使用</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull 镜像名[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本地主机上的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建+启动容器</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明（常用）：</span><br><span class="line">--name=&quot;容器新名字&quot;：为容器指定一个名称</span><br><span class="line">-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)</span><br><span class="line">-i：以交互模式运行容器，通常与-t同时使用 </span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与-i同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class="line">-P: 随机端口映射，大写P</span><br><span class="line">-p: 指定端口映射，小写p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前所有正在运行的容器</span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">OPTIONS：</span><br><span class="line">-a: 列出当前所有正在运行的容器+历史上运行过的 </span><br><span class="line">-l：显示最近创建的容器</span><br><span class="line">-n：显示最近n个创建的容器</span><br><span class="line">-q：静默模式，只显示容器编号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器</span></span><br><span class="line">1、exit退出，容器停止</span><br><span class="line">2、ctrl+p+q退出，容器不停止</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已停止运行的容器</span></span><br><span class="line">docker start 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已停止的容器</span></span><br><span class="line">docker rm 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内运行的进程</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内部细节</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入正在运行的容器并以命令行交互</span></span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新进入</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止。</p>
<p>exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止。</p>
<p>一般来说，使用exec来进入终端。</p>
</blockquote>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝文件，可双向进行拷贝</span></span><br><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出容器</span></span><br><span class="line">docker export 容器ID &gt; 文件.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入容器</span></span><br><span class="line">docker import 文件.tar 镜像名[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射容器卷</span></span><br><span class="line">docker run -it -v /宿主机目录:/容器内目录</span><br><span class="line">默认为rw即读写，可:ro指定为只读，容器实例内部被限制，只能读取不能写。</span><br></pre></td></tr></table></figure></div>

<h4 id="Docker安装常规流程"><a href="#Docker安装常规流程" class="headerlink" title="Docker安装常规流程"></a>Docker安装常规流程</h4><p>以安装tomcat为例</p>
<ol>
<li><p>搜索镜像</p>
<p>docker search tomcat</p>
</li>
<li><p>拉取镜像</p>
<p>docker pull tomcat</p>
</li>
<li><p>查看镜像</p>
<p>docker images tomcat</p>
</li>
<li><p>启动容器</p>
<p>docker run -it -p 8080:8080 tomcat</p>
</li>
</ol>
<p>此时即可访问宿主机的8080端口，出现一只小猫。</p>
<blockquote>
<p>关于Docker网络，默认使用内部网桥来保证通信，一般无需修改，感兴趣的可前往官网查看教程。</p>
</blockquote>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>构建三步骤：</p>
<ol>
<li>编写DockerFile文件</li>
<li>docker build命令构建镜像</li>
<li>docker run运行容器实例</li>
</ol>
<p>构建大致流程：</p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker在基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令执行完成</li>
</ol>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p>
<p>Dockerfile是软件的原材料</p>
<p>Docker镜像是软件的交付品</p>
<p>Docker容器则可以认为是软件镜像的运行态，即依照镜像运行的容器实例</p>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<h4 id="常用保留字指令"><a href="#常用保留字指令" class="headerlink" title="常用保留字指令"></a>常用保留字指令</h4><ol>
<li><p>FROM</p>
<p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是FROM。</p>
</li>
<li><p>MANINTAINER</p>
<p>镜像维护者的姓名和邮箱地址。</p>
</li>
<li><p>Run</p>
<p>容器构建时需要运行的命令。</p>
<p>两种格式：</p>
<p>shell格式</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure></div>

<p>exec格式</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>EXPOSE</p>
<p>当前容器对外暴露出的端口。</p>
</li>
<li><p>WORKDIR</p>
<p>指定在创建容器后，终端默认登录后进来的工作目录。</p>
</li>
<li><p>USER</p>
<p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root。</p>
</li>
<li><p>ENV</p>
<p>用来在构建镜像过程中设置环境变量。</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_PATH /usr/java</span><br><span class="line">这个环境变量可以在后续的任何<span class="keyword">RUN</span><span class="language-bash">指令中使用，这就如同在命令前面指定了环境变量前缀一样</span></span><br><span class="line">也可以在其它指令中直接使用这些环境变量</span><br><span class="line">比如：<span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MY_PATH</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>ADD</p>
<p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包。</p>
</li>
<li><p>COPY</p>
<p>类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件&#x2F;目录复制到新的一层镜像内的&lt;目标路径&gt;位置。</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src dest</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;dest&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>VOLUME</p>
<p>容器数据卷，用于数据保存和持久化的工作。</p>
</li>
<li><p>CMD</p>
<p>指定容器启动后要干的事情。</p>
<blockquote>
<p>Dockerfile中可以有多个CMD指令，但是只有最后一个生效，CMD会被docker run之后的参数替换。</p>
</blockquote>
<p>与RUN的区别</p>
<p>CMD在docker run时运行；RUN在docker build时运行。</p>
</li>
<li><p>ENTRYPOINT</p>
<p>指定一个容器启动时要运行的命令。</p>
<p>类似于CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</p>
<p>可以和CMD组合使用，如下：</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>] <span class="comment">#定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment">#变参</span></span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>Docker命令</th>
<th>实际命令</th>
</tr>
</thead>
<tbody><tr>
<td>docker run nginx:test</td>
<td>nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td>
</tr>
<tr>
<td>docker run nginx:test -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td>
<td>nginx -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td>
</tr>
</tbody></table>
<blockquote>
<p>与CMD相同，如果存在多个ENTRYPOINT指令，仅最后一个生效。</p>
</blockquote>
</li>
</ol>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./Dockerfile.png"
                      width="500px" height="auto" alt="Dockerfile"
                ><figcaption>Dockerfile</figcaption></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>打包jdk到镜像中</p>
<h5 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h5><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像维护者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> yhxjs@****.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置初始路径</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/java</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行必要操作</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get -y install vim net-tools</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /usr/java/jdk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加jdk到容器中，安装包必须要和Dockerfile文件在同一位置 </span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-17_linux-x64_bin.tar.gz /usr/java/jdk/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk/jdk-<span class="number">17.0</span>.<span class="number">4.1</span></span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME /usr/java/jdk/jdk-<span class="number">17.0</span>.<span class="number">4.1</span></span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露80端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印Java版本</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-version&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>

<h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t myjava:0.1 .</span><br></pre></td></tr></table></figure></div>

<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it myjava:0.1</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>小丑</title>
    <url>/2021/08/16/%E5%B0%8F%E4%B8%91/</url>
    <content><![CDATA[<p>破碎的天空沉入海底，泛起阵阵涟漪，<br>孤独的太阳浮出海面，映着波光粼粼。</p>
<p>黑白的人间恶鬼游荡，<br>没有镜子，<br>看不清笑容背后，<br>阳光黯淡，<br>照不亮眼泪，<br>火炬已灭，<br>想不起。</p>
<p>哀嚎着，<br>究竟是人是鬼？</p>
<p style="text-align:right;">写于2021-8-16</p>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./joker.jpg"
                      width="500px" height="auto" alt="小丑"
                ><figcaption>小丑</figcaption></figure>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>呐喊</title>
    <url>/2016/10/30/%E5%91%90%E5%96%8A/</url>
    <content><![CDATA[<p>回想过去，多么怀念曾经的美好时光，但却早已只剩下那渐行渐远的一个个瞬间仍然徘徊，转瞬即逝。深入骨髓的孤独感慢慢侵蚀着我，迷失在人海中，与自己的影子为伍，不时躲闪来往的行人，我只想躲到阴暗的角落，回想过去的点点滴滴，仅此而已，但外在虚伪的皮囊早已机械麻木，与这繁华世界格格不入。此刻，我只想呐喊。<br>内心的苦楚遍布在每一个角落，想呐喊，却不行，就像一个异类，不被人所正视，即便有，那也是不长久的，顷刻间，可能往昔的情分早已烟消云散，不复存在，只剩下那充斥着虚伪笑容的脸仍留在脑中，久久挥之不去，仿佛在讥讽，嘲笑，我想这是不能呐喊的原因吧，因为它无时无刻不在压抑你，让你无法置身事外，世间种种皆是如此，想要逃离这一切，却发现自己早已被捆绑住了，无法挣脱，甚至无法发声，身边的人诧异地看着你，你的那些看似有些另类的行为不被人所接受，因为人们习惯于司空见惯，而当一些不正常的东西出现的时候，他们会质疑它，甚至去摧残它。</p>
<p>呐喊，我只想呐喊，在广袤无垠的田野中肆意呐喊，在这里，没有人去讥讽、嘲笑你，似乎很畅意，但我不能，虽然世间的种种把我压得喘不过气来，但在这一片黑暗中还有零星的灯火——真正爱你的人，回到他们的身边，种种不安、惶恐都消失了，尽管只有一段段短暂的时间，但内心却是如此光明。也许将来你们会离开我的身边，但我还是会挺住这苦楚的肆虐，在这万象丛生的世界活下去，去为了寻找一个能够陪伴我走下去的挚爱。</p>
<p>在这之前，我只想呐喊，当我渐渐长大，亦或是变老，头发渐渐苍白，如今炽热的心也许会随之降温，但我仍有信念，仍有为之一生的目标，这便足够了。哪怕世人无法理解，但我保持自我，我还是我，放纵着我，在这世界中茫茫一点，不奢求改变什么，但求初心不变，这便足够了。</p>
<p>在这世界，有许多不公平，但这往往是表象，许多人想逃离这种不公平的现象，转而追求那些看似公平的选择，这本没有错，但这些人为了公平，将不公平强加于他人，只为了一时的利益，并不能说人心险恶，这只是人们为了自我保护和那万恶的欲望作的祟，这可能会毁了一个人的一生，但人们却不管不顾，仍旧如此，只有当其波及家人或自我的时候，这才会看清本质，停止那愚蠢的行为，但有些人仍旧被蒙蔽，做出无法挽回的事，这充斥在人世间，几乎每时每刻都在发生，我厌倦了这种选择和拒绝的过程，而结果也不再那么重要了，无非是为了欲望，还有那可笑的自我保护，所以，我只想呐喊。</p>
<p>生活中的某些事物会将我们置之于一处险地，在这里，只有你自己，周围黑漆漆的一片，这强烈的压抑感会使人喘不过气，但又不得不去面对它，独自地，将它打败，你才能走出去，这时，你的心境会变得更加强韧，但往往会有许多事物会影响你的心智，妨碍甚至阻止你做出关键的选择，如果你放弃了，那么你将沦为它的奴隶，自此难以自拔，只能任由它侵蚀你，肆虐你，直到你的最后一道防线被攻破，那么，你早已不是你，你将会被改变，变得麻木，没有丝毫情感，一切都将无法阻止你的决定，你的选择，你的一切，因为你已不是人，只是机械动物，我怕，会成为这样的存在，所以，我只想呐喊。</p>
<p>啊——这一切究竟是为了什么？也许究其一生都不会知道，只能默默、平凡地活着，让尸骨腐烂在地底，让世界遗忘我曾经存在过，而这一切，都将成为消失那一点。</p>
<p>我真的只想呐喊。</p>
<p style="text-align:right;">写于2016-10-30</p>

<p align="right" style="text-align:right;text-indent:32.0pt"><span style="font-size:16.0pt;font-family:楷体;color:#215868">蚝油<span></span></span></p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>我</title>
    <url>/2018/05/06/%E6%88%91/</url>
    <content><![CDATA[<p>飘浮着<br>流荡着<br>望着远方的夕阳<br>我知道你已逝去</p>
<p>踌躇着<br>漫步着<br>听着身旁的乐声<br>我知道你已归来</p>
<p>也许<br>来来往往<br>你已老去</p>
<p>但是<br>往复之间<br>越发真切</p>
<p>我知道<br>你<br>一直在追逐<br>追逐那心中念想</p>
<p>我知道<br>你<br>一直在幻想<br>幻想那世间美好</p>
<p>我也知道<br>你<br>曾多少次暗自神伤</p>
<p>我亦知道<br>你<br>曾多少次触景生情</p>
<p>因为<br>我知道<br>我便是你</p>
<p style="text-align:right;">写于2018-5-6</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>学习路线</title>
    <url>/2024/03/03/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请重新输入。" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fcd872a8a18954221eb5bec248309c4032caa06adb0df6b6a1cd208009af638a">7e302a64c19ca2d3ce010e4131597270786b1bb1aaf244198f42d692eb66feb4bc070be16da0a052557145b88b06a7387e3029ffbbbb6130fe0a097cb8511ca043a3a1ac49a1c8d6e3209fbd33f4b5ec808511bbbcbf9eed5db3d988448945fdaf4926c793654b80518ba075a6b012b2b528ba26ffb32b6aa542d403457d3f99e138490ec2452377bb9d0aa0876d21a39ad74194eaaae82bac2f29811278064ba1ad8d323242753fcec2d647caf57e8c68a1631c6ea4b6795455aa5bddb4a7a5a6984c24e714e3a1d4b6a1f5b40d103dff22152cb5767dc0a07e63d419d50e66a3bacd98da6b63001b6dca188b97684ded665fa39e575da0bb50467826e5ab6c4e9bc7c13e5ffd851a763e80e8888f1eb158ace8a3adae10e4952a59972ded7b629425a5ba52a89aa1eb7f33f9f7a05e2282c8dd2eebdff6cbc5ff68888ad769e483801c95580f6dd44181059e723b45f1fad1441331cea7c03cf97f53e7bbceb448a73794b615a27670c7f537a9c0a360483360caa5392103a0a8887c3638cb9e49ef68db8040d2bfba1151e13c678a03996de7eb7942afe332a110eac08fa47e6c6e0ac1170d4ede7d0cc4e3cfc361c8e7e46aa9772c81e54cc1b1860fd6d08f2eb449ec0070f9f3a8162522a544bab118fb9a3234c10d03c9fdef4589ca16f812d81e033618be3866d1dc6668f8a08cb1cd9cefc5c7f6dcfe027c736e704176c9c3f75175d7c8c0852104d043665cbe3e2aca512baaf852962b738a979e4a0c0aae312650f44bc3239b826102c17e1e9d7f63fe28418a2487b913515c15782cd7a799666617bb8c49f1f6b6f4e4c758a8ba1f52b017517a27f5824b06817b4c24374441f553427fc8caf213d20e780d69ca47bc27a799bff3d895b50b5dc1a9773881963fa87203c2d78abed04f544dd4302843677e7e3fefac05e85f4879404a1fae894d13a6ca799b0b6e2c9f6222c7973239865cf5f59d645d62349f8645c2e852d24366c5149903c8042effb49e3b513f7138905e63070c65e09036604217472a4e1b29e6f6fe3e4b5c6ec873275af907d941e05fea1c9a009519b4b22d60c43f7661efea590b5a85170908fde78956f72a07c619eab9211dc2b2c7deb69fb6924b659d0e9e620f264c67af600828e4f3271a017f36249688ef1c45fcb2e0ad046ea84df8b3453e599365a3ed4a2d3123e88c84d23fb5d252bffb78ce4f7743912face06c5f0509b96c59f7ab815c00c5c7ff19d4edf909f0797610aacd54e12819bd04e9322ab69c9c0a969191ada2d3926f588e7ad54cd323632033cbec7c345891d53cf2c7dd566a888fbff271258b42f01cfaef3b87d6b660a928889bddbcede75e86cc0b28e8a7e5f8cfbfb75743436c86a48116ca0a24126bcd4790114ad22f2254d4f54ae663437574bcbd53a3a7a81dc066e2b37601836679b9eb5bf061368d82d99fd3ec79037eb24bcaf6130d7eedb69eef6fc0d3a3bcf197f4d243a61f272407c7399a446da734325a3d057459ae9b486045bd55d2d5e3c50c2aca45f13257a3d916dec48ce80382f53e5295a691c4842c74b02407228849e96782179788918da40ef252656db9e7c524ba793e5965dbcfb4a8e8e0d5d3a3fc0e155f5ff2b3debbf4f0d261bf6c61e251e28f068d212722aca95a476410f12aa2580dfbb0ef0163532a61925506e645da8dc4cd5ae960ccbd8bd05094ba81016a3ee4181bd7c383e0b5bd573e5eef0ef546b1a0846af0c6b3b583a2cbad7dcf7aabc61a27bd36aa997a1c4508ebcfec0459960cfc35bc55477158a0923d1e79fd04e5414b6e219df9727d7030a2b05c37243264470b9c491b71b840c499d06d4ff19232b800579722d0fb8c281df6b5a54e4b0fe252fecc5c3dd081da3fcdb629c8d4f274d003155890883791c1b6e731ea0bd2f297cde53a49d1aea1233a39103cab73d3454e3a6ae70a310d6be786d4d9dc40d2b7d74bffec2a76d3444fabf4309ea25fe6113f2b771125804c24394966bfc50ab206519ba84bbccefcb715d69a020651fe01f797486c12c54405bb0ca40a50a7b193e5e3617178d982d35370517af59205004ae784934c108fba3568433b7eaaf184fef2a88342af90a2cf1f92d5f78b293e5044b47d4e064ff496a05714e531619477eb38953faed1ea67380fa73df0afec0e415978d1afa6b9a2fb952575a197bb86351946df3965dd858bdbc55ff067b26c252dc7cc13fcd3f3206f82ce231f5970e43aa65dc9c53cefd494b30776d9128fdbdc9eec0f969d53b2905a47a92e4e19ad224b7ab950344043c6d53cdaec9e739a4968d6d86f2c833d283d9fb88ce043fb203fbb7bbea6c9db3683efaf2426a8847df5730c920a637f4f324bf7dfefa70f7096fd9fbc0481ca5fc0b5b89d0b605c428ebe71d1c59c06620670f316d0c9e90fa6e29006446d2b3af79fc84ff604c4192db8548f1c2373bbd401ea9b3153195a0bf7a6e2858ecbacbec605fe763840d8eb1b899750e6064b890a362398871604d7b8bad7065e5cc6dc6c19d9ee8723161c7989723b315608bd4e2b37f9c7c44776d925f120c4cd1408a62dc8e57fce927789a09aa54e46875cd78f5af37720d890113b24e68a12d97da5f4a395a383b242e1570c31160f0a4c948c810dc59979d51971f90a6c5be91e7ef1abe178e25978a2a187872b6d0fb6086ec078a83111cb223f9f2843ecf636ef594c44c48409f8a9cc71d55d1c40266356c1b32f7e3753cfaa4670976b6f5245de0eaac54f9d8b4d36c166673749114159c186212d59f6f486141a314a43fd0153939a861ac8d09fcd911f0e6f006d019861f2e22f8a53ddbd7706982727fb759e7989250580a723d714e81c1772ebb0d74c5795d2a5d881724ae5a574e22402ad02097c64fad3d2f921f04799230cccc327c2a1c3979dc3a0b7e7f5c012b50e4607c6ba1f0efaef9abf57dd3053d6c95c5c8b9b49f6784e6f70ccc31a0a1f9d6002ae7a14a14e02f3b211c8c6188a581f42a17e0eae92f9d0c765ddcc2bb1aad1688ba5191cf950cbf4d77dcb61999aa0022cd6a3bbf8bb4660aaff9e03430937649f73b5f368e11a849fbd80cd243c2c5200e2c322c6864d4493db52ef92441e597bb691342c2ee2bde1d6c0d89658e6b5da26e2ef99817d58e607e4f685ddbf0ddb801d979412c4cdfaaf503e2ee4fc37067f0ae27c49af14680b9543e55d72e8b90de6e6690f23754f14fb13b4389dc98d3f90ec147219310ed97d939380fe496695aae506eba74131619cd4f4835b2396f7a5f7ea958a78362465a11a330af9ed23f2fdb160a78a90b40a3a24616dd0c3fcbc38cc3309483bb667e36bea412ff9b87e092b3f969c2d307be0bc91295b6590257be4dd82f8d984b8237f601f4248371f92a7be29caf3ae43861e1ee0b622c17e5db7eb710bb397d15e869cc3f2b80dad790d9593a7658236a7c08c4d0e205e84c6345228aa84d7342487c8411af7dc35283a7c1c388ab081ba1246242154c90e39d1cde511f20e0499a6822de5e851aa3fb901e259e512ef0c9f9c841fa459f54e74bd58359cfef4406427763a7f88dad64777df66c0cc6942bb6184089488d9a4b422d523f01964d403cf54725d49ba1ae7938c72d1ecdccf188dd0e6ad808f8de81ae37578f8339360ad9378fb5e2e24149eaf969836c5b35a5f6171f5dbf22d2b53a8279e945fbbed794eda5c92b3e7748f97162d9cb476ae1b516c9f637e1e2c31f0945301f41ffa01705670920e56719399f32b1f9cafd331673f68ab8d55edf28b0167f06d18a96bdd64243db44b935dbfe9a644b428b12186fa8bf4acfaabcb11a989d7ab62c3789074ebe442c131c2d8a82f328f87d6bdd17676ab16c8244400e740fddb58e7b9984432f976837f23244d8c34c84c0e22d9184e3feea47bd41fa78443f34683d1cb2653dc001da20b43b0a6865a4a550481752cf6d04666a5465b3c8ebe4a6f0a8818ccfd2610b5ebc9ca55bdeef887ff5c4352147ca8cfaea7639dbcf40edbc229ccffe0cc9d666b3cde15d7a3e2cc98bf32be412bb6fb5b07af5163abb9587e69ee296c0b943431bbd8a70e5ca213671a2beefc93ff915c1fa294a7221b43aa754dfe207f66144829b54225b78f0cdc5aa4dea708a55b7afa4ef7040a541067d61a3c964ff4c6ce80152d189d807b2909bb718379fb44098df5d7426d5597cb3e87219a800672cb05e2f5a8446208dfae73d45888ad9996e5d0342c82e35597a06055c735e7afb17118c1e8c6140c607b888807c695d264bf894b60b99e90bbb20ca6cb0950b012c7031b767fd6daf1671939a49b1f78f79dcf67e0afb1a537edbd81ce2bbfb246f8e7ed3934625b78f11a86e0f06216f659dba527c406fdbe402d18ad6b29c86bbea1e7dcc0a4ec66e38f8169940d3a3721dd0ab375d546470ad10db57c41432cd5d0a56d956885bc0607aac39ec7b52b05e9f3768cd0eec9aab86ffefabd74968bb0fca3294356bb2600b508b19a9721c32a301d8b66acbb1e38b0aa3ed1c321625f2786601aa7bba88195f442928143f828070507d9086b48460887f314afd6ccc06993db086d0f0d91ff8d92ed10aaedaddb2a3cf5cf00c7c41c54a434b2ccaed4185d029d6a8917729a9b6f347acb20434a592d9e28b290c20a1e26465ba2e232e8165b3553a0329214de11314fe0dbd38dab6a2b7a15cd0828ce0e11592e282f22ff65b9d4c30b241db46d04a510102db0d3da88046119f68d8ecd28b0041d6f7c49a1f97b2f3ee910b558e322e1c4a0747985d59b1d59b28d3fd57e7b5a6553d6cced1982ea799336a256b6ac0c1bda8244cad82bea85f9fadea6dace60d277d4e7cb20f03430ff54c218435032c0a574a1cf02be3587254a355e26597e2a26ee52444f784e58570ccaad574bb12c3d8f903b1116c03b28c2d243c364955ee58ee14113612d1bf757441d99075a32e8fad3b79c9d27a61742121fe1c429ddf43920c7b677cafd935c485074f123b6f7dbad4a2fa4e6244b2e3c9078461741f0d35ed9f379530471df92a7a911cc522aaf76ba291e916b23959109595dc8c2a6a7877c49666b1048eabc8ebf2f565103027d065e91aa3fda5ccda5883e703ae098e1e9cef7d74f5d77e9a89db6f40ded9fb07a1e96bab71b4a1880d47bddda751d407d1073848315e2545dc1d293f51ae5b5da65b96d811f7dfcae49e4bc461f999ad46b6e7480595ea0e244cb486fd2a18db5ab759f0684dd42808f6d56854c2f2a9e7bdf5783ef897ce8d918281f567fdbfaa2dc3c78618030688cd83aca2fec7d0269aec6f2fd56b403573b0150aa4401b234e1063c73d2db713170658ba574277878282c61388a74db49361b9df62291c02fe72229d385440a542edb6b5d49a035441ba3c9f47bae9b594ce9cbb49181377eb466fb5c91e6e90d6f449002865010c260336fb7b8341b9be9ebbc8da96010f9154ca98384b9ae8686a848a31dad6ff5e0b28d364a3fea816ce581a0883159dfa3070e3b3d0c2ef2eebe96594d87ff30024bc9b30e0393296dd9269a4b540dfee54b8af0823bfd9ba9b4ecd375d2f2e3fee6e770f4f9a33b9cc2f95d028d8a5fdebfdf684f6cc140f57b66acbc9b842d414d23a9ad8403b199ae7c66ce91ddde60b09d12daac53d1b42ada914c27d5d629ae5cb07a4a097015cfcff786ec28d6c7b4659dd95411ec55655be98d5f4c4e1f1b486920747cdd434989e51c9e3f65d966e865ffed06aa8cb94f9f71551f62762fd8c867caff3989bda035c5e9fcce80f5c602d039e33a9b9978fefb081f934a701464c31be557882e41d735e7d1dfbdc528bdf5d4d3193d97dddfdf87161815883ad5a411ea503f582211a7c3662d89a89b718ed323e80ba40c4616814665508d87619f0fa1bd1c412531bfd7e4e6cace850f59a57150ee94c738d65b41b870b43e631c8b3180e3fec98e6c43e68a63eae94e929b8e7b6c482248fe6d42e1eff95ddaf60db41660842a08ad9be993935d81c44b126d25e60e7ea1fc0c5ffbd0340aef680f1c073c2dc25ed156453395632cba0443e7a96173626cee6a8997fb30bffca87221b7bbcb1cbb38181b12a34bd6f6b6fe0585b9e467f9208fbbf3d0c58ed91df5d13942326c7c8bd03ad85637f2761870660bf9bd49c7aca5cba68014da63baa5f71d880dedb65d4983e5bc9da58ac72a4c28ecb97eabd9301e10f9602ef57bbfed94fdacaa50f390779171da55eb29941268976588bcd0e85edc57ce2cf7d4ce03c5dcf41b218f904c3a452f5a22a5aeacdeda7ca2564a4d298448f49077b2504434db58bd1c4e4792ba150f77da9e76e09a15e0722abe8a2e2b7059c9812243673887d872cfdf35c16c748bc5a2d2d58ac0dc8b5fc2ada0dbe40ec9b6438e5f1a7cf18df91240942dc5f6410e5fb79486d42013981816c4da8052a1595280d9608831c9986e2aec705e72804cc31d164dadf9b341cf4b777fea4483028cfbdd5a4ca6a55d89bb993417c074d4cd4158b8291cba93f81edf95e6cd1009a776344cd171ba01039f4f594a12b5c68c9991160aba10535ead809265f7c2e6feda97cd4398653e72a4f5742e141d7d36b30ffb4d43dc5802fc0a33c4ea534cc33f9cd73e987cb95d4c8db78cd5525a1e2792305578181153af1fb011e1043c6aa79991e9a1cb2c0b682a55f1c753e21fe8dbcd963291cb5bfd2b9acb5a499727ea0874b1f2ee0f4a1586277f28611823d3b860f359b32ac2e11ddf6ac9b6c017c34dc9a1d3ebfb0445a24fc092758390f511251ee3fda0441b0f1ae2f474d9ec418410d0beaa560cbd9ac7631c40666442d35445fd7388e13f3032a3042e89ac38046700dd46abc926d8e5eea50ea37fd42308aad7247e586c3578175b543640cfdd300dcff36c6b933e73f4ae5bc49369cddc6a9c868a97e618b279fceb5f1f5c2d93e1f3294367a2b5aa63bb28b186da2d5c488061a507b3574981dcd98c305841eeef2c48c2a067d8f3bc3da682f23825fde8c40225646bf945254583d266ccb8fc96fc548df2c7d4316faee1a5574afd425cedd5746829dba46ca3c407a013db1b3b85bfd62b2c37342c1642850c17df5407de96728991556bc844345df21454aa9357782a7ec976a831bc6ac8367db7e42ed61e1cfb43953af26886a61573e5216c92aa802d1bcdfa639960854f45d1c6dab7c542b685197e56a1d222c5442f8540f91e10d9dd377d0bb97ac0bdca77bb967ad3301e474dabbc5f5a740f3c25cca8bbe241e0df592d3ba237915192b62eaf49008524dc7cca8d9fc428f55f35b118dd16f21b8c0cea6947c4bede806658681223196335ebd4cff569c5efb95f178eaa872b4756a55398dd70fc4307a4dfb6268b39143dd37cb3099e8c8e29be0233b6283d3fbc630ba0b29eadfaafaf9c681e621b65d05d239dfb4116c360d6837ab8da6396581020eed80fef9caff766784f0f44c7fe8e0258a1a7d84a0ee5956fc85a18fba291ce00b5e6f52339c166d5fa2ea143caa9a9fb04dc544e2513c44f1f674488d3f2700f8113dedcedc162643abb1cd6c1b6f42fca0ed85ace8d11158ffd8b9bec99093418f3dc2dd45cb2c8715a1c0c544ca0395916f2481549b1c99744864c66e18db04a36e773c7eec640dc40b8b81c2e87b499d57cf802e949680356d6521e82d559fd8e33f326650dd18551aa40403397101b105020283d06025eaa6919fb0a0359d8107a0bbeff5a4733014467ea0b6d51f85e2eeb14ee9b138e5d8c092861cafdcd60bd071b34051319371efdd68c4791be022f5f1256adc5c31d2b69d120eb8ecb5f47d700b9dfdfa099b2e5e8e5db0dbd3ed546d18200493f40928bddea332401ab8ac43c35fcf32c2a9d498c4f10a8b26d56387f4e8f5d23b0d1c538b44dca774e04eb645b2bcb0ff3e61dcca359b2a5b359bdf58cdd57231c5a38aaa37f01ae7f38104d45c69109796cd82c7a7b2ab52a3be1d822f50451bf25d1dbd241a48e91bbdaeb0064544810168b5113a1adbf04f16dedab798cc498ed33b87762144ade62bb6542dfd40b01e5687f9e824513024d1be123eef63398cae0f743e189be8ba061eea920245d7bab094e861049cde4a84b258289b4eae060c2c01e0f863267d2046cc50270704a145bdae7fa1ce050958b209bffaa74c1ff262c3b83db62ed1db88773bcb2af87459b8b3ec1e48278334812b5726a0e8f73fa18c696b2e7438cba18922c040d1204762aec9534c82f955f83ff54a3be8df948da0af93212346bf32d0d73e67303427476198fca32dd374c4482699bee8e770f815da2927401f289b70dea6d3992dd521e1cfcb4c16575aca99a6f3dae31968e57ca2dc1bd9030ecf0fd277ead6057b046de8f8df08ee5196ead1c3187d1fb323578cb1a6955e0445f1313f8349c4b910ca570edc4e115fac4e0977a9f30d854530dd429b8d89e4c33a120162cfe8c9dfcb17dc665b0ab3fc1a1cfbc05a321f6747caf13bf2dc1be2e1ef736608425c4cd78131ddb847fd9cb6ceb9572e5f6418f3136bf14f23cd4c30d2a5b840d2fb01e00f7563ed43050ba28c98759d014e91d5a78c5dfe07bb70a55d4e811c6810994cfa45700b8d2633bf1fd0b9bf4fdc03cafb5e828dc79687bdc2676efaaa8636f5204c712add719d98e6aab8cce93519cab08a3aaef5a2877da9d68b6b719dbc72eb4d42558821f5a8ca06c2ab869a38616f57d0f48eb7a7fcafd66811e6fba3d1621883bdb035f2220241312e4de913e1545a6212b7c5d696ea31a18986585d31d6922f7367eab0c69d69e7ab52e9f06b032807a288b6992b60330d727c0733b14ac8e12b595b353db688c006fb6539c99a243b0dc4ca11dd8d62bd9bae8b38beab4a4e7dc3095a892836fed09f36f45df9002ba741c8d075203544ac2a6524cfc5ef69f71d265a4aedd7ea876128d037139ad8d6b500ed2f4264f3aba7bc7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以查看此内容</span>
      </label>
    </div>
  </div>
</div>
<script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>沉默的大多数</title>
    <url>/2017/01/14/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/</url>
    <content><![CDATA[<p>沉默，一切无言，对于世间的种种，我只能冷眼相对，不是冷漠，而是心力交瘁，感觉内心充满了黑暗，却装出一副无所谓、不在乎的样子，仅仅是为了更好地融入这个虚伪的世界，那又能怎么样呢？迷失了方向，只有家的光芒仍引导着我向前走，尽管前路茫茫，但，路在前方，坚持走下去，哪怕是为了自己的信念，也要咬牙坚持走下去。</p>
<p>可是，却早已无力，瘫倒在冰冷的地上，看着天空，白茫茫的一片覆盖了蓝天，仅露出些空隙，光从中渗透出来，洒满了大地，也照到我的脸上，麻木的脸颊甚至感受不到丝毫暖意，此刻太阳仿佛冷焰一般，燃烧着，却冷到无感，这早已不是火，而是晃动着的光球，散发着寒人的光芒，世间这一切仿佛失色，在这天地间，仅剩我一人，自由地飞翔在冰冷的大地上，内心燃烧起一团火，双眼只剩下无尽的深邃，毫无感情，无奈化作脸上那唯一的标志——沉默，无尽的沉默。</p>
<p>曾几何时，可笑的认为这世间如此美好，却在一瞬之间，破灭了，一点点消散在内心深处，化为一道道无法修复的伤痕，触目惊心，却又蕴含着对从前的回忆，不禁交杂着一种复杂的情感，在笑的时候，眼角却冒出了眼泪，内心痛苦，牵动着神经，身体做出抗拒的表现，想要发泄，却又不能，只能任由它肆意破坏曾经美好的感受，剩下一片废墟，慢慢沙化，渴望雨水将其冲刷干净，却只有几滴眼泪。</p>
<p>无言，岁月流逝，也许废墟会重建，但一切早已不是原来的模样，只有那面目全非的痕迹才能证明这曾经存在过，只能独自缅怀逝去的青春，却无人能懂，烦闷瞬间爆炸，将我炸得血肉横飞。一次又一次地隐忍，早已受不了那倦怠，我只想逃离，逃离这一切。</p>
<p style="text-align:right;">写于高中某天</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>把握</title>
    <url>/2016/05/14/%E6%8A%8A%E6%8F%A1/</url>
    <content><![CDATA[<p>曾经放眼望去，时间就在那里，现在却找不着它了，只怪我没有好好珍惜，等一切都变了，再来追悔莫及，一切都晚了，时间从手间划过，留下一道道触目惊心的伤痕，也许时间会慢慢抚平，但当那时，心早已崩塌，化作一朵凋零的花蕊，珍惜时间吧，时间也许就在那里，找到它，紧握，不要让它再消失了，让我们把握当下吧，也许酸甜苦辣，也许会受伤，也许有那么一份保留的纯真，也许还有那内心深处的感触，去感受它们其中蕴含的真理，那么你的一生将由此改变，也许变得沧桑，也许变得开朗，也许什么都不会变，变的只是你的外表，而不是自己的本心，不忘初心，方得始终，虽然人终有一死，但死得其所，才是最重要的，而当初那些觉得重要的，却早已不重要了，记住，有时候忘记是最好的选择，而忘不掉的，往往是那些你爱的，深爱的，或者是恨的，而这些都将影响你的内心，因此你要控制住它，不让它侵蚀你的内心，保持着最初的那一份念想。</p>
<p style="text-align:right;">写于2016-5-14</p>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./elapse.jpg"
                      width="400px" height="auto" alt="流逝"
                ><figcaption>流逝</figcaption></figure>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>溺水</title>
    <url>/2017/04/08/%E6%BA%BA%E6%B0%B4/</url>
    <content><![CDATA[<p>渐渐丧失知觉，阳光仿佛随我一起消失在这河里，逐渐黯淡，岸上的呼喊声在耳边若隐若现。有那么几刻，我甚至怀疑这并不真实，仿佛做梦一般飘渺，它就那样将我拉入万丈深渊，我不禁想要挣扎，去挣脱它的控制，但毫无成效，反而使我越陷越深，我感到一丝无力与绝望，不甘就这么死去，世间的种种在眼前浮现，我不禁笑了笑，是啊，又有什么可怀念的呢？放弃挣扎的我慢慢下沉，我仿佛看到世间最美的景色，一切是那么安静，祥和，我闭上眼睛，想去感受死亡所带来的一丝不安与恐惧，但我感受到的只有无尽的黑暗和一片虚无。</p>
<p>岸上的那人仿佛冷漠无比，事不关己地看着我，渐渐死去，于是，我便长眠于此，世间再无我的容身之地，我已不复存在，接管这个皮囊的是另一种存在，一种未知的存在，它就在那，就那么默默注视着我，看着我渐渐堕落，迷失自我，取代我的便是它，是我助长它的存在，使它慢慢腐蚀我的灵魂，侵入我的内心，但对此我一无所知，直至此刻，我死了，我才领悟，但也没有什么值得我去留念了，当初的信念早已覆灭，随着我一同消散在这世间。</p>
<p style="text-align:right;">写于高中某天</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>致百日誓师的我</title>
    <url>/2018/09/16/%E8%87%B4%E7%99%BE%E6%97%A5%E8%AA%93%E5%B8%88%E7%9A%84%E6%88%91/</url>
    <content><![CDATA[<p>当我审视自己，我看到了无数个视角下不同的我，为了他人目光活着，有点累，而我却看不清真实的自己到底是哪个，还是说，我早已不是当初的那个我，我曾以为我便是我，一个自由放纵的我，可现实却击中了我，把我击倒在地，我强忍着伤痛，匍匐前进，前方始终是黑暗，我心逐渐绝望，终于，我看清了，我就是我，一个独一无二的我，也许他人目光将我弄得遍体鳞伤，但我终究是我，随自己的心意而活，可是，真的吗？我不禁陷入了深思，我真的能吗？我想这是不可能的，生活本就是一个囚笼，你无法打破它，只能去学会接受它，去改造它，让它变得更加美好，哪怕再不堪，也要好好的，没有人能真正按照自己心意而活，生活本就是如此，面对他人的目光，不要去逃避，不然你终将会被其击倒在地，我挣扎着爬起来，哪怕前方没有光亮，我也要用我这心，去照亮前方，只为那当初的我，于是，我便不断前行，披荆斩棘。</p>
<p>我知道你内心挣扎，并全力克制着疑惑，我理解你每次每次哭泣时的痛苦与无奈，但我早已没了眼泪，被生活磨去了棱角，你本能再坚强一点的，把握明天将给予的一切，但是等待我们的往往是狂风骤雨，不要害怕，去感受它，敞开心胸，让它来吧，学会接受恐惧给你带来的感受，是那么黑暗，那么纯粹，而带来恐惧的正是你的心，不要抵触，让它成为你的一部分，让它驱使你前进，哪怕跟当初的我一样，你也要前行，因为你一旦停止了脚步，你将迷失在这黑暗之中，陷入深潭，恐惧将会吞噬你，所以，接受它吧，没有人能真正按照自己的心意而活，我也不例外，如今我已完全醒悟，过去那些将我击倒的，逐渐使我升华，所以，请不要灰心，相信明天将会是美好的，哪怕狂风骤雨，但你也不怕了，不是吗？勇敢的去面对它，我知道，真正的敌人就在我内心深处，那里是恐惧本源，我须战胜自我，去降服他，可是，我的双手早已无力，我的内心早已千疮百孔，我已无心战斗，但我的灵魂不允许我松懈，于是，我便不断前行，披荆斩棘。</p>
<p>那么，便努力吧，努力做自己，去冲。</p>
<p style="text-align:right;">——致百日誓师的我</p>

<p style="text-align:right;">写于2018-9-16</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>等着</title>
    <url>/2016/09/25/%E7%AD%89%E7%9D%80/</url>
    <content><![CDATA[<p>等<br>一盏明灯<br>照亮我的内心，<br>这样也许<br>就不会如此孤独。</p>
<p>一切由自己面对，<br>哭过笑过，<br>都是独自承受。</p>
<p>他人的眼光，<br>装作无所谓；<br>装作若无其事。<br>其实内心<br>早已千疮百孔。</p>
<p>默默的，<br>多么希望<br>有人能分担一些，<br>但没有。</p>
<p>这也许就是我。<br>也许放弃<br>向往自由，<br>但是被孤独<br>所囚禁了，<br>无法挣脱。<br>默默的。</p>
<p>这也许就是我——至喜欢独自承受的自己（永远）</p>
<p style="text-align:right;">写于2016-09-25</p>

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./whalefall.jpg"
                      width="500px" height="auto" alt="鲸落"
                ><figcaption>鲸落</figcaption></figure>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式提供了一套在特定问题场景下解决软件设计问题的标准化解决方案，能够帮助开发者避免重复造轮子，提高代码的可复用性、可维护性和可扩展性，并且能够使开发过程更加高效、有条理。</p>
<p>在介绍之前先了解下三个原则：单一职责原则、开放-封闭原则和依赖倒转原则。</p>
<blockquote>
<p>单一职责原则</p>
<p>如字面意思所示，对于一个类来说最好只有一个引起它变化的原因。如果一个类承担的职责过多，就相当于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。如果根据职责进行划分，即根据功能进行细化，后续的改动甚至是移植都会变得容易许多，可维护性大大提升，而不是一堆shit mountain摆在面前，不知道从何入手。当然，无需过度细分，实际上，在开发中一般是以功能模块进行划分，而模块内部的各个细节再进行具体划分，做到粗中有细。</p>
</blockquote>
<blockquote>
<p>开放-封闭原则</p>
<p>如字面意思所示，可以进行扩展，但不能进行修改。此处的不能修改并不绝对，而是需要开发者事先预知可能的变化，将这种变化进行抽象，从而实现隔离变化，当发生变化时，只需要增加新代码，而不是修改现有代码。当然，仅需要对频繁做出改变的部分进行抽象，而不是事无巨细，反而会导致过度修改。</p>
</blockquote>
<blockquote>
<p>依赖倒转原则</p>
<p>首先先了解里氏代换原则，即一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换为它的子类，程序的行为并未发生变化，简单来说，就是子类型必须能够替换掉它们的父类型。</p>
<p>抽象不应该依赖于细节，细节应该依赖于抽象，即针对接口编程，不要对实现编程，高层模块不应该依赖低层模块，两个都应该依赖抽象。由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式主要分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是这三类设计模式的简要概述：</p>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这类模式主要关注对象的创建方式，使系统独立于对象的创建、组合和表示方式。常见的创建型模式包括：</p>
<h4 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h4><p>即确保一个类仅存在单个实例，并为该实例提供访问方法，当多线程时，需要提供锁来保证单实例。</p>
<p>单例模式分为饿汉式和懒汉式，饿汉式即一开始就创建实例，而懒汉式则是用到时才构建实例。</p>
<h4 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h4><p>即用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。实际上就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建的细节，将对象初始化为被克隆的对象，然后再根据需要修改部分属性，而不需要从头开始初始化。</p>
<blockquote>
<p>此处克隆分为浅拷贝和深拷贝，这是一个老生常谈的问题，浅拷贝只是引用传递，即拷贝对象只将对象的引用进行拷贝，而真正的数据并有拷贝，即数据只有一份，只要一个地方进行了修改，其他拷贝的地方也会跟着产生变化，如果不想这样，就需要值传递，实现深拷贝方法，重新创建一个跟被拷贝对象一样数据的对象，曾经在写Vue的时候遇到这个坑，直接用等于号赋值，结果临时变量的改变也导致了原本变量的改变，从而导致模版重新渲染，这里就不展开说了，感兴趣的可以搜搜看。对于Java、C#等等面向对象语言来说，都会提供一个Cloneable类，只需要继承该类即可调用clone方法来复制实例，不过此处的clone方法是浅拷贝，如果需要深拷贝，可以进行重写。</p>
</blockquote>
<h4 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h4><p>首先需要了解简单工厂模式，即运用多态，在构造时，构造工厂根据某个属性创建对应的类，这些类都继承于某个抽象类，实现某个公有方法，从而只需要调用该方法即可，不用关心方法是如何实现，当需要变动时，只需要改变对应类的实现，而不用关心其他类的实现。</p>
<p>工厂方法模式将简单工厂模式进一步抽象，把工厂也分为一个个具体的工厂，将原先在工厂内判断的逻辑移动到外部，进一步加强了开放-封闭原则。定义了一个创建对象的接口，让子类决定实例化哪个类。</p>
<h4 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h4><p>创建一系列相关或相互依赖的对象，而无需指定它们具体的类。常常和依赖注入和反射相结合，根据传入的依赖创建不同的实例，从而调用不同的方法，例如数据库连接池druid，它并不感知具体的数据库类型，不论是MySQL还是oracle，都有一套标准，即连接器，只需要方法一致即可。</p>
<h4 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h4><p>即将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>将构建流程标准化形成一个抽象类建造者，其中包含各个步骤，然后再去继承这个抽象类，然后必须实现其中的所有方法，因此不会有遗漏，而再抽象出一个流程类指挥者，传入建造者，调用各个步骤，从而形成具体的流程。部分定制化可以概括这个模式的特点，流程是定死的，但是步骤可定制化，经过不同的步骤，最后呈现的结果也是不同的，但万变不离其宗。</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这类模式主要涉及到类和对象的组合，用于构建大型的对象结构，帮助确保系统的灵活性和高效性。常见的结构型模式包括：</p>
<h4 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h4><p>即将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>适配器模式主要应用于希望复用一些现存的类，但是又与复用环境要求不一致的情况，字面意思，可以联想到电源适配器，将市电转化为直流电，供设备运行，一样的思想，适配，适配，适应配置，当存在复杂且繁杂的代码时，无法对其进行重构，或者重构成本过于昂贵，这时就可以运用适配器模式进行相应的适配，当然，还有第三方接口和自己的接口不匹配，此时也需要进行适配。</p>
<h4 id="装饰者（Decorator）"><a href="#装饰者（Decorator）" class="headerlink" title="装饰者（Decorator）"></a>装饰者（Decorator）</h4><p>即将所需的功能按正确的顺序串联起来控制，动态地给一个对象添加一些额外的职责。</p>
<p>可以理解为一种另类的递归，装饰对象的被装饰物其实还是其他对象的装饰对象，每次先执行之前“装饰”的方法，再执行自己的方法，串成一串，这样就实现了可装配的增强功能，当需要时，可按需进行串联，例如事先的数据校验，增加新的字段，新的逻辑等等。注意，装饰的顺序是很重要的，例如数据校验、加密，不能等到业务处理结束后才进行。装饰模式可以有效地将核心功能和装饰功能分离开来，按照需要进行必要的增强，而不修改核心功能。</p>
<h4 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h4><p>即为其他对象提供一种代理以控制这个对象的访问。</p>
<p>如果有部署过Nginx的应该不陌生，代理服务器，即将收到的请求发送到另一个服务器，收到应答后再将该应答返回，相当于多了一个代理人的概念，当然在传递期间可以做一些额外的事，甚至经过处理而不用继续传递直接返回，一般来说，代理能处理的事，就不用劳烦被请求的对象了。</p>
<h4 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h4><p>即为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加易用。</p>
<p>在设计初期阶段，应该有意识的定义不同的层，每个层都有不同的职责，然后层与层之间通过接口访问，使得耦合大大降低，例如网络的TCPIP模型，再比如后端的数据访问层、业务逻辑层、表示层等等，各司其职，对外提供一组接口供其他层调用，只需要知道这个接口是干啥的，而无需过分关注其中的实现，只要功能没变，调用该接口的地方就无需变动。</p>
<h4 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h4><p>即将抽象部分与它的实现部分分离，使它们都可以单独地变化，简单来说，就是将类的功能层次结构和类的实现层次结构连接起来。</p>
<p>就像系统和软件之间存在的关系，软件在不同的系统中实现有所不同，但是功能是一样的，即仅需定义好功能，然后调用实现即可，功能侧无需关心具体实现。</p>
<p>想要新增功能时，只需在功能侧添加功能类，不必对实现侧进行修改，增加后的功能能被所有实现使用。</p>
<h4 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h4><p>即将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>文件树、窗口视图、权限管理等等，都可以采用组合模式，即可以进行嵌套，当然需要注意有没有嵌套自身，不然就会无限递归下去。</p>
<h4 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h4><p>即运用共享技术有效地支持大量细粒度的对象。</p>
<p>例如字符串常量就可以理解为是享元，相同的字符串常量实际上是在同一块内存，还有线程池、数据库连接池，其实也是享元，只不过是事先建立多个线程或者连接，然后共享，本质是一样的，C语言的文件描述符也是如此，可以事先进行创建，还能节省时间，因为创建比较耗费时间。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这类模式专注于对象之间的通信，用于增强对象之间的协作和职责分配。常见的行为型模式包括：</p>
<h4 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h4><p>即将策略（算法）从单个类剥离出来，定义一个父类，然后分成不同的类继承该父类，这些类都实现对某个问题的处理方法，这样只需要在需要构造的类（上下文）中传入需要的策略，即可调用处理方法，而无需关注内部如何实现。</p>
<p>策略类只需要实现必要的接口，具体的策略类需要实现策略类中定义的接口，而上下文类负责使用策略类，用多态传入不同的具体的策略类。</p>
<p>策略模式有效地将算法和实际应用剥离开来，后续如果要新增策略或者修改策略对应的算法时，只需要对相应的部分进行新增或者修改即可，相当于是委托，是一种弱关联关系，可以很方便地进行替换。</p>
<p>策略模式可以和简单工厂模式相结合，上下文构造时传入的可以是某个属性，再将该属性映射到具体的类。不同模式是可以进行嵌套的，最终境界就是看似没有应用模式，实际都是模式，不需要刻意使用，即化有形为无形。</p>
<h4 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h4><p>又叫发布-订阅模式，即让多个观察者订阅某一个对象，当这个对象状态发生变化时，会通知所有观察者对象执行相应的动作。</p>
<p>消息队列就是经典的观察者模式，以及基于事件驱动的websocket，都是根据“状态”变化来触发对应动作，也就是回调，并不关心是谁触发的，而是关注什么事件被触发了。</p>
<h4 id="责任链（Chain-of-Responsibility）"><a href="#责任链（Chain-of-Responsibility）" class="headerlink" title="责任链（Chain of Responsibility）"></a>责任链（Chain of Responsibility）</h4><p>即使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>相当于踢皮球一样，先看看自身能不能处理，不能就踢给下一个人，以此类推，直到有人进行处理，当然，最后必须保证能处理，不然就没有意义了，就像现实中无意义的互相甩锅（手动狗头</p>
<h4 id="命令（Command）"><a href="#命令（Command）" class="headerlink" title="命令（Command）"></a>命令（Command）</h4><p>即将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p>可以理解为事件驱动，事件触发时将要做的操作加入队列中，或者将操作从队列中删除，当收到执行事件时，将队列中的操作一一执行。</p>
<h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>即用状态决定对象的行为。</p>
<p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，用类表示状态，将冗长的判断切分为一个个状态，分而治之，可以将状态迁移交给各个状态，由自己判断什么时候迁移状态，也可以在外部进行迁移，通过有限状态机可以更好地理解各个状态之间的关系。</p>
<h4 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h4><p>即将数据结构和处理分离开来，使得可以不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p>该模式适用于数据结构相对稳定的系统，这就使得它的优缺点都十分明显，优点就是操作解耦，增加新操作无需修改先前的代码，而缺点就是一旦数据结构变化，需要修改的地方就会分散到各个角落里，难以维护，因此只适用于稳定的数据结构。</p>
<h4 id="中介者（Mediator）"><a href="#中介者（Mediator）" class="headerlink" title="中介者（Mediator）"></a>中介者（Mediator）</h4><p>即用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>相当于由一个路由器决定请求该发往哪里，在web应用中可以用Redis解决跨域问题，不同的网站请求同一个Redis即可，存的cookie可以很容易共享，跟发布&#x2F;订阅模式很像。</p>
<h4 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h4><p>即将对象的状态保存起来，需要时可以进行恢复，就像游戏中的存档和读档。</p>
<p>可以藉由该模式实现状态恢复、状态暂存，甚至还能覆盖保存的状态，可以将状态保存到Redis里，需要时进行取用，可以实现二阶段提交等功能。</p>
<h4 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h4><p>即提供一种方式顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>
<p>该模式实际已经加入语言实现当中，iterator即迭代器，使用该元素即可对集合进行遍历然后进行相同的操作。</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><a class="link"   href="https://baike.baidu.com/item/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7427270" >《Head First设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262" >《大话设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>强烈推荐！！！以浅显易懂地方式介绍了各个模式，建议先阅读，挺有趣的</p>
<p><a class="link"   href="https://baike.baidu.com/item/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22699708" >《图解设计模式》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>具体案例可以看这本，加深理解</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>技术是在总结和否定中不断发展，设计模式就是总结前人惯用的一些思维模式，抽象出来具体的方法，让后来者可以借鉴，领略其中的精妙之处，但23个设计模式并不足以概括此前贡献者的智慧，在我看来，只是冰山一角，更多的奥妙，还需要在接下来的编码生涯中慢慢体会，仔细品味。</p>
<p>不同的语言之间存在实现上的差异，但是处处可见设计模式的身影，这说明了设计模式的技巧被广泛运用，其实这是个先有鸡还是先有蛋的问题，是先有所谓的设计模式，还是先有的技巧，我觉得并不重要，重要的是如何运用所谓的设计模式，要融会贯通，而不仅仅是套用，虽然套用可以省去一些无谓的开销，但是结合具体场景需要对模版进行改进以适应需求。有的时候，套用模版并不是一件好事，这样容易将简单的事情复杂化，个人觉得，需要设计模式的时候，那么这个功能一定是繁杂的，不容易理清的，才需要设计模式的协助，减少出错的概率，就像C语言，并不是面向对象的语言，但是这并不影响面向对象思想的运用，这就要问问神奇的宏了，可以实现多态，进而实现各个设计模式，让我不由得感叹前人的智慧，精妙！</p>
<p>集设计模式为大成的MVC模式，即模型-视图-控制器，最近貌似被DDD模式给创飞了，即领域驱动设计，我对于DDD的了解甚少，在前不久才知道有这么个模式，不过貌似这两个模式可以并存，DDD模式实际上是一种思想。</p>
<p>MVC是一种常见的软件架构模式，用于组织和分离应用程序的逻辑层、表示层和用户交互层。模型负责表示和处理数据，视图负责显示用户界面，控制器负责处理用户交互和调度逻辑。MVC的核心目标是将应用程序的不同功能和职责解耦，使得各个组件可以独立变化，并且提高了应用程序的可维护性和可扩展性。</p>
<p>DDD是一种面向复杂业务领域的软件设计方法，它将关注点放在领域模型的设计和开发上，强调领域专家和开发团队的紧密合作，以达到更好的业务理解和设计实现。它提倡通过领域模型来反映业务需求，将业务逻辑和业务概念抽象为领域对象、值对象、聚合等概念，通过领域模型来实现业务规则和业务流程的核心逻辑。它的核心思想包括战略设计和和战术设计，其中战略设计关注领域模型的整体结构和组织，战术设计则关注具体领域对象和业务逻辑的实现。</p>
<p>二者都是软件开发中的设计模式和思想，它们的目标都是提高软件系统的可维护性、可扩展性和可理解性。二者可以结合使用，DDD的领域模型可以作为MVC模型中的模型部分，MVC模式提供了一种良好的架构和开发模式来组织和展现DDD的领域模型。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>重构</title>
    <url>/2023/11/06/%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重构，即对程序内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构以增加程序的可维护性、可靠性，这是门学问，这与古老的谚语“程序能跑就不要动它”背道而驰，这句谚语也是屎山如何形成的最根本原因，没有定期地重构不合理的代码，使得埋下的坑越来越深，解bug就像探宝一样，时不时能发现其他宝藏：更难解的bug，这就是为什么bug越解越多。当然，重构总是与bug如影随形，这就要求以最小的步伐来进行重构，每一次重构完成时要进行详尽的测试，最好是提供统一稳定的测试环境，按照相同的方法进行测试，以免重构引入bug。</p>
<p>重复的代码块IDE会进行提醒，如果有两个及以上重复就可以考虑抽象出一个函数了，这样当这块代码出错，就无需修改每处地方，仅需修改那个函数，这就是重构，其实我们每天都在进行重构，提炼、分析，从而选出最适合的数据结构，或者逻辑顺序。重构有许多种方法，其中按照既有模版进行重构是最简单的，因此了解设计模式以及类似的思想是很有必要的，可以减少编写代码出错的概率。重构就像是在梳理代码，只有理解了具体的逻辑，重构才成为可能，这就是代码可理解性的重要性，难以理解的设计非常不利于重构，因此，代码可读性优先于其他要义（如果不考虑性能的情况下，如果要进行性能优化，可能就会摒弃可读性，这是没办法的，不过也可以增加适当的注解来提高可读性，不要让别人揣测你代码的意思，而是浅显易懂，这才是好的设计）。讲个笑话，当有天回过头来看之前写的代码，会看不懂，惊呼一句卧槽这啥*玩意，那么就需要进行重构了，如果当初代码的作者都看不明白了，那么指望别人能快速理解代码意图是不太可能了。</p>
<h2 id="设计大于编码"><a href="#设计大于编码" class="headerlink" title="设计大于编码"></a>设计大于编码</h2><p>良好的设计才是快速开发的秘诀，恶劣的设计会使得开发大半的时间都花在不断重复地调试当中，因为程序状况百出，不得不每每打断开发的进度，甚至因为修复bug而打上的补丁会影响后续的开发，使代码愈来愈臃肿，这是我们不希望看见的，因此，我再次强调设计思想的重要性，这是重构的前提。</p>
<p>事先做好设计可以有效减少返工次数，即进行重构的次数，甚至无需进行重构，就能完美符合需求且代码结构清晰，维护容易，当然，不要过度设计，过于揣测之后的变化是不利于开发的，应该能够在满足需求的情况下，然后一定限度地对风险进行预测，考虑增加容错，而不是一上来就“疑神疑鬼”。掌握设计和编码难度的平衡性也是挺困难的，设计为需求而服务，但满足需求并不一定能够实际落地，需要切实考虑编码难度、时间花费、风险控制等等因素，而不是盲目地追求所谓好的设计。在设计前请务必理清需求和度量系统，不要臆测，想当然地以为那样就是那样，需要不断沟通以完善设计。</p>
<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h3><p>这是再正常不过的坏味道了，当一段代码在多处出现，那就要考虑是否需要进行重构了，提炼出重复代码，然后封装到一个函数中，这样出问题只需改一处即可，而不是牵一发而动全身。</p>
<h3 id="过长函数"><a href="#过长函数" class="headerlink" title="过长函数"></a>过长函数</h3><p>当一个函数过长，就要注意了，函数越长，逻辑就越难理清，也就越难维护，所谓屎山就是堆砌起来的，当一段冗长的代码摆在面前，且没有相应注释，我想是个人都会抗拒去阅读它，将这类代码分割成一小块一小块，每一块都是单独的一段逻辑，然后再串联起来，这样不仅能减少临时变量，且还能让逻辑变得清晰明了，最重要的是，复用性大大增加。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
</search>
